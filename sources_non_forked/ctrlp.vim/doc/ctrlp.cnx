*ctrlp.txt*       支持模糊匹配的 文件, 缓冲区, 最近最多使用, 标签, ... 检索. v1.80
*CtrlP* *ControlP* *'ctrlp'* *'ctrl-p'*
===============================================================================
#                                                                             #
#          :::::::: ::::::::::: :::::::::  :::             :::::::::          #
#         :+:    :+:    :+:     :+:    :+: :+:             :+:    :+:         #
#         +:+           +:+     +:+    +:+ +:+             +:+    +:+         #
#         +#+           +#+     +#++:++#:  +#+             +#++:++#+          #
#         +#+           +#+     +#+    +#+ +#+             +#+                #
#         #+#    #+#    #+#     #+#    #+# #+#             #+#                #
#          ########     ###     ###    ### ##########      ###                #
#                                                                             #
===============================================================================
名词对照（译注）

  buffer:缓冲区                    mapping:按键绑定
     mru:最近最多使用               prompt:提示符面板
     tag:标签                          tab:页签
     tab:制表符

===============================================================================
内容                                                            *ctrlp-content*

    1. 介绍.............................................|ctrlp-intro|
    2. 选项.............................................|ctrlp-options|
    3. 命令.............................................|ctrlp-commands|
    4. 按键绑定.........................................|ctrlp-mappings|
    5. 输入格式.........................................|ctrlp-input-formats|
    6. 扩展.............................................|ctrlp-extensions|

===============================================================================
介绍                                                              *ctrlp-intro*

带有直观接口的全路径模糊文件, 缓冲区, 最近最多使用, 标签, ... 检索。
使用纯净的Vimscript编写，可以运行在MacVim，gVim和版本号7.0以上的Vim中。
全面支持Vim的正则表达式 |regexp| 作为搜索模式，内建最近最多使用文件监测，
项目根目录定位和更多特性。

开启可选的扩展（标记，目录，rtscript...），参考 |ctrlp-extensions| 。

===============================================================================
OPTIONS                                                         *ctrlp-options*

总览:~

  |loaded_ctrlp|................禁用插件。
  |ctrlp_map|...................默认按键绑定。
  |ctrlp_cmd|...................默认按键绑定调用的命令。
  |ctrlp_by_filename|...........是否默认开启文件名模式。
  |ctrlp_regexp|................是否默认开启正则表达式模式。
  |ctrlp_match_window|..........匹配窗口的显示位置。
  |ctrlp_switch_buffer|.........如果文件已在缓冲区中打开，跳转到该打开的缓冲区。
  |ctrlp_reuse_window|..........重用特殊窗口（帮助、快速修复 |quickfix| ，等等）。
  |ctrlp_tabpage_position|......新标签页出现的位置。
  |ctrlp_working_path_mode|.....如何设置CtrlP的本地工作目录。
  |ctrlp_root_markers|..........额外的，高优先级的根目录标识。
  |ctrlp_use_caching|...........针对每个会话，设置是否开启缓存的。
  |ctrlp_clear_cache_on_exit|...退出Vim后是否保留缓存。
  |ctrlp_cache_dir|.............缓存目录的位置。
  |ctrlp_show_hidden|...........是否显示隐藏文件和隐藏文件夹。
  |ctrlp_custom_ignore|.........使用 |globpath()| 时自定义忽略的文件或目录。
  |ctrlp_max_files|.............扫描文件的最大数目。
  |ctrlp_max_depth|.............扫描目录的最大层数。
  |ctrlp_user_command|..........使用外部的扫描工具。
  |ctrlp_max_history|...........历史提示符面板中保留的最大条目数。
  |ctrlp_open_new_file|.........由<c-y>创建的文件的打开方式。
  |ctrlp_open_multiple_files|...由<c-z>选择的文件的打开方式。
  |ctrlp_arg_map|...............是否拦截<c-y> 和 <c-o> 命令。
  |ctrlp_follow_symlinks|.......是否跟随链接。
  |ctrlp_lazy_update|...........停止输入时才更新。
  |ctrlp_default_input|.........为提示符面板提供一个初始字符串。
  |ctrlp_abbrev|................输入缩写。
  |ctrlp_key_loop|..............为多字节输入开启输入事件循环。
  |ctrlp_prompt_mappings|.......改变提示符面板内部的按键绑定。
  |ctrlp_line_prefix|...........ctrlp 窗口中为每一行添加前缀。
  |ctrlp_open_single_match|.....当只有一个候选时自动接受。
  |ctrlp_brief_prompt|..........提示符为空的时候使用<bs>退出 CtrlP。
  |ctrlp_match_current_file|....在匹配条目中包含当前文件。
  |ctrlp_types|.................內建类型的名称。

  最近最多使用模式:
  |ctrlp_mruf_max|..............记录的最近最多使用的最大数据。
  |ctrlp_mruf_exclude|..........需要被排除的文件。
  |ctrlp_mruf_include|..........需要被记录的文件。
  |ctrlp_mruf_relative|.........只显示在工作目录内的最近最多使用。
  |ctrlp_tilde_homedir|.........保存 home 目录中的 MRU 的目录路径为波浪扩展的形式 ~/。
  |ctrlp_mruf_default_order|....禁用排序。
  |ctrlp_mruf_case_sensitive|...最近最多使用文件是否大小写敏感。
  |ctrlp_mruf_save_on_update|...只要有一个新的条目添加，就保存到磁盘。

  缓冲模式:
  |ctrlp_bufname_mod|...........文件名部分修饰符。
  |ctrlp_bufpath_mod|...........文件路径部分修饰符。

  缓冲标签模式: (开启此模式，参考 |ctrlp-extensions| )
  |g:ctrlp_buftag_ctags_bin|....兼容的ctags二进制程序的位置。
  |g:ctrlp_buftag_systemenc|....ctags命令的编码。
  |g:ctrlp_buftag_types|........添加新的文件类型和设置命令行参数。

  高级选项:
  |ctrlp_open_func|.............使用自定义的打开文件的函数。
  |ctrlp_status_func|...........改变CtrlP的两个状态栏
  |ctrlp_buffer_func|...........在CtrlP的缓冲区内调用自定义的函数。
  |ctrlp_match_func|............替换内建的匹配算法。

-------------------------------------------------------------------------------
详细描述和默认值:~

                                                                *'g:ctrlp_map'*
使用该选项来改变普通模式 |Normal| 下调用CtrlP的按键绑定: >
  let g:ctrlp_map = '<c-p>'
<

                                                                *'g:ctrlp_cmd'*

设置当按下上面的按键绑定时，使用的默认打开命令: >
  let g:ctrlp_cmd = 'CtrlP'
<

                                                             *'g:loaded_ctrlp'*
使用该选项完全禁用插件: >
  let g:loaded_ctrlp = 1
<

                                                        *'g:ctrlp_by_filename'*
修改该选项为1，设置默认为按文件名搜索（否则为全路径）: >
  let g:ctrlp_by_filename = 0
<
在提示符面板内可以使用 <c-d> 来切换。

                                                             *'g:ctrlp_regexp'*
修改该选项为1，设置默认为使用正则表达式匹配。: >
  let g:ctrlp_regexp = 0
<
在提示符面板内可以使用 <c-r> 来切换。

                                                       *'g:ctrlp_match_window'*
改变匹配窗口的位置，结果的排列顺序，最小和最大高度: >
  let g:ctrlp_match_window = ''
<
例子: >
  let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:10,results:10'
<
位置: (默认:底部)
  top - 在屏幕顶部显示匹配窗口。
  bottom - 在屏幕底部显示匹配窗口。

结果的排列顺序: (默认: btt)
  order:ttb - 从顶部到底部。
  order:btt - 从底部到顶部。

最小和最大高度:
  min:{n} - 最少显示 {n} 行 (默认: 1).
  max:{n} - 最多显示 {n} 行 (默认: 10).

结果集的最大数目:
  results:{n} - 列出最多 {n} 条结果 (默认: 和最大高度同步).
                0代表没有限制。

注意: 当一个设置项没有被设置时，将会使用默认值。

                                                      *'g:ctrlp_switch_buffer'*
当尝试打开一个文件时，如果它已经在某个窗口被打开，CtrlP会尝试跳到那个窗口，而
不是新打开一个实例。: >
  let g:ctrlp_switch_buffer = 'Et'
<
  e - 当 <cr> 被按下时跳转，但是只跳转到当前页签内的窗口内。
  t - 当 <c-t> 被按下时跳转, 但是只跳转到其它标签的窗口内。
  v - 类似 "e", 但是当 <c-v> 被按下时跳转。
  h - 类似 "e", 但是当 <c-x> 被按下时跳转。
  E, T, V, H - 行为类似 "e", "t", "v", and "h", 但是跳转到任何地方的窗口中。
  0 或者 <empty> - 禁用这项功能。

                                                       *'g:ctrlp_reuse_window'*
当使用 <cr> 打开新文件时，CtrlP避免在插件，帮助，快速修复创建的窗口中打开该文
件。使用该选项来设置一些例外: >
  let g:ctrlp_reuse_window = 'netrw'
<
接受的值可以为特殊缓冲区的名字的一部分，文件类型或者缓冲区类型使用正则表达式来
指定匹配模式。
例子: >
  let g:ctrlp_reuse_window = 'netrw\|help\|quickfix'
<

                                                   *'g:ctrlp_tabpage_position'*
新打开页签的位置: >
  let g:ctrlp_tabpage_position = 'ac'
<
  a - 后面。
  b - 前面。
  c - 当前页签。
  l - 最后一个页签。
  f - 第一个页签。

                                                  *'g:ctrlp_working_path_mode'*
当启动时，CtrlP依据这个变量来设置它的工作目录: >
  let g:ctrlp_working_path_mode = 'ra'
<
  c - 当前文件所在的目录。
  a - 当前文件所在的目录，除非这个目录为当前工作目录的子目录
  r - 包含下列文件或者目录的最近的祖先目录:
      .git .hg .svn .bzr _darcs
  w - 用来修饰r：使用当前工作目录而不是当前文件所在目录进行查找
  0 或者 <empty> - 禁用这项功能。

注意 #1: 如果 "a" 或者 "c" 和 "r"一起被包含，当无法找到根目录时使用 "a" 或者
"c" 的行为（作为备选）。

注意 #2: 你可以在每个缓冲区内使用 |b:var| 来设置该选项。

                                                       *'g:ctrlp_root_markers'*
使用该选项来设置自定义的根目录标记作为对默认标记(.hg, .svn, .bzr, and _darcs)
的补充。自定义的标记具有优先权: >
  let g:ctrlp_root_markers = ['']
<
注意: 你可以在每个缓冲区内使用 |b:var| 来设置该选项。

                                                        *'g:ctrlp_use_caching'*
启用/禁用每个会话的缓存: >
  let g:ctrlp_use_caching = 1
<
  0 - 禁用缓存。
  1 - 启用缓存。
  n - 当大于1时，禁用缓存，使用该数值作为重新启用缓存的限制条件。

注意: 当在CtrlP中时你可以使用 <F5> 来快速的清除缓存。

                                                *'g:ctrlp_clear_cache_on_exit'*
设置该选项为0通过退出Vim时不删除缓存文件来启用跨会话的缓存: >
  let g:ctrlp_clear_cache_on_exit = 1
<

                                                          *'g:ctrlp_cache_dir'*
设置存储缓存文件的目录: >
  let g:ctrlp_cache_dir = $HOME.'/.cache/ctrlp'
<

                                                        *'g:ctrlp_show_hidden'*
如果你想CtrlP扫描隐藏文件和目录，设置该选项为1: >
  let g:ctrlp_show_hidden = 0
<
注意: 当命令使用 |g:ctrlp_user_command| 定义时该选项无效。

                                                           *'ctrlp-wildignore'*
你可以使用Vim的 |'wildignore'| 来从结果集中排序文件或目录。
例子: >
  " 排除版本控制文件
  set wildignore+=*/.git/*,*/.hg/*,*/.svn/*        " Linux/MacOSX
  set wildignore+=*\\.git\\*,*\\.hg\\*,*\\.svn\\*  " Windows ('noshellslash')
<
注意 #1: 每个目录设置前的字符 `*/` 是必须的。

注意 #2: |wildignore| 影响 |expand()| ， |globpath()| 和 |glob()| 的结果，这些函数被很
多插件用来在系统中执行查找。（例如和版本控制系统有关的插件在查找.git/、.hg/等，
一些其他插件用来在Windows上查找外部的*.exe工具），所以要修改 |wildignore| 时请先
考虑清楚。

                                                      *'g:ctrlp_custom_ignore'*
作为对 |'wildignore'| 和 |g:ctrlp_show_hidden| 的补充，用来设置你只是想在CtrlP中隐藏的文件和目录。使用正
则表达式来指定匹配模式: >
  let g:ctrlp_custom_ignore = ''
<
例子: >
  let g:ctrlp_custom_ignore = '\v[\/]\.(git|hg|svn)$'
  let g:ctrlp_custom_ignore = {
    \ 'dir':  '\v[\/]\.(git|hg|svn)$',
    \ 'file': '\v\.(exe|so|dll)$',
    \ 'link': 'SOME_BAD_SYMBOLIC_LINKS',
    \ }
  let g:ctrlp_custom_ignore = {
    \ 'file': '\v(\.cpp|\.h|\.hh|\.cxx)@<!$'
    \ }
  let g:ctrlp_custom_ignore = {
    \ 'func': 'some#custom#match_function'
    \ }
<
注意 #1: 默认情况下， |wildignore| 和 |g:ctrlp_custom_ignore| 只在 |globpath()| 被用
来扫描文件的情况下使用，这样这些选项在那些使用 |g:ctrlp_user_command| 定义的命
令中不会生效。

注意 #2: 当改变选项的变量类型时，记得先 |:unlet| ，或者重启Vim来避免这个错误：
"E706: Variable type mismatch" 。

注意 #3: 当使用函数来忽略类型时，你必须提供CtrlP可以调用的函数的全名。建议使用
自动加载的函数。函数必须接受两个参数，要匹配的条目和接受的类型，类型可以是目
录、文件和链接。如果条目被忽略，函数需要返回1，反之，返回0。

                                                          *'g:ctrlp_max_files'*
扫描文件的最大数量，设置为0时不进行限制: >
  let g:ctrlp_max_files = 10000
<
注意: 当命令使用 |g:ctrlp_user_command| 定义时该选项无效。

                                                          *'g:ctrlp_max_depth'*
目录树递归的最大层数: >
  let g:ctrlp_max_depth = 40
<
注意: 当命令使用 |g:ctrlp_user_command| 定义时该选项无效。

                                                       *'g:ctrlp_user_command'*
指定用来代替Vim的 |globpath()| 的外部工具来列出文件，使用 %s 代表目标目录: >
  let g:ctrlp_user_command = ''
<
例子: >
  let g:ctrlp_user_command = 'find %s -type f'       " MacOSX/Linux
  let g:ctrlp_user_command = 'dir %s /-n /b /s /a-d' " Windows
<
你也可以使用 'grep', 'findstr' 或者其它东西来过滤结果集。
例子: >
  let g:ctrlp_user_command =
    \ 'find %s -type f | grep -v -P "\.jpg$|/tmp/"'          " MacOSX/Linux
  let g:ctrlp_user_command =
    \ 'dir %s /-n /b /s /a-d | findstr /v /l ".jpg \\tmp\\"' " Windows
<
在扫描一个大型项目时，在仓库目录中使用版本控制系统的列出命令会加快扫描速度: >
  let g:ctrlp_user_command = [root_marker, listing_command, fallback_command]
  let g:ctrlp_user_command = {
    \ 'types': {
      \ 1: [root_marker_1, listing_command_1],
      \ n: [root_marker_n, listing_command_n],
      \ },
    \ 'fallback': fallback_command,
    \ 'ignore': 0 or 1
    \ }
<
一些例子: >
  " 单个版本控制系统，列出命令不会列出没有被追踪的文件:
  let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files']
  let g:ctrlp_user_command = ['.hg', 'hg --cwd %s locate -I .']

  " 多个版本控制系统:
  let g:ctrlp_user_command = {
    \ 'types': {
      \ 1: ['.git', 'cd %s && git ls-files'],
      \ 2: ['.hg', 'hg --cwd %s locate -I .'],
      \ },
    \ 'fallback': 'find %s -type f'
    \ }

  " 单个版本控制系统，列出命令列出没有被追踪的文件（较慢）:
  let g:ctrlp_user_command =
    \ ['.git', 'cd %s && git ls-files -co --exclude-standard']

  let g:ctrlp_user_command =
    \ ['.hg', 'hg --cwd %s status -numac -I . $(hg root)'] " MacOSX/Linux

  let g:ctrlp_user_command = ['.hg', 'for /f "tokens=1" %%a in (''hg root'') '
    \ . 'do hg --cwd %s status -numac -I . %%a']           " Windows
<
注意 #1: 在 |Dictionary| 格式, 'fallback' 和 'ignore' 是可选的，在 |List| 格式，
备选命令是可选的。

注意 #2: 如果备选命令是空的或者属性 'fallback' 没有定义，当扫描仓库之外目录时，
|globpath()| 会被使用。

注意 #3: 除非使用了 |Dictionary| 格式并且 'ignore' 被定义并且设置为1，当这些自
定义的命令被使用时 |wildignore| 和 |g:ctrlp_custom_ignore| 选项不会生效。没有出现
时，'ignore' 被默认设置为0来保留使用外部命令的性能优势。

注意 #4: 当改变了选项的变量类型时，记得先 |:unlet| ，或者重启Vim来避免这个错误：
"E706: Variable type mismatch" 。

注意 #5: 你可以在每个缓冲区内使用 |b:var| 来设置该选项。

                                                        *'g:ctrlp_max_history'*
你希望CtrlP记录的用户输入历史的最大数目。默认值是Vim的全局选项 |'history'| : >
  let g:ctrlp_max_history = &history
<
设置为0来禁用提示符面板的历史。使用 <c-n> 和 <c-p> 来浏览历史。

                                                      *'g:ctrlp_open_new_file'*
使用该选项指定当使用 <c-y> 打开新建的文件时，文件的打开方式: >
  let g:ctrlp_open_new_file = 'v'
<
  t - 在新页签中。
  h - 在新的水平分割窗口。
  v - 在新的竖直分割窗口。
  r - 在当前窗口。

                                                *'g:ctrlp_open_multiple_files'*
如果非0， 会启用使用 <c-z> 和 <c-o> 打开多个文件: >
  let g:ctrlp_open_multiple_files = 'v'
<
例子: >
  let g:ctrlp_open_multiple_files = '2vjr'
<
对于数字:
  - 如果指定，会被用来作为打开文件时创建的窗口或者页签的最大数量（剩余的会在隐
    藏的缓冲区中打开）。
  - 如果没有指定，<c-o> 会打开所有文件，每个在一个新的窗口或者页签中。

对于字母:
  t - 每个文件在一个新页签中。
  h - 每个文件在一个新的水平分割窗口中。
  v - 每个文件在一个新的竖直分割窗口中。
  i - 所有的文件在隐藏的缓冲区中。
  j - 打开以后，跳转到第一个打开的页签或者窗口。
  r - 在当前窗口打开第一个文件，其他文件根据同时出现的"h"，"v"和"t"中的一个，
      在新的分割窗口或者页签中打开。

                                                            *'g:ctrlp_arg_map'*
当设置为1时， <c-o> 和 <c-y> 会接收一个额外的键值作为参数，来覆盖默认行为: >
  let g:ctrlp_arg_map = 0
<
按下 <c-o> 或者 <c-y> 会提示一次按键。按键可以是:
  t - 在新标签页中打开。
  h - 每个文件在一个新的水平分割窗口中。
  v - 每个文件在一个新的竖直分割窗口中。
  i - 所有的文件在隐藏的缓冲区中（只有 <c-o> 生效）。
  c - 清楚标记的文件（只有 <c-o> 生效）。
  r - 在当前窗口中打开（只有 <c-y> 生效）。
  <esc>, <c-c>, <c-u> - 取消并且回到提示符面板。
  <cr> - 使用 |g:ctrlp_open_new_file| 和 |g:ctrlp_open_multiple_files| 指定的默
         认行为。


                                                    *'g:ctrlp_follow_symlinks'*
如果非0，当列出文件时CtrlP会跟随链接: >
  let g:ctrlp_follow_symlinks = 0
<
  0 - 不要跟随链接。
  1 - 跟随但是忽略内部循环的链接，避免重复。
  2 - 无差别的跟随所有链接。

注意: 当命令使用 |g:ctrlp_user_command| 定义时该选项无效。

                                                        *'g:ctrlp_lazy_update'*
设置为1将或更大可开启延迟更新特性：只在输入停止一个确定的时间后才更新匹配窗口:
>
  let g:ctrlp_lazy_update = 0
<
如果设置为1，在250毫秒后更新該值作為默認值。如果大于1，数字会被作为延迟时间使
用。

                                                      *'g:ctrlp_default_input'*
设置为1将为提示符面板提供当前文件的相对路径作为种子: >
  let g:ctrlp_default_input = 0
<
如果不指定1或0，如果选项的值是字符串，会被用来作为默认输入: >
  let g:ctrlp_default_input = 'anystring'
<
这个选项可以和 |g:ctrlp_open_single_match| 配合使用。


                                                 *'g:ctrlp_match_current_file'*
在匹配条目中包含当前文件: >
  let g:ctrlp_match_current_file = 1

默认情况下，当前文件不包含在列表中。

注意: 当使用 |g:ctrlp_match_func| 时不会应用这个选项。

                                                              *'g:ctrlp_types'*
通过设置这个列表变量的值来定制核心类型: >
  let g:ctrlp_types = ['mru', 'fil']

类型默认为: >
  let g:ctrlp_types = ['fil', 'buf', 'mru'].

                                                             *'g:ctrlp_abbrev'*
定义可以在提示面包内被扩展（内部的或者可见的）的输入缩写: >
  let g:ctrlp_abbrev = {}
<
例子: >
  let g:ctrlp_abbrev = {
    \ 'gmode': 'i',
    \ 'abbrevs': [
      \ {
        \ 'pattern': '^cd b',
        \ 'expanded': '@cd ~/.vim/bundle',
        \ 'mode': 'pfrz',
      \ },
      \ {
        \ 'pattern': '\(^@.\+\|\\\@<!:.\+\)\@<! ',
        \ 'expanded': '.\{-}',
        \ 'mode': 'pfr',
      \ },
      \ {
        \ 'pattern': '\\\@<!:.\+\zs\\\@<! ',
        \ 'expanded': '\ ',
        \ 'mode': 'pfz',
      \ },
      \ ]
    \ }
<
字符串 'pattern' 是使用正则表达式来匹配输入的匹配模式。扩展后就像扩展后的字符串
在提示符面板中被输入了一样。

对于 'gmode' （可选的）:
  i - 内部扩展（默认）。
  t - 插入扩展结果到提示符面板，就像你自己输入的一样。
  k - 当非关键字的字符被输入时，插入扩展结果到提示符面板。只在"t"也出现时生效。

对于 'mode' （对于每个条目，可选的）:
  f - 只应用于文件名模式。
  p - 只应用于全路径模式。
  r - 只应用于正则表达式模式。
  z - 只应用于模糊模式。
  n - 只应用于使用 <c-y> 创建新文件时（使用扩展后的字符串作为文件名）。
  c - 当使用 <tab> 自动补全目录名时（在自动补全之前立即扩展模式）。
  <empty> 或者未定义 - 总是启用。

注意: 缩写条目按顺序求值，后求值的条目会覆盖先求值的条目；当 'gmode' 为"t"时，
包括他自己。

                                                           *'g:ctrlp_key_loop'*
一个实验性的特性。设置该选项为1将为多字节字符开启输入事件循环: >
  let g:ctrlp_key_loop = 0
<
注意 #1: 当设置时，该选项会重置 |g:ctrlp_lazy_update| 选项。

注意 #2: 你可以在提示符面板使用自定义的按键绑定切换这个特性: >
  let g:ctrlp_prompt_mappings = { 'ToggleKeyLoop()': ['<F3>'] }
<

                                                    *'g:ctrlp_prompt_mappings'*
使用该选项来自定义CtrlP的提示窗口内的按键绑定为你喜欢的方式。你只需要保留你改
变值（在[]内部）的行: >
  let g:ctrlp_prompt_mappings = {
    \ 'PrtBS()':              ['<bs>', '<c-]>'],
    \ 'PrtDelete()':          ['<del>'],
    \ 'PrtDeleteWord()':      ['<c-w>'],
    \ 'PrtClear()':           ['<c-u>'],
    \ 'PrtSelectMove("j")':   ['<c-j>', '<down>'],
    \ 'PrtSelectMove("k")':   ['<c-k>', '<up>'],
    \ 'PrtSelectMove("t")':   ['<Home>', '<kHome>'],
    \ 'PrtSelectMove("b")':   ['<End>', '<kEnd>'],
    \ 'PrtSelectMove("u")':   ['<PageUp>', '<kPageUp>'],
    \ 'PrtSelectMove("d")':   ['<PageDown>', '<kPageDown>'],
    \ 'PrtHistory(-1)':       ['<c-n>'],
    \ 'PrtHistory(1)':        ['<c-p>'],
    \ 'AcceptSelection("e")': ['<cr>', '<2-LeftMouse>'],
    \ 'AcceptSelection("h")': ['<c-x>', '<c-cr>', '<c-s>'],
    \ 'AcceptSelection("t")': ['<c-t>'],
    \ 'AcceptSelection("v")': ['<c-v>', '<RightMouse>'],
    \ 'ToggleFocus()':        ['<s-tab>'],
    \ 'ToggleRegex()':        ['<c-r>'],
    \ 'ToggleByFname()':      ['<c-d>'],
    \ 'ToggleType(1)':        ['<c-f>', '<c-up>'],
    \ 'ToggleType(-1)':       ['<c-b>', '<c-down>'],
    \ 'PrtExpandDir()':       ['<tab>'],
    \ 'PrtInsert("c")':       ['<MiddleMouse>', '<insert>'],
    \ 'PrtInsert()':          ['<c-\>'],
    \ 'PrtCurStart()':        ['<c-a>'],
    \ 'PrtCurEnd()':          ['<c-e>'],
    \ 'PrtCurLeft()':         ['<c-h>', '<left>', '<c-^>'],
    \ 'PrtCurRight()':        ['<c-l>', '<right>'],
    \ 'PrtClearCache()':      ['<F5>'],
    \ 'PrtDeleteEnt()':       ['<F7>'],
    \ 'CreateNewFile()':      ['<c-y>'],
    \ 'MarkToOpen()':         ['<c-z>'],
    \ 'OpenMulti()':          ['<c-o>'],
    \ 'PrtExit()':            ['<esc>', '<c-c>', '<c-g>'],
    \ }
<
注意: 如果按 <bs> 后光标向左移动一个字符而不是删除一个字符，在你的.vimrc中添加
下面的设置来禁用插件默认的 <c-h> 绑定: >
  let g:ctrlp_prompt_mappings = { 'PrtCurLeft()': ['<left>', '<c-^>'] }
<

                                                    *'g:ctrlp_line_prefix'*
这个前缀会被加到ctrlp的条目列表中每一行的前面。
默认值: >
  let g:ctrlp_line_prefix = '> '
<

                                                    *'g:ctrlp_open_single_match'*
当CtrlP处于列表中配置的模式中时，如果只有一个候选条目，CtrlP会直接接受该条目。
例子: >
  let g:ctrlp_open_single_match = ['buffer tags', 'buffer']
<
目前这个选项的作用是和 |g:ctrlp_default_input| 一起，使用类似下面的函数，在使用
前设置，使用完后还原： >
  fu! <SID>tagsUnderCursor()
    try
      let default_input_save = get(g:, 'ctrlp_default_input', '')
      let g:ctrlp_default_input = expand('<cword>')
      CtrlPBufTagAll
    finally
      if exists('default_input_save')
        let g:ctrlp_default_input = default_input_save
      endif
    endtry
  endfu
>
<
----------------------------------------
MRU mode options:~

                                                           *'g:ctrlp_mruf_max'*
指定你希望CtrlP记录的最近打开的文件历史的数目: >
  let g:ctrlp_mruf_max = 250
<

                                                       *'g:ctrlp_mruf_exclude'*
你不希望CtrlP记录的文件。使用正则表达式来指定模式: >
  let g:ctrlp_mruf_exclude = ''
<
例子: >
  let g:ctrlp_mruf_exclude = '/tmp/.*\|/temp/.*' " MacOSX/Linux
  let g:ctrlp_mruf_exclude = '^C:\\dev\\tmp\\.*' " Windows
<

                                                       *'g:ctrlp_mruf_include'*
如果你想让CtrlP只记录某些文件，在这里指定: >
  let g:ctrlp_mruf_include = ''
<
例子: >
  let g:ctrlp_mruf_include = '\.py$\|\.rb$'
<
                                                       *'g:ctrlp_tilde_homedir'*
将这个选项设置为1来把所有的 MRU 文件路径中 $HOME 目录下的 $HOME/$filepath 保存
为 ~/$filepath ，而不是 $HOME/$filepath : >
  let g:ctrlp_tilde_homedir = 0
<
注意: 对所有通过 :CtrlPBookmarkDirAdd! 保存的也有效

                                                      *'g:ctrlp_mruf_relative'*
设置该选项为1将只显示在当前工作目录内的最近最多使用文件: >
  let g:ctrlp_mruf_relative = 0
<
注意: 你可以在提示符面板使用自定义的按键绑定切换这个特性: >
  let g:ctrlp_prompt_mappings = { 'ToggleMRURelative()': ['<F2>'] }
<

                                                 *'g:ctrlp_mruf_default_order'*
设置该选项为1将在最近最多使用模式搜索时禁用排序: >
  let g:ctrlp_mruf_default_order = 0
<

                                                *'g:ctrlp_mruf_case_sensitive'*
将该选项和你的文件系统大小写敏感性保持一致来避免重复的最近最多使用条目: >
  let g:ctrlp_mruf_case_sensitive = 1
<

                                                *'g:ctrlp_mruf_save_on_update'*
设置该选项为 0 禁止 CtrlP 每当有一个新条目增加就把最近最多使用列表保存到磁盘
文件，而是在退出Vim时才保存: >
  let g:ctrlp_mruf_save_on_update = 1
<
                                                *'g:ctrlp_bufname_mod'*
根据修饰符修改文件名部分。参见 |filename-modifiers| 。 >
  let g:ctrlp_bufname_mod = ':t'
<
                                                *'g:ctrlp_bufpath_mod'*
根据修饰符修改文件路径部分。参见 |filename-modifiers| 。 >
  let g:ctrlp_bufpath_mod = ':~:.:h'
<
----------------------------------------
高级选项:~

                                                          *'g:ctrlp_open_func'*
使用一个自定义函数来打开选定的文件: >
  let g:ctrlp_open_func = {}
<
例子: >
  let g:ctrlp_open_func = {
    \ 'files'     : 'Function_Name_1',
    \ 'buffers'   : 'Function_Name_2',
    \ 'mru files' : 'Function_Name_3',
    \ }
<
函数结构: >
  function! Function_Name(action, line)
    " 参数:
    " |
    " +- a:action : 打开的动作:
    " |             + 'e' : 用户按下 <cr>  (默认)
    " |             + 'h' : 用户按下 <c-x> (默认)
    " |             + 'v' : 用户按下 <c-v> (默认)
    " |             + 't' : 用户按下 <c-t> (默认)
    " |             + 'x' : 用户使用 <c-o> 终端对话框 (默认) 选择"e[x]ternal"。
    " |
    " +- a:line   : 选择的文件。

  endfunction
<
注意: 当使用<c-z> 和 <c-o>打开多个文件时无效。

例子: 当 <c-t> 被按下时在默认浏览器中打开HTML文件，否则在Vim中打开 >
  function! HTMLOpenFunc(action, line)
    if a:action =~ '^[tx]$' && fnamemodify(a:line, ':e') =~? '^html\?$'

      " 获取文件名
      let filename = fnameescape(fnamemodify(a:line, ':p'))

      " 关闭CtrlP
      call ctrlp#exit()

      " 打开文件
      silent! execute '!xdg-open' filename

    elseif a:action == 'x' && fnamemodify(a:line, ':e') !~? '^html\?$'

      " 不是HTML文件，再次模拟 <c-o> 按键并且等待新的输入
      call feedkeys("\<c-o>")

    else

      " 使用CtrlP的默认的打开文件的函数
      call call('ctrlp#acceptfile', [a:action, a:line])

    endif
  endfunction

  let g:ctrlp_open_func = { 'files': 'HTMLOpenFunc' }
<

                                                        *'g:ctrlp_status_func'*
为CtrlP窗口使用自定义的状态栏: >
  let g:ctrlp_status_func = {}
<
例子: >
  let g:ctrlp_status_func = {
    \ 'main': 'Function_Name_1',
    \ 'prog': 'Function_Name_2',
    \ }
<
函数结构: >
  " 主状态栏
  function! Function_Name_1(focus, byfname, regex, prev, item, next, marked)
    " 参数:
    " |
    " +- a:focus   : 提示符面板的焦点: "prt" 或者 "win"。
    " |
    " +- a:byfname : 在文件名模式还是全路径模式: "file" 或者 "path"。
    " |
    " +- a:regex   : 是否在正则表达式模式: 1 or 0。
    " |
    " +- a:prev    : 前一个搜索模式。
    " |
    " +- a:item    : 当前的搜索模式。
    " |
    " +- a:next    : 下一个搜索模式。
    " |
    " +- a:marked  : 被标记文件的数目，或者一个逗号分隔的被标记的文件名列表。

    return full_statusline
  endfunction

  " 状态栏进度条
  function! Function_Name_2(str)
    " a:str : 一个当前已扫描的文件数，或者一个当前扫描目录和用户命令的字符串。

    return full_statusline
  endfunction
<
一个可用的例子，参见 https://gist.github.com/1610859 。

                                                        *'g:ctrlp_buffer_func'*
指定一个会在启动或者退出CtrlP缓冲区时被调用的函数: >
  let g:ctrlp_buffer_func = {}
<
例子: >
  let g:ctrlp_buffer_func = {
    \ 'enter': 'Function_Name_1',
    \ 'exit':  'Function_Name_2',
    \ }
<

                                                         *'g:ctrlp_match_func'*
为CtrlP设置一个额外的模糊匹配函数: >
  let g:ctrlp_match_func = {}
<
例子: >
  let g:ctrlp_match_func = { 'match': 'Function_Name' }
<
函数结构: >
  function! Function_Name(items, str, limit, mmode, ispath, crfile, regex)
    " 参数:
    " |
    " +- a:items  : 搜索条目的全列表。
    " |
    " +- a:str    : 用户输入的字符串。
    " |
    " +- a:limit  : 匹配窗口的最大高度。可以用来限制返回的条目数量。
    " |
    " +- a:mmode  : 在匹配模式。可以是下列字符串之一:
    " |             + "full-line": 匹配整行。
    " |             + "filename-only": 只匹配文件名。
    " |             + "first-non-tab": 匹配到第一个制表符。
    " |             + "until-last-tab": 匹配到最后一个制表符。
    " |
    " +- a:ispath : 搜索文件，缓冲区，最近最多使用，混合，目录和rtscript模.
    " |             式时为1。其它为0。
    " |
    " +- a:crfile : 当前窗口中的文件。当a:ispath为1时应该被搜索结果排除在外
    " |
    " +- a:regex  : 是否在正则表达式模式: 1 or 0.

    return list_of_matched_items
  endfunction
<

注意: 你可以通过 { 'arg_type': 'dict' } 扩展上面的任何选项，这样就可以通过
一个字典类型的参数来传递所有的函数参数。使用参数名作为字典的键值。

例子: >
  let g:ctrlp_status_func = {
    \ 'arg_type' : 'dict',
    \ 'enter': 'Function_Name_1',
    \ 'exit':  'Function_Name_2',
    \ }

  function! Function_Name_1(dict)
    " where dict == {
    " \ 'focus':   value,
    " \ 'byfname': value,
    " \ 'regex':   value,
    " \ ...
    " }
  endfunction
<
                                                       *'g:ctrlp_brief_prompt'*
当设置为 1 时, 提示符后为空时按 <bs> 会退出 CtrlP 。

                                                          *ctrlp-default-value*
另外，你可以使用下面的方式来改变默认值。
例子: >
  let g:ctrlp_path_nolim = 1

这样可以让无限制模式匹配“路径”类型。
===============================================================================
命令                                                           *ctrlp-commands*

                                                                       *:CtrlP*
:CtrlP [起始目录]
   用文件搜索模式打开CtrlP。

   如果没有给定参数，|g:ctrlp_working_path_mode| 会被用来决定起始目录。临时覆盖
   这个参数 的方法见 |:CtrlPCurFile| 和 |:CtrlPCurWD| 。

   在输入时你可以使用 <tab> 自动补全[起始目录]。

                                                                 *:CtrlPBuffer*
:CtrlPBuffer
   用缓冲区搜索模式打开CtrlP。

                                                                *:CtrlPCurFile*
:CtrlPCurFile
    行为类似变量 |g:ctrlp_working_path_mode| = '' 时执行 |:CtrlP| ，忽略这个变量
    现在的值。

                                                                  *:CtrlPCurWD*
:CtrlPCurWD
    行为类似变量 |g:ctrlp_working_path_mode| = '' 时执行 |:CtrlP| ，忽略这个变量
    现在的值。

                                                                    *:CtrlPMRU*
:CtrlPMRU
   用最近最多使用模式打开CtrlP。

                                                               *:CtrlPLastMode*
:CtrlPLastMode [--dir]
   用上一次使用的模式打开CtrlP。当提供了"--dir"参数，也重用上一次的工作目录。

                                                                   *:CtrlPRoot*
:CtrlPRoot
    行为类似使用了 |g:ctrlp_working_path_mode| = 'r' 并且忽略了该变量的当前值的
    |:CtrlP| 命令。

                                                             *:CtrlPClearCache*
:CtrlPClearCache
   清除当前工作目录的缓存。和在CtrlP内按 <F5> 效果一样。
   使用 |g:ctrlp_use_caching| 来启用或禁用缓存。

                                                         *:CtrlPClearAllCaches*
:CtrlPClearAllCaches
   删除在 |g:ctrlp_cache_dir| 中定义的缓存目录中的所有缓存文件。

-------------------------------------------------------------------------------
由扩展提供的命令参见 |ctrlp-extensions| 。

===============================================================================
按键绑定                                                        *ctrlp-mappings*

                                                                *'ctrlp-<c-p>'*
<c-p>
   普通模式 |Normal| 下默认以文件搜索模式打开CtrlP提示符面板。

----------------------------------------
已经在提示符面板中:~

  <c-d>
    在全路径搜索和文件名搜索间切换。
    注意: 在文件名搜索模式，提示符面板的提示符是'>d>'，而不是'>>>'

  <c-r>                                                    *'ctrlp-fullregexp'*
    在字符串搜索模式和正则表达式模式之间切换。
    注意: 在全正则表达式模式，提示符面板的提示符是'r>>'，而不是'>>>'

    详细参见: |input-formats| （指引）和 |g:ctrlp_regexp_search| 选项。

  <c-f>, 'forward' 前进
  <c-up>
    切换到序列里面的 'next' 后一个搜索模式。

  <c-b>, 'backward' 后退
  <c-down>
    切换到序列里面的 'previous' 前一个搜索模式。

  <tab>                                                *'ctrlp-autocompletion'*
    自动补全在提示符面板的当前工作路径中的目录名。

  <s-tab>
    在匹配窗口和提示符面板之间切换焦点。

  <esc>,
  <c-c>,
  <c-g>
    退出CtrlP。

移动:~

  <c-j>,
  <down>
    向下移动。

  <c-k>,
  <up>
    向上移动。

  <c-a>
    移动光标到提示符面板的 'start' 开头。

  <c-e>
    移动光标到提示符面板的 'end' 末尾。

  <c-h>,
  <left>,
  <c-^>
    向左 'left' 移动一个字符。

  <c-l>,
  <right>
    向右 'right' 移动一个字符。

编辑:~

  <c-]>,
  <bs>
    删除前一个字符。

  <del>
    删除当前字符。

  <c-w>
    删除前一个单词。

  <c-u>
    清除输入。

浏览输入历史:~

  <c-n>
    提示符面板历史里的下一个字符串。

  <c-p>
    提示符面板历史里的上一个字符串。

打开/创建文件:~

  <cr>
    如果可能的话在 'current' 当前窗口打开选择的文件。

  <c-t>
    在 'tab' 新标签打开选择的文件。
    Open the selected file in a new 'tab'.

  <c-v>
    在 'vertical' 竖直分割窗口打开选择的文件。

  <c-x>,
  <c-cr>,
  <c-s>
    在 'horizontal' 水平分割窗口打开选择的文件。

  <c-y>
    创建一个新文件和它的父目录。

打开多个文件:~

  <c-z>
    - 标记/取消标记一个被 <c-o> 打开的文件。
    - 标记/取消标记一个被 <c-y> 在它的目录被创建的文件。

  <c-o>
    - 打开被 <c-z> 标记的文件。
    - 当没有文件被 <c-z> 标记时，使用下列选项打开一个终端对话框:

      打开被选择的文件:
        t - 在新标签页中打开。
        v - 在一个竖直分割窗口中。
        h - 在一个水平分割窗口中。
        r - 在当前窗口中打开。
        i - 在隐藏的缓冲区中。
        x - （可选的）使用 |g:ctrlp_open_func| 中定义的函数。

      其它选项 （未显示）:
        a - 标记匹配窗口中的所有文件。
        d - 改变CtrlP的工作目录到被选择的文件的目录并切换到文件搜索模式。

功能按键绑定:~

  <F5>
    - 刷新匹配窗口并且清除当前目录的缓存。
    - 从最近最多使用中移除被删除的文件。

  <F7>
    最近最多使用模式：
    - 清除最近最多使用列表。
    - 删除被 <c-z> 标记的最近最多使用条目。
    缓冲区模式：
    - 删除光标下的条目或者删除被 <c-z> 标记的多个条目。

粘贴:~

  <Insert>,                                                   *'ctrlp-pasting'*
  <MiddleMouse>
    将剪贴板中的文本粘贴到提示符窗口中。

  <c-\>
    打开一个终端对话框来粘贴 <cword>， <cfile>，搜索寄存器的文本，上一次可视
    化模式的选择，剪贴板或者任何寄存器到提示符面板中。

使用 |g:ctrlp_prompt_mappings| 选择你自己的绑定。

----------------------------------------
当焦点在匹配窗口中时（使用 <s-tab> 来切换）:~

  a-z
  0-9
  ~^-=;`',.+!@#$%&_(){}[]
    在匹配第一个字符的行中循环。

===============================================================================
输入格式                                                  *ctrlp-input-formats*

提示符面板的输入格式:~

a)  字符串。

    例如: 'abc' 被内部理解为 'a[^a]\{-}b[^b]\{-}c'

b)  在正则表达式模式，输入字符串被按照Vim的正则表达式模式 |pattern| 来对待，不
    进行任何修改。

    例如: 'abc\d*efg' 会被解读为 'abc\d*efg'。

    如何启用正则表达式模式参见 |ctrlp-fullregexp| （按键绑定）和
    |g:ctrlp_regexp_search| （选项）。

c)  字符串末尾使用一个冒号':'跟随一个Vim命令来在打开那个文件后执行该命令。如果
    你需要使用':'的字面意思，使用反斜杠转义'\:'。但打开多个文件时，命令会在每
    个打开文件上执行。

    例如: 使用':45'跳转到第45行。

          使用':/any\:string'跳转到'any:string'第一次出现的地方。

          使用':+setf\ myfiletype|50'来设置文件类型为 'myfiletype'，然后跳转
          到第50行。

          使用':diffthis'当打开多个文件时在前四个文件上调用 |:diffthis| 。

    参见: Vim的 |++opt| 和 |+cmd|.

d)  提交两个点号 '..' 来进入上级目录。如果想进入向上多级目录，每多一级使用一个
    额外的点号:
>
         输入         解释为
         ..           ../
         ...          ../../
         ....         ../../../
<
    注意: 如果父目录很大并且没有被缓存，可能会很慢。

    你可以使用'@cd path/'来改变CtrlP的工作目录为path/。使用'@cd %:h'来改变为当
    前文件的目录。

e)  类似的，提交'/'或者'\'来查找或者跳转到项目的根目录。

    如果项目很大，使用版本控制系统的列出命令来寻找文件可能会加速初始化扫描。（
    更多细节参见 |g:ctrlp_user_command| )。

    注意: d) 和 e) 只在文件，目录和混合模式生效。

f)  输入一个不存在的文件名并且按下 <c-y> 来创建文件。如果使用 <c-z> 标记了一个
    文件，将会在被标记的文件的目录下创建这个新文件。

    例如: 使用 'newdir/newfile.txt' 会创建一个名为'newdir'的目录和一个名为
          'newfile.txt'的文件。

          如果一个条目'some/old/dirs/oldfile.txt'被 <c-z> 标记，然后 'newdir'
          和'newfile.txt'会在'some/old/dirs'下被创建。最终的路径会像下面这样
          'some/old/dirs/newdir/newfile.txt'.

    注意: 在Windows下使用 '\' 代替 '/' （如果 |'shellslash'| 选项没有设置）。

g)  在文件名模式（使用 <c-d> 切换）下，你可以使用被逗号分隔的一个主要的模式和
    一个改善的模式。两个模式在正则表达式模式下像（a）或（b）那样工作。

h)  使用?打开帮助文件。

===============================================================================
扩展                                                         *ctrlp-extensions*

扩展是可选的。把它的名字添加到变量g:ctrlp_extensions中来开启扩展: >
  let g:ctrlp_extensions = ['tag', 'buffertag', 'quickfix', 'dir', 'rtscript',
                          \ 'undo', 'line', 'changes', 'mixed', 'bookmarkdir']
<
扩展的名字在变量中出现的顺序会是在使用命令 <c-f>， <c-b> 切换时扩展在状态栏中出
现的顺序。

可用的扩展:~

                                                                    *:CtrlPTag*
  * 标记模式:~
    - 名称: 'tag'
    - 命令: ":CtrlPTag"
    - 在一个生成的标记文件中搜索标签，跳转到标签定义。使用Vim的 |'tags'| 来指定
      标签文件的位置和名称。
      例如: set tags+=doc/tags

                                                                 *:CtrlPBufTag*
                                                              *:CtrlPBufTagAll*
  * 缓冲区标签模式:~
    - 名称: 'buffertag'
    - 命令: ":CtrlPBufTag [缓冲区]"，
                ":CtrlPBufTagAll"。
    - 在当前缓冲区或者所有列出的缓冲区中搜索标签并且跳转到定义。需要
      |exuberant_ctags| 或者兼容的程序。

                                                               *:CtrlPQuickfix*
  * 快速修复模式:~
    - 名称: 'quickfix'
    - 命令: ":CtrlPQuickfix"
    - 在当前的快速修复错误列表中搜索条目并且跳转过去。

                                                                    *:CtrlPDir*
  * 目录模式:~
    - 名称: 'dir'
    - 命令: ":CtrlPDir [起始muu]"
    - 搜索目录并且将其作为工作目录。
    - 按键绑定:
      + <cr> 为CtrlP修改工作目录并且保持打开状态。
      + <c-t> 修改全局的工作目录（退出）。
      + <c-v> 为当前窗口修改工作目录（退出）。
      + <c-x> 修改全局工作目录为CtrlP的当前工作目录（退出）。

                                                                    *:CtrlPRTS*
  * 运行时脚本模式:~
    - 名称: 'rtscript'
    - 命令: ":CtrlPRTS"
    - 在运行时路径中寻找文件（vimscripts, docs, snippets...）。

                                                                   *:CtrlPUndo*
  * 撤销模式:~
    - 名称: 'undo'
    - 命令: ":CtrlPUndo"
    - 浏览撤销历史。

                                                                   *:CtrlPLine*
  * 行模式:~
    - 名称: 'line'
    - 命令: ":CtrlPLine [缓冲区]"
    - 在所有列出的缓冲区或者在指定的 [buffer] 缓冲区内搜索一行内容。

                                                                 *:CtrlPChange*
                                                              *:CtrlPChangeAll*
  * 修改列表模式:~
    - 名称: 'changes'
    - 命令: ":CtrlPChange [缓冲区]",
            ":CtrlPChangeAll".
    - 在当前缓冲区或者在所有列出的缓冲区内搜索最近的修改并跳转。

                                                                  *:CtrlPMixed*
  * 混合模式:~
    - 名称: 'mixed'
    - 命令: ":CtrlPMixed"
    - 同时在文件，缓冲区和最近最多修改中搜索。

                                                            *:CtrlPBookmarkDir*
                                                         *:CtrlPBookmarkDirAdd*
  * 书签目录模式:~
    - 名称: 'bookmarkdir'
    - 命令: ":CtrlPBookmarkDir",
            ":CtrlPBookmarkDirAdd [目录] [标题]".
            ":CtrlPBookmarkDirAdd! [目录] [标题]".
    - 搜索一个被书签标记的目录并将其作为工作目录。
    - 以指定的[标题]添加[目录]到 CtrlPBookmarkDir 中，如果没有给出[标题]或
      者[目录]，会请求用户输入。
    - 以指定的[标题]添加[目录]到 CtrlPBookmarkDir 中，如果没有给出目录，则
      默认为当前目录( [CWD] )，如果没有给出[标题] ，会请求用户输入。

      最新的用来添加所有最近使用过的目录到 CtrlPBookmarkDir 列表中的自动命令
      如下
      >
      augroup CtrlPDirMRU
        autocmd!
        autocmd FileType * if &modifiable | execute 'silent CtrlPBookmarkDirAdd! %:p:h' | endif
      augroup END
<

    - 按键绑定:
      + <cr> 为CtrlP修改工作目录并且保持打开状态，并且切换到文件搜索模式。
      + <c-x> 修改全局的工作目录（退出）。
      + <c-v> 为当前窗口修改工作目录（退出）。
      + <F7>
        - 清除书签列表。
        - 删除被 <c-z> 标记的书签条目。

                                                 *ctrlp-autoignore-extension*
  * 自动忽略模式:~
    - 名称: 'autoignore'

    - 这个扩展并不会添加新命令。它支持通过项目根目录中的 `.ctrlpignore` 文件为
      每个项目设置忽略模式 (就像属于单个项目的 |ctrlp_custom_ignore|)。基本
      上就像 CtrlP 的 `.gitignore` 或者 `.hgignore`。

      注意: 当使用 |g:ctrlp_user_command| 自动忽略模式不起作用。

      注意: `.ctrlpignore` 会被当做根目录的标识(参见 |g:ctrlp_root_markers|).

    - 忽略文件的语法:
      空行，以 `#` （注释）开头的行会被忽略。

      其他行会被当做正则表达式。 匹配模式如何被使用参见 *string-match* 。
      任意条目，只要匹配到任意匹配模式，就会从 CtrlP 中搜索结果中忽略。

      例子:

        \.tmp$
        ^generated/
        local\.cfg

      注意: 即使在 Windows 上模式也应该使用反斜线。

      你也可以像下面那样使用 glob 命令风格的语法：

        syntax:wildignore
        *.tar.gz
        *.tmp

      这样会在搜索文件时临时的把每一个匹配模式添加到 |'wildignore'|
      中，结束时移除。

      你也可以通过下面的方式切换回默认的正则表达式为基础的模式：

        syntax:regexp

      你也可以只为某一条目类型（文件、目录...）设置匹配模式：

        dir:build
        file:foo\.txt

      这样只会忽略包含 "build" 的目录和包含 "foo.txt" 的文件。不会忽略带
      有 "build" 的文件或者反过来。

      注意: 如果为了忽略名为 "build" 的目录，而不是『任何』包含 "build"
      的目录，你可以使用下面的正则： ^build$

    - 常见问题:
      问: 为什么 CtrlP 不能直接支持原生的 `.gitignore` or `.hgignore` ?

      答: 这些文件初看起来好像已经包含了所有你想从 CtrlP 中排除的文件。但是
      通常情况下，这些文件和你想在 CtrlP 中的配置会有一些不同。这些配置文件
      列出了不能被包含到版本控制中的文件。这些不能被包含到版本控制中的文件
      包括了你想忽略的，但是同时可能也包含了你不想忽略的：本地设置，外部包
      和依赖，等等。作者觉得支持多种语法与只是简单的复制/粘贴几行忽略规则比
      起来比较麻烦。如果你不这么觉得可以随时提交补丁 :)

      问: 我开启了 |ctrlp-autoignore-extension|， 或者编辑了 `.ctrlpignore`
      但是这些新模式并没有起作用。我哪里做错了？

      答: 可能什么都没做错！CtrlP 可以为了快速的响应缓存搜索结果。你可以按
      <F5> 强制刷新。如果 `.ctrlpignore` 改动过，这样也会使用新的匹配模式。

----------------------------------------
缓冲标签模式选项:~

                                                   *'g:ctrlp_buftag_ctags_bin'*
如果ctags没有在环境变量中配置，或者一个二进制ctags文件存在于
/opt/local/bin 或 /usr/local/bin，使用该选项来指定它的位置: >
  let g:ctrlp_buftag_ctags_bin = ''
<

                                                   *'g:ctrlp_buftag_systemenc'*
将该选项与你的操作系统的编码（非Vim的）保持一致。默认值使用Vim的全局
|'encoding'| 选项: >
  let g:ctrlp_buftag_systemenc = &encoding
<

                                                       *'g:ctrlp_buftag_types'*
使用该选项来在ctags, jsctags...中为指定的文件格式设置参数: >
  let g:ctrlp_buftag_types = ''
<
例子: >
  let g:ctrlp_buftag_types = {
    \ 'erlang'     : '--language-force=erlang --erlang-types=drmf',
    \ 'javascript' : {
      \ 'bin': 'jsctags',
      \ 'args': '-f -',
      \ },
    \ }
<

===============================================================================
自定义                                                    *ctrlp-customization*

高亮:~
  * CtrlP缓冲区的设置:
    CtrlPNoEntries : 当没有匹配被发现时的消息（错误）。
    CtrlPMatch     : 匹配模式（标识）。
    CtrlPLinePre   : 匹配窗口的行前缀'>'。
    CtrlPPrtBase   : 提示符窗口的基础（注释）。
    CtrlPPrtText   : 提示符窗口的文本 （|hl-Normal|）。
    CtrlPPrtCursor : 提示符窗口的光标在文本上移动时（常量）。

  * 缓冲区浏览模式:
    CtrlPBufferNr     : 缓冲区编号
    CtrlPBufferInd    : '+', '-', '=' 和 '#' 指示符 (参见 |:buffers|)
    CtrlPBufferHid    : 隐藏缓冲区
    CtrlPBufferHidMod : 隐藏和被编辑过的缓冲区
    CtrlPBufferVis    : 可见的缓冲区
    CtrlPBufferVisMod : 可见的和被编辑过的缓冲区
    CtrlPBufferCur    : 当前缓冲区
    CtrlPBufferCurMod : 当前和被编辑过的缓冲区
    CtrlPBufferPath   : 缓冲区路径

  * 在扩展中:
    CtrlPTabExtra  : 每一行中不匹配的部分（注释）。
    CtrlPBufName   : 条目所属的缓冲区名称（|hl-Directory|）。
    CtrlPTagKind   : 缓冲区标签模式中标签的类型（|hl-Title|）。
    CtrlPqfLineCol : 快速修复模式中行和列的序号（注释）。
    CtrlPUndoT     : 撤销模式的流逝时间（|hl-Directory|）。
    CtrlPUndoBr    : 撤销模式的方括号（注释）。
    CtrlPUndoNr    : 撤销模式的方括号中的数字（字符串）。
    CtrlPUndoSv    : 文件被保存的点（注释）。
    CtrlPUndoPo    : 撤销树中的当前位置（|hl-Title|）。
    CtrlPBookmark  : 书签的名称（标识）。

状态栏:~
  * 高亮组:
    CtrlPMode1 : 'file' 或 'path' 或 'line'，和当前模式（字符）。
    CtrlPMode2 : 'prt' 或 'win'， 'regex'，工作目录 |hl-LineNr| 。
    CtrlPStats : 扫描状态（函数）。

  重新构建状态栏，参见 |g:ctrlp_status_func| 。

===============================================================================
其它选项                                          *ctrlp-miscellaneous-configs*

* 为 |g:ctrlp_user_command| 使用 |wildignore| :
>
  function! s:wig2cmd()
    " 修改wildignore为空格或者|分隔的组
    " 例如: .aux .out .toc .jpg .bmp .gif
    " 或者  .aux$\|.out$\|.toc$\|.jpg$\|.bmp$\|.gif$
    let pats = ['[*\/]*\([?_.0-9A-Za-z]\+\)\([*\/]*\)\(\\\@<!,\|$\)','\\\@<!,']
    let subs = has('win32') || has('win64') ? ['\1\3', ' '] : ['\1\2\3', '\\|']
    let expr = substitute(&wig, pats[0], subs[0], 'g')
    let expr = substitute(expr, pats[1], subs[1], 'g')
    let expr = substitute(expr, '\\,', ',', 'g')

    " 设置用户命令选项
    let g:ctrlp_user_command = has('win32') || has('win64')
      \ ? 'dir %s /-n /b /s /a-d | findstr /V /l "'.expr.'"'
      \ : 'find %s -type f | grep -v "'.expr .'"'
  endfunction

  call s:wig2cmd()
<
（由 Rich Alesi <github.com/ralesi> 提交）

* 一个独立的函数，设置项目的根目录为工作目录，如果没有找到根目录的话使用当前文
* 件的父目录。
>
  function! s:setcwd()
    let cph = expand('%:p:h', 1)
    if cph =~ '^.\+://' | retu | en
    for mkr in ['.git/', '.hg/', '.svn/', '.bzr/', '_darcs/', '.vimprojects']
      let wd = call('find'.(mkr =~ '/$' ? 'dir' : 'file'), [mkr, cph.';'])
      if wd != '' | let &acd = 0 | brea | en
    endfo
    exe 'lc!' fnameescape(wd == '' ? cph : substitute(wd, mkr.'$', '.', ''))
  endfunction

  autocmd BufEnter * call s:setcwd()
<
(需要 Vim 7.1.299+)

* 使用 |count| 来使用同样的按键绑定调用不同的命令:
>
  let g:ctrlp_cmd = 'exe "CtrlP".get(["", "Buffer", "MRU"], v:count)'
<

===============================================================================
开发人员                                                        *ctrlp-credits*

最初由 Kien Nguyen <github.com/kien>开发。现在由 Github 上 ctrlpvim 组织的成员
维护(https://github.com/orgs/ctrlpvim/people) 。在Vim的 |license| 下发行。

项目主页:   http://ctrlpvim.github.com/ctrlp.vim
Git 仓库:   https://github.com/ctrlpvim/ctrlp.vim

-------------------------------------------------------------------------------
感谢所有通过github，bitbucket或电子邮件提供想法，报告bug或者帮助debugging的人。

特别感谢:~

    * Woojong Koh <github.com/wjkoh>
    * Simon Ruderich
    * Yasuhiro Matsumoto <github.com/mattn>
    * Ken Earley <github.com/kenearley>
    * Kyo Nagashima <github.com/hail2u>
    * Zak Johnson <github.com/zakj>
    * Diego Viola <github.com/diegoviola>
    * Piet Delport <github.com/pjdelport>
    * Thibault Duplessis <github.com/ornicar>
    * Kent Sibilev <github.com/datanoise>
    * Tacahiroy <github.com/tacahiroy>
    * Luca Pette <github.com/lucapette>
    * Seth Fowler <github.com/sfowler>
    * Lowe Thiderman <github.com/thiderman>
    * Christopher Fredén <github.com/icetan>
    * Zahary Karadjov <github.com/zah>
    * Jo De Boeck <github.com/grimpy>
    * Rudi Grinberg <github.com/rgrinberg>
    * Timothy Mellor <github.com/mellort>
    * Sergey Vlasov <github.com/noscript>

===============================================================================
更新日志                                                      *ctrlp-changelog*

    * 新选项 |g:ctrlp_custom_tag_files| 用来指定自定义的标签文件。
    * 设置 g:ctrlp_match_window 为0来不限制窗口大小

Before 2016/11/28~

    + 新命令: |YankLine()| 来复制整个文件。
    + 新选项: |g:ctrlp_types| 来选择內建类型。
    + 新特性: 异步在新线程中调用 |g:ctrlp_user_command| 。 设置
              |g:ctrlp_user_command_async|  为1来启用。
    + 为 delphi, rust 和 golang提供buffertag支持。
    + 新选项: |g:ctrlp_brief_prompt|,
              |g:match_current_file|,
              |g:ctrlp_compare_lim|.
    + 新功能: 自动忽略扩展。
    + 为 ant, tex, dosbatch, matlab 和 vhdl提供buffertag支持。
    + 新选项 |g:ctrlp_line_prefix| 来结合第三方插件。
    + 新选项 |g:open_single_match| 在 matches 中打开单个文件。
    + 添加启动方式 <plug>(ctrlp) 。
    + 接受 bang for CtrlPBookmarkDirAdd 来避免确认。
    + 处理像 "g:ctrlp_TYPE_MODE" 大小写混合的变量名。
                   例如: let g:ctrlp_path_sort
    + 新选项: |g:ctrlp_custom_ancestors|

在2014/08/08之前~

    + 新的支持高亮的缓冲区浏览模式 (建议 |+conceal|)
    + 新选项: |g:ctrlp_bufname_mod|,
              |g:ctrlp_bufpath_mod|
    + 结合 *g:ctrlp_match_window_bottom* *g:ctrlp_match_window_reversed* 和
      *g:ctrlp_max_height* 到 |g:ctrlp_match_window| 。
    + 新选项: |g:ctrlp_match_window| 。

在2012/11/30之前~

    + 新选项: |g:ctrlp_abbrev|，
              |g:ctrlp_key_loop|，
              |g:ctrlp_open_func|，
              |g:ctrlp_tabpage_position|，
              |g:ctrlp_mruf_save_on_update|
    + 重命名:
        *g:ctrlp_dotfiles* -> |g:ctrlp_show_hidden| 。
    + 修改 |g:ctrlp_switch_buffer| 和 |g:ctrlp_working_path_mode|的类型
      （旧值仍然工作）。
    + 当 |g:ctrlp_user_command| 是一个字典时，为其增加一个新的键: 'ignore'。

在2012/06/15之前~

    + |g:ctrlp_follow_symlinks| 的新值: 2。
    + |g:ctrlp_open_multiple_files| 的新值: 'j'。
    + 允许使用 <c-t>, <c-x>, <c-v> 打开被 <c-z> 标记的文件。
    + 扩展 '..' (|ctrlp-input-formats| (d))
    + 新的输入格式: '@cd' (|ctrlp-input-formats| (d))

在2012/04/30之前~

    + 新选项: |g:ctrlp_mruf_default_order|
    + 新特性: 被书签标记的目录的扩展。
    + 新命令: |:CtrlPBookmarkDir|
              |:CtrlPBookmarkDirAdd|

在2012/04/15之前~

    + 新选项: |g:ctrlp_buffer_func|，CtrlP缓冲区的回调函数。
    + 移除  : g:ctrlp_mruf_last_entered，使其作为最近最多使用的默认行为。
    + 新命令: |:CtrlPLastMode|，以上一次使用的模式打开CtrlP。
              |:CtrlPMixed|，在文件，缓冲区和最近最多使用中搜索。

在2012/03/31之前~

    + 新选项: |g:ctrlp_default_input|， 进入CtrlP后的默认输入。
              |g:ctrlp_match_func|，允许使用自定义的模糊查找工具。
    + 重命名:
        *ClearCtrlPCache* -> |CtrlPClearCache|
        *ClearAllCtrlPCaches* -> |CtrlPClearAllCaches|
        *ResetCtrlP* -> |CtrlPReload|

在2012/03/02之前~

    + 重命名:
        *g:ctrlp_regexp_search* -> |g:ctrlp_regexp|，
        *g:ctrlp_dont_split* -> |g:ctrlp_reuse_window|，
        *g:ctrlp_jump_to_buffer* -> |g:ctrlp_switch_buffer|。
    + 重命名和微调:
        *g:ctrlp_open_multi* -> |g:ctrlp_open_multiple_files|。
    + 过时 *g:ctrlp_highlight_match*
    + 扩展 |g:ctrlp_user_command| 支持多个命令。
    + 新选项: |g:ctrlp_mruf_last_entered| 修改最近最多使用为最近进入。

在2012/01/15之前~

    + 新按键绑定: 交换 <tab> 和 <s-tab>. <tab> 现在用来补全在当前工作目录内的目
                  录名。
    + 新选项: |g:ctrlp_arg_map| 使 <c-y>， <c-o> 可以接收一个参数。
              |g:ctrlp_status_func| 自定义状态栏。
              |g:ctrlp_mruf_relative| 在当前工作目录内显示最近最多使用。
    + 扩展 g:ctrlp_open_multi 增加新选项值： tr， hr， vr。
    + 扩展 |g:ctrlp_custom_ignore| 指定过滤目录，文件和链接。

在2012/01/05之前~

    + 新特性: 缓冲区标记扩展。
    + 新命令: |:CtrlPBufTag|, |:CtrlPBufTagAll|。
    + 新选项: |g:ctrlp_cmd|，
              |g:ctrlp_custom_ignore|

在2011/11/30之前~

    + 新特性: 标签，快速修复和目录扩展。
    + 新命令: |:CtrlPTag|, |:CtrlPQuickfix|, |:CtrlPDir|。
    + 新选项: |g:ctrlp_use_migemo|，
              |g:ctrlp_lazy_update|，
              |g:ctrlp_follow_symlinks|

在2011/11/13之前~

    + 新的特殊输入: '/' 和 '\' 查找根目录 (|ctrlp-input-formats| (e))
    + 移除 ctrlp#SetWorkingPath()。
    + 移除 *g:ctrlp_mru_files* ，使最近最多使用模式变为永久的。
    + 扩展 g:ctrlp_open_multi，添加打开文件的新方式。
    + 新选项: g:ctrlp_dont_split，
              |g:ctrlp_mruf_case_sensitive|

在2011/10/30之前~

    + 新特性: 支持自定义扩展。
              <F5> 也会从最近最多使用列表中移除不存在的文件。
    + 新选项: g:ctrlp_jump_to_buffer

在2011/10/12之前~

    + 新特性: 打开多个文件。
              传递Vim的 |++opt| 和 |+cmd| 到新打开的文件
              (|ctrlp-input-formats| (c))
              为 |:CtrlP| [起始目录]自动补全每个目录
    + 新按键绑定: <c-z> 标记/取消标记一个被 <c-o> 打开的文件。
                  <c-o> 打开所有被标记的文件。
    + 新选项: g:ctrlp_open_multi
    + 移除 *g:ctrlp_persistent_input* *g:ctrlp_live_update* and <c-^>。

在2011/09/29之前~

    + 新按键绑定: <c-n>, <c-p> 输入历史中的前一个/后一个字符串。
                  <c-y> 创建一个新的文件和它的父目录。
    + 新选项: |g:ctrlp_open_new_file|，
                   |g:ctrlp_max_history|
    + 添加一个新的在横向分割窗口打开的绑定：<c-x>

在2011/09/19之前~

    + 新命令: ResetCtrlP
    + 新选项: |g:ctrlp_max_files|，
              |g:ctrlp_max_depth|，
              g:ctrlp_live_update
    + 新按键绑定: <c-^>

在2011/09/12之前~

    + 添加在匹配窗口内循环匹配行的功能。
    + 扩展 g:ctrlp_persistent_input的行为
    + 扩展 |:CtrlP| 的行为
    + 新选项: |g:ctrlp_dotfiles|，
              |g:ctrlp_clear_cache_on_exit|，
              g:ctrlp_highlight_match，
              |g:ctrlp_user_command|
    + 新的特殊输入: '..' (|ctrlp-input-formats| (d))
    + 新按键绑定: <F5>。
    + 新命令: |:CtrlPCurWD|，
              |:CtrlPCurFile|，
              |:CtrlPRoot|

    + 新特性: 在最近最常使用的文件列表中搜索
    + 新按键绑定: <c-b>。
    + 扩展 <c-f> 的行为。
    + 新选项: g:ctrlp_mru_files，
              |g:ctrlp_mruf_max|，
              |g:ctrlp_mruf_exclude|，
              |g:ctrlp_mruf_include|
    + 新命令: |:CtrlPMRU|

第一版发布于: 2011/09/06~

===============================================================================
vim:ft=help:et:ts=2:sw=2:sts=2:norl
