priority -50

global !p

def ada_case(word):
	out = word[0].upper()
	for i in range(1, len(word)):
		if word[i] == '-':
			out = out + '.'
		elif word[i - 1] == '_' or word[i - 1] == '-':
			out = out + word[i].upper()
		else:
			out = out + word[i]
	return out

endglobal

snippet wi "with"
with $1;$0
endsnippet

snippet pac "package"
package ${1:`!p snip.rv = ada_case(snip.basename)`} is
	$0
end $1;
endsnippet

snippet pacb "package body"
package body ${1:`!p snip.rv = ada_case(snip.basename)`} is
	$0
end $1;
endsnippet

snippet ent "entry ... when"
entry $1($2) when $3 is
begin
	$0
end $1;
endsnippet

snippet task "task"
task $1 is
	entry $0
end $1;
endsnippet

snippet taskb "task body"
task body $1 is
	$2
begin
	$0
end $1;
endsnippet

snippet acc "accept"
accept $1($2) do
	$0
end $1;
endsnippet

snippet prot "protected type"
protected type $1($2) is
	$0
end $1;
endsnippet

snippet prob "protected body"
protected body $1 is
	$2
begin
	$0
end $1;
endsnippet

snippet gen "generic type"
generic
	type $1 is $2;$0
endsnippet

snippet ty "type"
type $1 is $2;$0
endsnippet

snippet tyd "type with default value"
type $1 is $2
	with Default_Value => $3;$0
endsnippet

snippet subty "subtype"
subtype $1 is $2;$0
endsnippet

snippet dec "declare block"
declare
	$1
begin
	$0
end;
endsnippet

snippet decn "declare named block"
$1:
declare
	$2
begin
	$0
end $1;
endsnippet

snippet ifex "if expression"
if $1 then $2 else $0
endsnippet

snippet casex "case expression"
case $1 is
	when $2 => $3,$0
endsnippet

snippet fora "for all"
for all $1 ${2:in} $3 => $0
endsnippet

snippet fors "for some"
for some $1 ${2:in} $3 => $0
endsnippet

snippet if "if"
if $1 then
	$0
end if;
endsnippet

snippet ife "if ... else"
if $1 then
	$2
else
	$0
end if;
endsnippet

snippet el "else"
else
	$0
endsnippet

snippet eif "elsif"
elsif $1 then
	$0
endsnippet

snippet wh "while"
while $1 loop
	$0
end loop;
endsnippet

snippet nwh "named while"
$1:
while $2 loop
	$0
end loop $1;
endsnippet

snippet for "for"
for ${1:I} in $2 loop
	$0
end loop;
endsnippet

snippet fore "for each"
for $1 of $2 loop
	$0
end loop;
endsnippet

snippet nfor "named for"
$1:
for ${2:I} in $3 loop
	$0
end loop $1;
endsnippet

snippet nfore "named for each"
$1:
for $2 of $3 loop
	$0
end loop $1;
endsnippet

snippet proc "procedure"
procedure $1($2) is
	$3
begin
	$0
end $1;
endsnippet

snippet procd "procedure declaration"
procedure $1;$0
endsnippet

snippet fun "function"
function $1($2) return $3 is
	$4
begin
	$0
end $1;
endsnippet

snippet fune "expression function"
function $1 return $2 is
	($3);$0
endsnippet

snippet fund "function declaration"
function $1 return $2;$0
endsnippet

snippet ret "extended return"
return $1 do
	$0
end return;
endsnippet

snippet rec "record"
record
	$0
end record;
endsnippet

snippet case "case"
case $1 is
	when $2 => $3;$0
end case;
endsnippet

snippet whe "when"
when $1 => $2;$0
endsnippet

snippet wheo "when others"
when others => $1;$0
endsnippet

snippet lo "loop"
loop
	$0
end loop;
endsnippet

snippet nlo "named loop"
$1:
loop
	$0
end loop $1;
endsnippet

snippet ex "exit when"
exit when $1;$0
endsnippet

snippet put "Ada.Text_IO.Put"
Ada.Text_IO.Put($1);$0
endsnippet

snippet putl "Ada.Text_IO.Put_Line"
Ada.Text_IO.Put_Line($1);$0
endsnippet

snippet get "Ada.Text_IO.Get"
Ada.Text_IO.Get($1);$0
endsnippet

snippet getl "Ada.Text_IO.Get_Line"
Ada.Text_IO.Get_Line($1);$0
endsnippet

snippet newline "Ada.Text_IO.New_Line"
Ada.Text_IO.New_Line(${1:1});$0
endsnippet

# vim:ft=snippets:
