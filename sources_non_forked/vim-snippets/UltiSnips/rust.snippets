#######################################################################
#                            Rust Snippets                            #
#######################################################################

###############
#  Functions  #
###############
snippet fn "A function, optionally with arguments and return type."
fn ${1:function_name}(${2})${3/..*/ -> /}${3} {
	${VISUAL}${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
}
endsnippet

snippet test "Test function"
#[test]
fn ${1:test_function_name}() {
	${VISUAL}${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
}
endsnippet

snippet new "A new function"
pub fn new(${2}) -> ${1:Name} {
	${VISUAL}${0}return $1 { ${3} };
}
endsnippet

snippet main "The main function"
pub fn main() {
	${VISUAL}${0}
}
endsnippet



snippet let "A let statement"
let ${1:name}${3} = ${VISUAL}${2};
endsnippet

snippet pln "println!(..)" b
println!("${1}"${2/..*/, /}${2});
endsnippet



snippet ec "extern crate ..." b
extern crate ${1:sync};
endsnippet

snippet ecl "...extern crate log;" b
#![feature(phase)]
#[phase(syntax, link)] extern crate log;
endsnippet

snippet mod	 "A mod." b
mod ${1:`!p snip.rv = snip.basename.lower() or "name"`} {
	${VISUAL}${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
} /* $1 */
endsnippet

snippet crate "Create header information" b
// Crate ID
#![crate_id = "${1:crate_name}#${2:0.0.1}"]

// Additional metadata attributes
#![desc = "${3:Descrption.}"]
#![license = "${4:BSD}"]
#![comment = "${5:Comment.}"]

// Specify the output type
#![crate_type = "${6:lib}"]
endsnippet

snippet allow "#[allow(..)]" b
#[allow(${1:unused_variable})]
endsnippet

snippet feat "#![feature(..)]" b
#![feature(${1:macro_rules})]
endsnippet


##################
#  Common types  #
##################
snippet opt "Option<..>"
Option<${1:int}>
endsnippet

snippet res "Result<.., ..>"
Result<${1:~str}, ${2:()}>
endsnippet




snippet if "if .. (if)" b
if ${1:/* condition */} {
	${VISUAL}${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
}
endsnippet

snippet mat "match"
match ${1} {
	${2} => ${3},
}
endsnippet

snippet while "while .. {}" b
while ${1:condition} {
	${VISUAL}${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
}
endsnippet

snippet for "for .. in .." b
for ${1:i} in ${2:range(0u, 10)} {
	${VISUAL}${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
}
endsnippet

snippet spawn "spawn(proc() { .. });" b
spawn(proc() {
	${VISUAL}${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
});
endsnippet

snippet chan "A channel" b
let (${1:tx}, ${2:rx}): (Sender<${3:int}>, Receiver<${4:int}>) = channel();
endsnippet

snippet duplex "Duplex stream" b
let (${1:from_child}, ${2:to_child}) = sync::duplex();
endsnippet

#####################
#  TODO commenting  #
#####################
snippet todo "A Todo comment"
// [TODO]: ${1:Description} - `!v strftime("%Y-%m-%d %I:%M%P")`
endsnippet


############
#  Struct  #
############
snippet st "Struct" b
struct ${1:`!p snip.rv = snip.basename.title() or "name"`} {
	${VISUAL}${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
}
endsnippet

snippet stn "Struct with new constructor." b
pub struct ${1:`!p snip.rv = snip.basename.title() or "name"`} {
	${3:/* code */}
}

impl $1 {
	pub fn new(${2}) -> $1 {
		${4}return $1 {
			${5}
		};
	}
}
endsnippet


##########
#  Enum  #
##########
snippet enum "An enum" b
enum ${1:enum_name} {
	${VISUAL}${0},
}
endsnippet


##########
#  Impl  #
##########
snippet imp "An impl" b
impl ${1:Name} {
	${VISUAL}${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
}
endsnippet

snippet drop "Drop implementation" b
impl Drop for ${1:Name} {
	fn drop(&mut self) {
		${VISUAL}${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
	}
}
endsnippet


############
#  Traits  #
############
snippet trait "Trait block" b
trait ${1:Name} {
	${VISUAL}${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
}
endsnippet


#############
#  Statics  #
#############
snippet ss "A static string."
static ${1}: &'static str = "${VISUAL}${0}";
endsnippet

snippet stat "A static variable."
static ${1}: ${2:uint} = ${VISUAL}${0};
endsnippet

# vim:ft=snippets:
