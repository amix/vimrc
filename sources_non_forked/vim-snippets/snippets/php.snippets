snippet <?
	<?php

	${0:${VISUAL}}
snippet dst "declare(strict_types=1)"
	declare(strict_types=${1:1});
snippet ec
	echo ${0};
snippet <?e
	<?php echo ${0} ?>
# this one is for php5.4
snippet <?=
	<?=${0}?>
snippet ?=
	<?= ${0} ?>
snippet ?
	<?php ${0} ?>
snippet ?f
	<?php foreach ($${1:vars} as $${2:$var}): ?>
		${0:${VISUAL}}
	<?php endforeach ?>
snippet ?i
	<?php if ($${1:var}): ?>
		${0:${VISUAL}}
	<?php endif ?>
snippet ns
	namespace ${1:Foo\Bar\Baz};
	
	${0:${VISUAL}}
snippet c
	class ${1:`vim_snippets#Filename()`}
	{
		${0:${VISUAL}}
	}
snippet i
	interface ${1:`vim_snippets#Filename()`}
	{
		${0:${VISUAL}}
	}
snippet t.
	\$this->
snippet f
	function ${1}(${3})
	{
		${0:${VISUAL}}
	}
# method
snippet m
	${1:protected} function ${2:foo}()
	{
		${0:${VISUAL}}
	}
snippet sm "PHP Class Setter"
	/**
	 * Sets the value of ${1:foo}
	 *
	 * @param ${2:string} $$1 ${3:description}
	 *
	 * @return ${4:`vim_snippets#Filename()`}
	 */
	${5:public} function set${6:$1}(${7:$2 }$$1)
	{
		$this->${8:$1} = $$1;

		return $this;
	}
snippet gm "PHP Class Getter Setter"
	/**
	 * Gets the value of ${1:foo}
	 *
	 * @return ${2:string}
	 */
	${3:public} function get${4:$1}()
	{
		return $this->${5:$1};
	}
#setter
snippet $s
	${1:$foo}->set${2:Bar}(${0});
#getter
snippet $g
	${1:$foo}->get${0:Bar}();
# Tertiary conditional
snippet =?:
	$${1:foo} = ${2:true} ? ${3:a} : ${0};
snippet ?:
	${1:true} ? ${2:a} : ${0}
snippet t "$retVal = (condition) ? a : b"
	$${1:retVal} = ($2) ? ${3:a} : ${4:b};
# Predefined variables
snippet C
	$_COOKIE['${1:variable}']
snippet E
	$_ENV['${1:variable}']
snippet F
	$_FILES['${1:variable}']
snippet G "_GET array"
	$_GET['${1:variable}']
snippet P "_POST array"
	$_POST['${1:variable}']
snippet R
	$_REQUEST['${1:variable}']
snippet S
	$_SERVER['${1:variable}']
snippet SS
	$_SESSION['${1:variable}']
snippet get "get"
	$_GET['${1}']
snippet post "post"
	$_POST['${1}']
snippet session "session"
	$_SESSION['${1}']
# the following are old ones
snippet inc
	include '${1:file}';
snippet inc1
	include_once '${1:file}';
snippet req
	require '${1:file}';
snippet req1
	require_once '${1:file}';
# Start Docblock
snippet /*
	/**
	 * ${0}
	 */
# Class - post doc
snippet doc_cp
	/**
	 * ${1:undocumented class}
	 *
	 * @package ${2:default}
	 * @subpackage ${3:default}
	 * @author ${4:`g:snips_author`}
	 */
# Class Variable - post doc
snippet doc_vp
	/**
	 * ${1:undocumented class variable}
	 *
	 * @var ${2:string}
	 */
# Class Variable
snippet doc_v
	/**
	 * ${3:undocumented class variable}
	 *
	 * @var ${4:string}
	 */
	${1:var} $${2};

# Class attribute with short comment
snippet att
	/** @var ${3:string} */
	${1:public} $${2};

# Class
snippet doc_c
	/**
	 * ${3:undocumented class}
	 *
	 * @package ${4:default}
	 * @subpackage ${5:default}
	 * @author ${6:`g:snips_author`}
	 */
	${1:}class ${2:}
	{
		${0:${VISUAL}}
	} // END $1class $2
# Constant Definition - post doc
snippet doc_dp
	/**
	 * ${1:undocumented constant}
	 */
# Constant Definition
snippet doc_d
	/**
	 * ${3:undocumented constant}
	 */
	define(${1}, ${2});
# Function - post doc
snippet doc_fp
	/**
	 * ${1:undocumented function}
	 *
	 * @return ${2:void}
	 * @author ${3:`g:snips_author`}
	 */
# Function signature
snippet doc_s
	/**
	 * ${4:undocumented function}
	 *
	 * @return ${5:void}
	 * @author ${6:`g:snips_author`}
	 */
	${1}function ${2}(${3});
# Function
snippet doc_f
	/**
	 * ${4:undocumented function}
	 *
	 * @return ${5:void}
	 * @author ${6:`g:snips_author`}
	 */
	${1}function ${2}(${3})
	{${0}
	}
# Header
snippet doc_h
	/**
	 * ${1}
	 *
	 * @author ${2:`g:snips_author`}
	 * @version ${3:$Id$}
	 * @copyright ${4:$2}, `strftime('%d %B, %Y')`
	 * @package ${0:default}
	 */
snippet doc_i "interface someClass {}"
	/**
	 * $1
	 * @package ${2:default}
	 * @author ${3:`!v g:snips_author`}
	 **/
	interface ${1:someClass}
	{${4}
	}
snippet inheritdoc "@inheritdoc docblock"
	/**
	 * {@inheritdoc}
	 */
# Interface
snippet interface
	/**
	 * ${2:undocumented class}
	 *
	 * @package ${3:default}
	 * @author ${4:`g:snips_author`}
	 */
	interface ${1:`vim_snippets#Filename()`}
	{
		${0:${VISUAL}}
	}
# Trait
snippet trait
	/**
	 * ${2:undocumented class}
	 *
	 * @package ${3:default}
	 * @author ${4:`g:snips_author`}
	 */
	trait ${1:`vim_snippets#Filename()`}
	{
		${0:${VISUAL}}
	}
# class ...
snippet class
	/**
	 * ${1}
	 */
	class ${2:`vim_snippets#Filename()`}
	{
		${3}
		/**
		 * ${4}
		 */
		${5:public} function ${6:__construct}(${7:argument})
		{
			${0}
		}
	}
snippet nc
	namespace ${1:`substitute(substitute(expand("%:h"), '\v^\w+\/(\u)', '\1', ''), '\/', '\\\', 'g')`};

	${2:abstract }class ${3:`vim_snippets#Filename()`}
	{
		${0:${VISUAL}}
	}
# define(...)
snippet def "define('VARIABLE_NAME', 'definition')"
	define('${1:VARIABLE_NAME}', ${2:'definition'});
# defined(...)
snippet def?
	${1}defined('${2}')
snippet wh "while (condition) { ... }"
	while ($1) {
		${0:${VISUAL}}
	}
snippet do "do { ... } while (condition)"
	do {
		${0:${VISUAL}}
	} while (${1});
snippet if "if (condition) { ... }"
	if (${1}) {
		${0:${VISUAL}}
	}
snippet ifn "if (!condition) { ... }"
	if (!${1}) {
		${0:${VISUAL}}
	}
snippet ifil "<?php if (condition): ?> ... <?php endif; ?>"
	<?php if (${1}): ?>
		${0:${VISUAL}}
	<?php endif; ?>
snippet ife "if (cond) { ... } else { ... }"
	if (${1}) {
		${0:${VISUAL}}
	} else {
		${2}
	}
snippet ifeil "<?php if (condition): ?> ... <?php else: ?> ... <?php endif; ?>"
	<?php if (${1}): ?>
		${0:${VISUAL}}
	<?php else: ?>
		${2}
	<?php endif; ?>
snippet el "else { ... }"
	else {
		${0:${VISUAL}}
	}
snippet eif "elseif(condition) { ... }"
	elseif (${1}) {
		${0:${VISUAL}}
	}
snippet switch "switch($var) { case 'xyz': ... default: .... }"
	switch ($${1:variable}) {
		case '${2:value}':
			${3}
			break;
		${0}
		default:
			${4}
			break;
	}
snippet case "case 'value': ... break"
	case '${1:value}':
		${0:${VISUAL}}
		break;
snippet for "for ($i = 0; $i < $count; $i++) { ... }"
	for ($${2:i} = 0; $$2 < ${1:count}; $$2${3:++}) {
		${0:${VISUAL}}
	}
snippet foreach "foreach ($var as $value) { .. }"
	foreach ($${1:variable} as $${2:value}) {
		${0:${VISUAL}}
	}
snippet foreachil "<?php foreach ($var as $value): ?>  ... <?php endforeach; ?>"
	<?php foreach ($${1:variable} as $${2:value}): ?>
		${0:${VISUAL}}
	<?php endforeach; ?>
snippet foreachk "foreach ($var as $key => $value) { .. }"
	foreach ($${1:variable} as $${2:key} => $${3:value}) {
		${0:${VISUAL}}
	}
snippet foreachkil "<?php foreach ($var as $key => $value): ?>  ... <?php endforeach; ?>"
	<?php foreach ($${1:variable} as $${2:key} => $${3:value}): ?>
		${0:<!-- html... -->}
	<?php endforeach; ?>
snippet array "$... = ['' => ]"
	$${1:arrayName} = ['${2}' => ${3}];
snippet try "try { ... } catch (Exception $e) { ... }"
	try {
		${0:${VISUAL}}
	} catch (${1:Exception} $e) {
	}
# lambda with closure
snippet lambda
	${1:static }function (${2:args}) use (${3:&$x, $y /*put vars in scope (closure) */}) {
		${0}
	};
# pre_dump();
snippet pd
	echo '<pre>'; var_dump(${0}); echo '</pre>';
# pre_dump(); die();
snippet pdd
	echo '<pre>'; var_dump(${1}); echo '</pre>'; die(${0:});
snippet vd
	var_dump(${0});
snippet vdd
	var_dump(${1}); die(${0:});
snippet pr
	print_r(${0});
snippet prs
	print_r(${0}, 1);
snippet vdf
	error_log(print_r($${1:foo}, true), 3, '${2:/tmp/debug.log}');
snippet http_redirect
	header ("HTTP/1.1 301 Moved Permanently");
	header ("Location: ".URL);
	exit();
snippet log "error_log(var_export($var, true));"
	error_log(var_export(${1}, true));
snippet var "var_export($var)"
	var_export(${1});
snippet ve "Dumb debug helper in HTML"
	echo '<pre>' . var_export(${1}, 1) . '</pre>';
snippet pc "Dumb debug helper in cli"
	var_export($1);$0
# Getters & Setters
snippet gs "PHP Class Getter Setter"
	/**
	 * Gets the value of ${1:foo}
	 *
	 * @return ${2:string}
	 */
	public function get${3:$1}()
	{
		return $this->${4:$1};
	}

	/**
	 * Sets the value of $1
	 *
	 * @param $2 $$1 ${5:description}
	 *
	 * @return ${6:`vim_snippets#Filename()`}
	 */
	public function set$3(${7:$2 }$$1)
	{
		$this->$4 = $$1;
		return $this;
	}
# anotation, get, and set, useful for doctrine
snippet ags
	/**
	 * ${1:description}
	 *
	 * @${0}
	 */
	${2:protected} $${3:foo};

	public function get${4:$3}()
	{
		return $this->$3;
	}

	public function set$4(${5:$4 }$${6:$3})
	{
		$this->$3 = $$6;
		return $this;
	}
snippet rett
	return true;
snippet retf
	return false;
snippet am
	$${1:foo} = array_map(function($${2:v}) {
		${0}
		return $$2;
	}, $$1);
snippet aw
	array_walk($${1:foo}, function(&$${2:v}, $${3:k}) {
		$$2 = ${0};
	});
# static var assign once
snippet static_var
	static $${1} = null;
	if (is_null($$1)){
		$$1 = ${2};
	}
snippet CSVWriter
	<?php
	
	class CSVWriter {
		public function __construct($file_or_handle, $sep = "\t", $quot = '"'){
			$args = func_get_args();
			$mode = isset($opts['mode']) ? $opts['mode'] : 'w';
	
			$this->f =
				is_string($file_or_handle)
				? fopen($file_or_handle, $mode)
				: $file_or_handle;
	
			$this->fputcsv_args = [$this->f, null, $sep, $quot];
	
			if (!$this->f) throw new Exception('bad file descriptor');
		}
	
		public function write($row){
			$this->fputcsv_args[1] =& $row;
			call_user_func_array('fputcsv', $this->fputcsv_args);
		}
	
		public function close(){
			if (!is_null($this->f))
				fclose($this->f);
			$this->f = null;
		}
	
		public function __destruct(){
			$this->close();
		}
	
	}
snippet CSVIterator
	
	// http://snipplr.com/view.php?codeview&id=1986 // modified
	class CSVIterator implements Iterator
	{	
		private $f;
		private $curr;
		private $rowCounter;
	
		 /* opts keys:
			* row_size
			* escape
			* enclosure
			* delimiter
			*/
		public function __construct( $file_or_handle, $opts = [4096, ','] )
		{
			$d = function($n) use(&$opts){ return isset($opts[$n]) ? $opts[$n] : false; };
	
			$this->combine = $d('combine');
			$this->headers = $d('headers');
			$this->headerCheckFunction = $d('header_check_function');
	
			$this->f =
				is_string($file_or_handle)
				? fopen( $file_or_handle, 'r' )
				: $file_or_handle;
			if (!$this->f) throw new Exception('bad file descriptor');
			$this->fgetcsv_args = [
					$this->f,
					isset($opts['row_size']) ? $opts['row_size'] : 4096,
					isset($opts['delimiter']) ? $opts['delimiter'] : ',',
					isset($opts['enclosure']) ? $opts['enclosure'] : '"',
					isset($opts['escape']) ? $opts['escape'] : '\\',
			];
			$this->start();
		}
	
		protected function readRow(){
			$this->curr = call_user_func_array('fgetcsv', $this->fgetcsv_args );
			$this->rowCounter++;
			if ($this->rowCounter == 1){
				$this->processHeader();
			} elseif ($this->curr) {
				$this->processRow();
			}
		}
	
		public function processHeader(){
			if ($this->headers || $this->combine){
				$this->header = $this->curr;
				if ($this->headerCheckFunction){
					$f = $this->headerCheckFunction;
					$f($this->header);
				}
				$this->readRow();
			}
		}
	
		public function processRow(){
			if ($this->combine)
				$this->curr = array_combine($this->header, $this->curr);
		}
	
		public function start(){
			$this->rowCounter = 0;
			rewind( $this->f );
			$this->readRow();
		}
	
		public function rewind()
		{
			$this->start();
		}
	
		public function current()
		{
			$curr = $this->curr;
			$this->readRow();
			return $curr;
		}
	
		public function key()
		{
			return $this->rowCounter;
		}
	
		public function next()
		{
			return $this->curr;
		}
	
		public function valid(){
			if( !$this->next() )
			{
				fclose( $this->f );
				return FALSE;
			}
			return TRUE;
		}
	
	} // end class
# phpunit
snippet ase "$this->assertEquals($a, $b)"
	$this->assertEquals(${1:$expected}, ${2:$actual});
snippet asne "$this->assertNotEquals($a, $b)"
	$this->assertNotEquals(${1:$expected}, ${2:$actual});
snippet asf "$this->assertFalse($a)"
	$this->assertFalse(${1});
snippet ast "$this->assertTrue($a)"
	$this->assertTrue(${1});
snippet asfex "$this->assertFileExists('path/to/file')"
	$this->assertFileExists(${1:'path/to/file'});
snippet asfnex "$this->assertFileNotExists('path/to/file')"
	$this->assertFileNotExists(${1:'path/to/file'});
snippet ascon "$this->assertContains($needle, $haystack)"
	$this->assertContains(${1:$needle}, ${2:$haystack});
snippet asncon "$this->assertNotContains($needle, $haystack)"
	$this->assertNotContains(${1:$needle}, ${2:$haystack});
snippet ascono "$this->assertContainsOnly($needle, $haystack)"
	$this->assertContainsOnly(${1:$needle}, ${2:$haystack});
snippet asconoi "$this->assertContainsOnlyInstancesOf(Example::class, $haystack)"
	$this->assertContainsOnlyInstancesOf(${1:Example}::class, ${2:$haystack});
snippet ashk "$this->assertArrayHasKey($key, $array)"
	$this->assertArrayHasKey(${1:$key}, ${2:$array});
snippet asnhk "$this->assertArrayNotHasKey($key, $array)"
	this->assertArrayNotHasKey(${1:$key}, ${2:$array});
snippet ascha "$this->assertClassHasAttribute($name, Example::class)"
	$this->assertClassHasAttribute(${1:$attributeName}, ${2:Example}::class);
snippet asi "$this->assertInstanceOf(Example::class, $actual)"
	$this->assertInstanceOf(${1:Example}::class, ${2:$actual});
snippet asit "$this->assertInternalType('string', $actual)"
	$this->assertInternalType(${1:'string'}, ${2:actual});
snippet asco "$this->assertCount($count, $haystack)"
	$this->assertCount(${1:$expectedCount}, ${2:$haystack});
snippet asnco "$this->assertNotCount($count, $haystack)"
	$this->assertNotCount(${1:$count}, ${2:$haystack});
snippet assub "$this->assertArraySubset($subset, $array)"
	$this->assertArraySubset(${1:$subset}, ${2:$array});
snippet asnu "$this->assertNull($a)"
	$this->assertNull(${1});
snippet asnnu "$this->assertNotNull($a)"
	$this->assertNotNull(${1});
snippet test "public function testXYZ() { ... }"
	public function test${1}()
	{
		${0:${VISUAL}}
	}
snippet setup "protected function setUp() { ... }"
	protected function setUp()
	{
		${0:${VISUAL}}
	}
snippet teardown "protected function tearDown() { ... }"
	protected function tearDown()
	{
		${0:${VISUAL}}
	}
snippet proph "$observer = $this->prophesize(SomeClass::class);"
	$${1:observer} = $this->prophesize(${2:SomeClass}::class);
snippet mock "$mock = $this->createMock(SomeClass::class);"
	$${1:mock} = $this->createMock(${2:SomeClass}::class);
snippet exp "phpunit expects"
	expects($this->${1:once}())
		->method('${2}')
		->with(${3})
		->willReturn(${4});
snippet testcmt "phpunit comment with group"
	/**
	* @group ${1}
	*/
snippet fail "$this->fail()"
	$this->fail(${1});
snippet marki "$this->markTestIncomplete()"
	$this->markTestIncomplete(${1});
snippet marks "$this->markTestSkipped()"
	$this->markTestSkipped(${1});
# end of phpunit snippets
snippet te "throw new Exception()"
	throw new ${1:Exception}("${2:Error Processing Request}");
snippet fpc "file_put_contents" b
	file_put_contents(${1:file}, ${2:content}${3:, FILE_APPEND});$0
snippet sr "str_replace"
	str_replace(${1:search}, ${2:replace}, ${3:subject})$0
snippet ia "in_array"
	in_array(${1:needle}, ${2:haystack})$0
snippet is "isset"
	isset(${1:var})$0
snippet isa "isset array"
	isset($${1:array}[${2:key}])$0
snippet in "is_null"
	is_null($${1:var})$0
snippet fe "file_exists"
	file_exists(${1:file})$0
snippet id "is_dir"
	is_dir(${1:path})$0
