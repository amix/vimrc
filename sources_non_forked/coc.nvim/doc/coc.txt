*coc-nvim.txt*					NodeJS client for Vim & Neovim.

Version: 0.0.82
Author: Qiming Zhao <chemzqm at gmail.com>
License: Anti 996 license

CONTENTS					*coc-contents*

Introduction					|coc-introduction|
Requirements					|coc-requirements|
Installation					|coc-installation|
Extensions 					|coc-extensions|
Configuration					|coc-configuration|
Floating windows 				|coc-floating|
LSP features 					|coc-lsp|
  Document 					|coc-document|
  Hover 					|coc-hover|
  Completion					|coc-completion|
  Diagnostics 					|coc-diagnostics|
  Pull diagnostics 				|coc-pullDiagnostics|
  Locations 					|coc-locations|
  Rename 					|coc-rename|
  Signature help 				|coc-signature|
  Inlay hint 					|coc-inlayHint|
  Format 					|coc-format|
  Code action 					|coc-code-actions|
  Document highlights 				|coc-document-highlights|
  Document colors 				|coc-document-colors|
  Document links 				|coc-document-links|
  Snippets 					|coc-snippets|
  Workspace					|coc-workspace|
  Cursors 					|coc-cursors|
  Outline 					|coc-outline|
  Call hierarchy 				|coc-callHierarchy|
  Semantic highlights 				|coc-semantic-highlights|
  Fold 						|coc-fold|
  Selection range 				|coc-selection-range|
  Code Lens 					|coc-code-lens|
  Linked editing 				|coc-linked-editing|
Interface					|coc-interface|
  Key mappings					|coc-key-mappings|
  Variables					|coc-variables|
    Buffer variables 				|coc-buffer-variables|
    Global variables 				|coc-global-variables|
  Functions					|coc-functions|
  Commands					|coc-commands|
  Autocmds					|coc-autocmds|
  Highlights					|coc-highlights|
Tree 						|coc-tree|
  Tree mappings 				|coc-tree-mappings|
  Tree filter 					|coc-tree-filter|
List						|coc-list|
  List command					|coc-list-command|
  List command options 				|coc-list-options|
  List configuration				|coc-list-configuration|
  List mappings					|coc-list-mappings|
  list sources					|coc-list-sources|
Dialog 						|coc-dialog|
  Dialog basic 					|coc-dialog-basic|
  Dialog confirm  				|coc-dialog-confirm|
  Dialog input 					|coc-dialog-input|
  Dialog menu 					|coc-dialog-menu|
  Dialog picker                                 |coc-dialog-picker|
Notification					|coc-notification|
Statusline integration				|coc-status|
  Manual					|coc-status-manual|
  Airline					|coc-status-airline|
  Lightline					|coc-status-lightline|
FAQ						|coc-faq|
Changelog					|coc-changelog|

==============================================================================
INTRODUCTION						*coc-introduction*

Coc.nvim enhances your (Neo)Vim to match the user experience provided by
VSCode through a rich extension ecosystem and implemented features specified
by Language Server Protocol (3.16 for now).

Some features (like completion) automatically works by default, all of them
can be disabled by |coc-configuration|.

Some of its key features include:~

- APIs compatible with both Vim8 and Neovim.
- Loading VSCode-like extensions.
- Configuring coc.nvim and its extensions with JSON configuration
  |coc-configuration|.
- Configuring Language Servers that using Language Server Protocol (LSP)
  |coc-config-languageserver|.

It is designed for best possible integration with other Vim plugins.

Note: coc.nvim doesn't come with support for any specific language. You
will need to install coc.nvim extensions |coc-extensions| or set up the
language server by configuration |coc-config-languageserver|.

Note: multiple language servers for same document is allowed, but you should
avoid configure same language server that already used by coc.nvim extension.

Note: Automatic completion plugins can't play nicely together, you can disable
automatic completion of coc.nvim through `"suggest.autoTrigger": "none"` (or
`"suggest.autoTrigger": "trigger"`) in your configuration file.

==============================================================================
REQUIREMENTS						*coc-requirements*

Neovim >= 0.4.0 or Vim >= 8.1.1719.

NodeJS https://nodejs.org/ >= 14.14.0.

Yarn https://yarnpkg.com/ required to build coc.nvim from typescript source
code.

==============================================================================
INSTALLATION						*coc-installation*

If you're using [vim-plug](https://github.com/junegunn/vim-plug), add this to
your `init.vim` or `.vimrc`: >

  Plug 'neoclide/coc.nvim', {'branch': 'release'}
<
And run: >

  :PlugInstall

For other plugin managers, make sure to use code from the release branch
(unless you want to change typescript source code).

To use Vim's native |packages| on Linux or MaxOS, use script like: >

  #!/bin/sh
  # for vim8
  mkdir -p ~/.vim/pack/coc/start
  cd ~/.vim/pack/coc/start
  curl --fail -L https://github.com/neoclide/coc.nvim/archive/release.tar.gz|tar xzfv -
  vim -c 'helptags ~/.vim/pack/coc/start/doc|q'

  # for neovim
  mkdir -p ~/.local/share/nvim/site/pack/coc/start
  cd ~/.local/share/nvim/site/pack/coc/start
  curl --fail -L https://github.com/neoclide/coc.nvim/archive/release.tar.gz|tar xzfv -
  nvim -c 'helptags ~/.local/share/nvim/site/pack/coc/start|q'

when using source code of coc.nvim, you'll have to install
https://yarnpkg.com/ and run `yarn install` in project root of coc.nvim.

==============================================================================
EXTENSIONS						*coc-extensions*

To provide LSP features of different filetypes, the user have to config
|coc-config-languageserver| or install coc extensions.

Coc extensions are more powerful since they could contribute json schemes,
commands, and use middleware methods of languageserver to provide better
results.  It's also possible to provide features that beyond LSP.

Install extensions from git (not recommended):~

- Download to code by `git clone` command.
- In project root, install dependencies and compile the code by `yarn install`
  (needed by most coc extensions).
- Add the project root to vim's runtimepath by `set runtimepath^=/path/to/project`

Plugin manager like [vim-plug] can be used as well.

Note: use coc extensions from source code requires install dependencies, which
may take huge disk usage.

							*coc-extensions-npm*
Install global extensions from npm (recommended):~

Use |:CocInstall| to install coc extensions from vim's command line.

To make coc.nvim install extensions on startup, use |g:coc_global_extensions|.

To use package manager other than npm (like `yarn` or `pnpm`), use
|coc-config-npm-binPath|.

To customize npm registry for coc.nvim add `coc.nvim:registry` in your
`~/.npmrc`, like:
>
	coc.nvim:registry=https://registry.mycompany.org/
<
To customize extensions folder, user |g:coc_data_home|.

Uninstall global extensions:~

Use |:CocUninstall|.

Update global extensions:~

Use |:CocUpdate| or |:CocUpdateSync|.

To update extensions automatically, config |coc-preferences-extensionUpdateCheck|.

Manage extensions list:~

Use |coc-list-extensions| or other list plugin that request extensions list by
|CocAction('extensionStats')|.

Single file extensions:~

All Javascript files that ends with `.js` inside the folder
|g:coc_config_home| + '/coc-extensions' are considered as coc extensions, for
example:
>
  const {window} = require('coc.nvim')

  exports.activate = context => {
    window.showInformationMessage("message from extension")
  }
<
==============================================================================
CONFIGURATION						*coc-configuration*

The configuration of coc.nvim is stored in file `coc-settings.json`.

Configuration properties are contributed by coc.nvim itself and coc.nvim
extensions.  See |coc-config| for builtin configurations.

The configuration files are all in JSON format (with comment supported), it's
recommended to enable JSON completion and validation by install the `coc-json`
extension: >

	:CocInstall coc-json
<
Global configuration file:~

Command |:CocConfig| will open (create when necessary) a user settings
file in the folder returned by |coc#util#get_config_home()|.

The user configuration can also be changed by API |coc#config()|.

The global configuration file can be created in another directory by setting
|g:coc_config_home| in your vimrc like: >

	let g:coc_config_home = '/path/to/folder'

Folder configuration file:~

To create a local configuration file for a specific workspace, use
|:CocLocalConfig| to create and open `.vim/coc-settings.json` in current
workspace folder.

Folder configuration would overwrite user configuration.

							*coc-configuration-scope*
Configuration scope:~

A configuration could be one of three different configuration scopes:

- "application" the configuration could only be changed in user configuration
  file.

- "resource" the configuration could be changed in user and workspace folder
  configuration file.

- "language-overridable" the configuration could be changed in user and
  workspace folder configuration file, and can be use used in language scoped
  configuration section like `[typescript][json]`.

==============================================================================
FLOATING WINDOWS					*coc-floating*

Floating windows/popups are created by |api-floatwin| on neovim or |popupwin|
on vim.
							*coc-floating-scroll*
Scroll floating windows:~

See |coc#float#has_scroll()| for example.

Note: use |coc#pum#scroll()| for scroll popup menu.

							*coc-floating-close*
Close floating windows:~

To close all floating windows/popups use |coc#float#close_all()| or
|popup_clear()| on vim.  Or you can use <CTRL-w>o on neovim which close all
split windows as well.

To close single floating window/popup, use |coc#float#close()|.

							*coc-floating-focus*
Focus floating windows:~

On neovim, use <CTRL-w>w (or |<Plug>(coc-float-jump)|) could focus a floating
window just created (if it's focusable).  It's not allowed to focus popups on
vim, unless it's using terminal buffer.

							*coc-floating-config*
Configure floating windows:~

To set custom window options on floating window create, use autocmd
|CocOpenFloat| or |CocOpenFloatPrompt|.

Related variables:

- |g:coc_borderchars|
- |g:coc_border_joinchars|
- |g:coc_markdown_disabled_languages|

Related highlight groups:

- |CocFloating| For floating window background.
- |CocFloatDividingLine| For dividing lines.
- |CocMenuSel| For selected line.
- |CocUnderline| For active parts.

To customize floating windows used by popup menu. Use configurations:

- |coc-config-suggest-floatConfig|
- |coc-config-suggest-pumFloatConfig|

For floating windows created around cursor, like diagnostics, hover and
signature use |coc-config-floatFactory-floatConfig| for common float
configurations. For further customization, use:

- |coc-config-diagnostic-floatConfig|
- |coc-config-signature-floatConfig|
- |coc-config-hover-floatConfig|

For customize dialog windows, use |coc-config-dialog|.
For customize notification windows, use |coc-config-notification|.

==============================================================================
LSP FEATURES 						*coc-lsp*

All features (except for telemetry) of LSP 3.16 are supported, checkout
the specification at
https://microsoft.github.io/language-server-protocol/specifications/specification-3-16/

LSP features only works with attached document, see |coc-document-attached|.

To check exists providers of current buffer, use command
`:CocCommand document.checkBuffer` or |CocHasProvider()|.

For historic reason, some features just works, but some are not.

Features automatically work by default:~

- Trigger completion |coc-completion|.
- Diagnostics refresh |coc-diagnostics|.
- Pull diagnostics |coc-pullDiagnostics|.
- Trigger signature help |coc-signature|.
- Inlay hints |coc-inlayHint|

Most features could be disabled/enabled by |coc-configuration| and some
vim variables.

Features require enabled by configuration:~

- Semantic highlights |coc-semantic-highlights|.
- Document color highlights |coc-document-colors|.
- Code lens, |coc-code-lens|
- Linked editing, |coc-linked-editing.|
- Format on type, enabled by |coc-preferences-formatOnType|
- Format on save, enabled by |coc-preferences-formatOnSaveFiletypes|.

Features requested by user:~

- Locations related (including definitions, references etc.) |coc-locations|
- Invoke code action |coc-code-actions|.
- Show call hierarchy tree |coc-callHierarchy|.
- Format, range format and on type format |coc-format|.
- Highlight same symbol ranges |coc-document-highlights|.
- Outline of document symbols |coc-outline| and |coc-list-symbols|.
- Show hover information |coc-hover|.
- Rename symbol under cursor |coc-rename|.
- Open link under cursor |coc-document-links|.
- Selection range |coc-selection-range|
- Create folding ranges |coc-fold|.

For convenient, some actions have associated |coc-key-mappings| provided.
Prefer |CocAction()| for more options.

Features triggered by languageserver:~

- Show message notification (use |coc-notification|).
- Show message request (use |coc-dialog-menu|).
- Log message notification (use `:CocCommand workspace.showOutput` to show
  output).
- Show document request (opened by vim or your browser for url).
- Work done progress (use |coc-notification|).

To make coc.nvim provide LSP features for your languages, checkout
https://github.com/neoclide/coc.nvim/wiki/Language-servers

To debug issues with languageserver, checkout
https://github.com/neoclide/coc.nvim/wiki/Debug-language-server

------------------------------------------------------------------------------
DOCUMENT 						*coc-document*

An associated document is created on buffer create, and disposed on buffer
unload.

Attached document:~
							*coc-document-attached*

An attached document means coc.nvim synchronize the lines of vim's buffer with
associated document automatically.

Only attached documents are synchronized with language servers and therefore
LSP features could be provided for the attached buffer.

The buffer may not be attached by following reasons:

- The 'buftype' is neither <empty> nor 'acwrite', (could be bypassed by
  |b:coc_force_attach|).
- Buffer variable |b:coc_enabled| is `0`.
- Byte length of buffer exceed |coc-preferences-maxFileSize|.
- Buffer is used for command line window.

Use |CocAction('ensureDocument')| or `:CocCommand document.checkBuffer` to
check attached state of current buffer.

Filetype map:~
							*coc-document-filetype*

Some filetypes are mapped to others to match the languageId used by VSCode,
including:

- javascript.jsx -> javascriptreact
- typescript.jsx -> typescriptreact
- typescript.tsx -> typescriptreact
- tex -> latex

Use |g:coc_filetype_map| to create additional filetype maps.

Use `:CocCommand document.echoFiletype` to echo mapped filetype of current
document.

Note make sure use mapped filetypes for configurations that expect filetypes.

------------------------------------------------------------------------------
HOVER							*coc-hover*

Hover feature provide information at a given text document position, normally
include type information and documentation of current symbol.

Hover functions:~

- ||CocAction('doHover')| Show hover information at cursor position.
- |CocAction('definitionHover')||| Show hover information with definition
  context at cursor position.
- |CocAction('getHover')| Get hover documentations at cursor position.

							*coc-hover-example*
Hover key-mapping example:~
>
  nnoremap <silent> K :call ShowDocumentation()<CR>
  " Show hover when provider exists, fallback to vim's builtin behavior.
  function! ShowDocumentation()
    if CocAction('hasProvider', 'hover')
      call CocActionAsync('definitionHover')
    else
      call feedkeys('K', 'in')
    endif
  endfunction
<
------------------------------------------------------------------------------
COMPLETION						*coc-completion*

The builtin completion of vim is no longer used, the default completion
behavior works like VSCode:

- Completion is automatically triggered by default.
- Item selection is enabled by default, use |coc-config-suggest-noselect| to
  disable default selection.
- When selection enabled and no preselect item exists, recent used item that
  matched will be selected by default.
- Snippet and additional edits only work after confirm completion.
- 'completeopt' is not used and APIs of builtin popupmenu not work.

							*coc-completion-default*
Default Key-mappings:~

To make the completion work like builtin completion without configuration,
following key-mappings are used when the {lhs} is not mapped:

Use <C-n>, <C-p>, <up> and <down> to navigate completion list: >

  inoremap <silent><expr> <C-n> coc#pum#visible() ? coc#pum#next(1) : "\<C-n>"
  inoremap <silent><expr> <C-p> coc#pum#visible() ? coc#pum#prev(1) : "\<C-p>"
  inoremap <silent><expr> <down> coc#pum#visible() ? coc#pum#next(0) : "\<down>"
  inoremap <silent><expr> <up> coc#pum#visible() ? coc#pum#prev(0) : "\<up>"
<
Use <PageDown> and <PageUp> to scroll: >

  inoremap <silent><expr> <PageDown> coc#pum#visible() ? coc#pum#scroll(1) : "\<PageDown>"
  inoremap <silent><expr> <PageUp> coc#pum#visible() ? coc#pum#scroll(0) : "\<PageUp>"
<
Use <C-e> and <C-y> to cancel and confirm completion: >

  inoremap <silent><expr> <C-e> coc#pum#visible() ? coc#pum#cancel() : "\<C-e>"
  inoremap <silent><expr> <C-y> coc#pum#visible() ? coc#pum#confirm() : "\<C-y>"

Note: <CR> and <Tab> are not remapped by coc.nvim.

							*coc-completion-variables*
Related variables:~

- Disable completion for buffer: |b:coc_suggest_disable|
- Disable specific sources for buffer: |b:coc_disabled_sources|
- Disable words for trigger completion: |b:coc_suggest_blacklist|
- Add additional keyword characters: |b:coc_additional_keywords|

							*coc-completion-functions*
Related functions:~

- Trigger completion with options: |coc#start()|.
- Trigger completion refresh: |coc#refresh()|.
- Select and confirm completion: |coc#_select_confirm()|.
- Check if customized popupmenu is visible: |coc#pum#visible()|.
- Select next complete item: |coc#pum#next()|.
- Select previous complete item: |coc#pum#prev()|.
- Cancel completion and reset trigger text: |coc#pum#cancel()|.
- Confirm completion: |coc#pum#confirm()|.
- Close the popupmenu only: |coc#pum#stop()|.
- Get information of the popupmenu: |coc#pum#info()|.
- Select specific complete item: |coc#pum#select()|.
- Insert word of selected item and finish completion: |coc#pum#insert()|.
- Scroll popupmenu: |coc#pum#scroll()|.

							*coc-completion-customize*
Customize completion:~

Use |coc-config-suggest| to change behavior of completion.

Use 'pumwidth' for configure minimal width of popupmenu and 'pumheight'
for maximum height.

Related Highlight groups:
	|CocPum| 	for highlight groups of customized pum.
	|CocSymbol| 	for kind icons.
	|CocMenuSel| 	for background highlight of selected item.

Note: background, border and winblend are configured by
|coc-config-suggest-floatConfig|.

Example user key-mappings:~
							*coc-completion-example*

Note: use command `:verbose imap` to check current insert
key-mappings when your key-mappings not work.

Use <tab> and <S-tab> to navigate completion list: >

  function! CheckBackSpace() abort
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~ '\s'
  endfunction

  " Insert <tab> when previous text is space, refresh completion if not.
  inoremap <silent><expr> <TAB>
	\ coc#pum#visible() ? coc#pum#next(1):
	\ CheckBackSpace() ? "\<Tab>" :
	\ coc#refresh()
  inoremap <expr><S-TAB> coc#pum#visible() ? coc#pum#prev(1) : "\<C-h>"

Use <c-space> to trigger completion: >

  if has('nvim')
    inoremap <silent><expr> <c-space> coc#refresh()
  else
    inoremap <silent><expr> <c-@> coc#refresh()
  endif
<
Use <CR> to confirm completion, use: >

  inoremap <expr> <cr> coc#pum#visible() ? coc#_select_confirm() : "\<CR>"
<
To make <CR> to confirm selection of selected complete item or notify coc.nvim
to format on enter, use: >

  inoremap <silent><expr> <CR> coc#pum#visible() ? coc#_select_confirm()
				\: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"

Map <tab> for trigger completion, completion confirm, snippet expand and jump
like VSCode: >

  inoremap <silent><expr> <TAB>
    \ coc#pum#visible() ? coc#_select_confirm() :
    \ coc#expandableOrJumpable() ?
    \ "\<C-r>=coc#rpc#request('doKeymap', ['snippets-expand-jump',''])\<CR>" :
    \ CheckBackSpace() ? "\<TAB>" :
    \ coc#refresh()

  function! CheckBackSpace() abort
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~# '\s'
  endfunction

  let g:coc_snippet_next = '<tab>'
<
Note: the `coc-snippets` extension is required for this to work.

------------------------------------------------------------------------------
DIAGNOSTICS SUPPORT 					*coc-diagnostics*

Diagnostics of coc.nvim are automatically refreshed to UI by default, checkout
|coc-config-diagnostic| for available configurations.

Note most language servers only send diagnostics for opened buffers for
performance reason, some lint tools could provide diagnostics for all files in
workspace.

Note pull diagnostics feature is added in LSP 3.17, which is not available
yet.

							*coc-diagnostics-refresh*
Changes on diagnostics refresh~

- Add highlights for diagnostic ranges and virtual text (when enabled on
  neovim or vim >= 9.0.0067), see |coc-highlights-diagnostics|.
- Add diagnostic signs to 'signcolumn', use `set signcolumn=yes` to avoid
  unnecessary UI refresh.
- Update variable |b:coc_diagnostic_info|.
- Refresh related |location-list| which was opened by |:CocDiagnostics|.

Diagnostics are not refreshed when buffer is hidden, and refresh on insert
mode is disabled by default.

Diagnostics highlights:~

See |coc-highlights-diagnostics|.

							*coc-diagnostics-toggle*
Enable and disable diagnostics~

Use |coc-config-diagnostic-enable| to toggle diagnostics feature.

Use |CocAction('diagnosticToggle')| for enable/disable diagnostics feature.

Use |CocAction('diagnosticToggleBuffer')| for enable/disable diagnostics of
current buffer.

Show diagnostic messages~

Diagnostic messages would be automatically shown/hide when the diagnostics
under cursor position changed (use float window/popup when possible) by
default.

To manually refresh diagnostics messages, use |<Plug>(coc-diagnostic-info)|
and |CocAction('diagnosticPreview')|.

							*coc-diagnostics-jump*
Jump between diagnostics~

Use key-mappings:

	|<Plug>(coc-diagnostic-next)| jump to next diagnostic.
	|<Plug>(coc-diagnostic-prev)| jump to previous diagnostic.
	|<Plug>(coc-diagnostic-next-error)| jump to next error.
	|<Plug>(coc-diagnostic-prev-error)| jump to previous error.

Check all diagnostics~

Use |coc-list-diagnostics| to open |coc-list| with all available diagnostics.

Use API |CocAction('diagnosticList')| to get list of all diagnostics.

------------------------------------------------------------------------------
PULL DIAGNOSTICS SUPPORT 				*coc-pullDiagnostics*

Diagnostics are pulled for visible documents when supported by languageserver.
Pull for workspace diagnostics is also enabled by default.

Document diagnostics are pulled on change by default, and can be
configured to be pulled on save.

Checkout |coc-config-pullDiagnostic| for related configurations.

------------------------------------------------------------------------------
LOCATIONS SUPPORT 					*coc-locations*

There're different kinds of locations, including "definitions", "declarations",
"implementations", "typeDefinitions" and "references".

Key-mappings for invoke locations request~

- |<Plug>(coc-definition)|
- |<Plug>(coc-declaration)|
- |<Plug>(coc-implementation)|
- |<Plug>(coc-type-definition)|
- |<Plug>(coc-references)|
- |<Plug>(coc-references-used)|

Error will be shown when the buffer not attached |coc-document-attached|.
Message will be shown when no result found.

Location jump behavior~

When there's only one location returned, the location is opened by command
specified by |coc-preferences-jumpCommand| ("edit" by default), context mark
is added by |m'|, so you can jump back previous location by <C-o>.

When multiple locations returned, |coc-list-location| is opened for preview
and other further actions.

To use |coc-list-location| for single location as well, use
|coc-locations-api| (instead key-mappings provided by coc.nvim).

To change default options of |coc-list-location| or use other plugin for
list of locations, see |g:coc_enable_locationlist|.

To use vim's quickfix for locations, use configuration
|coc-preferences-useQuickfixForLocations|.

To use vim's tag list for definitions, use |CocTagFunc()|.

							*coc-locations-api*
Related APIs~

- |CocAction('jumpDefinition')| Jump to definition locations.
- |CocAction('jumpDeclaration')| Jump to declaration locations.
- |CocAction('jumpImplementation')| Jump to implementation locations.
- |CocAction('jumpTypeDefinition')| Jump to type definition locations.
- |CocAction('jumpReferences')|| Jump to references
- |CocAction('jumpUsed')| Jump to references without declarations.
- |CocAction('definitions')| Get definition list.
- |CocAction('declarations')| Get declaration list.
- |CocAction('implementations')| Get implementation list.
- |CocAction('typeDefinitions')| Get type definition list.
- |CocAction('references')| Get reference list.

Send custom locations request to languageserver:

- |CocLocations()|
- |CocLocationsAsync()|

------------------------------------------------------------------------------
RENAME 							*coc-rename*

Rename feature provide workspace-wide rename of a symbol. Workspace edit
|coc-workspace-edit| is requested and applied to related buffers when
confirmed.

Check if current buffer have rename provider by
`:echo CocAction('hasProvider', 'rename')`

Rename key-mappings:~

- |<Plug>(coc-rename)|

Rename functions:~

- |CocAction('rename')| Rename the symbol under the cursor position.
- |CocAction('refactor')| Open refactor buffer for all references (including
  definitions), recommended for function signature refactor.

Rename local variable:~

Use command `:CocCommand document.renameCurrentWord` which uses |coc-cursors|
for edit multiple locations at the same time and fallback to word extraction
when rename provider not exists.

Rename configuration:~

use |coc-preferences-renameFillCurrent| to enable/disable populating prompt
window with current variable name.

------------------------------------------------------------------------------
SIGNATURE HELP 						*coc-signature*

Signature help of function is automatically triggered by default(when user
type trigger characters defined by the provider), which will use float
window/popup to show the signature documentations by default.

Use |CocAction('showSignatureHelp')| to trigger signature help manually.

Note error will not be thrown when provider not exists or nothing returned
from languageserver, use `echo CocAction('hasProvider', 'signature')` to check
if signature help provider exists.

Use |coc-config-signature| to change default signature help behavior.

------------------------------------------------------------------------------
INLAY HINT 						*coc-inlayHint*

Inlay hint is enabled for all filetypes by default. Inlay hint uses virtual
text which requires neovim >= 0.5.0 or vim >= 9.0.0067.

Note: you may need configure extension or languageserver to make inlay hint
works.

To temporarily toggle inlay hint of current buffer, use command
`:CocCommand document.toggleInlayHint`

Change highlight group:~

|CocInlayHint|

Configure inlay hint support:~

|coc-config-inlayHint|

------------------------------------------------------------------------------
FORMAT 							*coc-format*

Some tools may reload buffer from disk file during format, coc.nvim only
apply `TextEdit[]` to the document.

Don't be confused with vim's indent feature, configure/fix the 'indentexpr' of
your buffer if the indent is wrong after insert new line.

							*coc-format-options*
Format options:~

Buffer options that affect document format: 'eol', 'shiftwidth' and
'expandtab'.

- |b:coc_trim_trailing_whitespace| Trim trailing whitespace on a line.
- |b:coc_trim_final_newlines| Trim all newlines after the final newline at the
  end of the file.

Those options are converted to `DocumentFormattingOptions` and transferred to
languageservers before format.  The languageservers may only support some of
those options.

							*coc-format-document*
Format full document:~

Use |CocAction('format')|, you can create a command like: >

	command! -nargs=0 Format :call CocActionAsync('format')
<
to format current buffer.

							*coc-format-ontype*
Format on type:~

Format on type is disabled by default, could be enabled by configurations:

- |coc-preferences-formatOnType|
- |coc-preferences-formatOnTypeFiletypes|

Use `:CocCommand document.checkBuffer` to check if `formatOnType` provider
exists for current buffer.

To format on <CR>, create key-mapping of <CR> that uses |coc#on_enter()|.

If you don't like the behavior on type bracket characters, configure
|coc-preferences-bracketEnterImprove||.

							*coc-format-selected*
Format selected code:~

Use 'formatexpr' for specific filetypes: >

  autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')

So that |gq| could works for format range of lines.
>
Setup visual mode and operator key-mappings: >

  xmap <leader>f  <Plug>(coc-format-selected)
  nmap <leader>f  <Plug>(coc-format-selected)
<
							*coc-format-onsave*
Format on save:~

Use configuration |coc-preferences-formatOnSaveFiletypes|.

Or create |BufWritePre| autocmd like: >

	autocmd BufWritePre * call CocAction('format')
<
Note the operation have to synchronized, avoid use |CocActionAsync()|.
Note to skip the autocmd, use `:noa w` to save the buffer.

The operation on save will be timeout after 0.5s by default, configured by
|coc-preferences-willSaveHandlerTimeout|

------------------------------------------------------------------------------
CODE ACTION 						*coc-code-actions*

Code actions are used for ask languageserver to provide specific kind code
changes.

There're different kinds of code actions:

- `quickfix` used for fix diagnostic(s).
- `refactor` used for code refactor.
- `source` code actions apply to the entire file.
- `organizeImport` organize import statements of current document.

Key-mappings for code actions:~

- |<Plug>(coc-fix-current)| Invoke quickfix action at current line if any.
- |<Plug>(coc-codeaction-cursor)| Choose code actions at cursor position.
- |<Plug>(coc-codeaction-line)| Choose code actions at current line.
- |<Plug>(coc-codeaction)| Choose code actions of current file.
- |<Plug>(coc-codeaction-selected)| Choose code actions from selected range.

Except for |<Plug>(coc-fix-current)| which invoke code action directly,
|coc-dialog-menu| would be shown for pick specific code action.

To invoke organize import action, use command like:
>
	command! -nargs=0 OR :CocCommand editor.action.organizeImport

Error would be shown when organize import code action not found.

Related APIs~

- |CocAction('codeActions')|
- |CocAction('organizeImport')|
- |CocAction('fixAll')|
- |CocAction('quickfixes')|
- |CocAction('doCodeAction')|
- |CocAction('doQuickfix')|
- |CocAction('codeActionRange')|

------------------------------------------------------------------------------
DOCUMENT HIGHLIGHTS 					*coc-document-highlights*

Document highlights is used for highlight same symbols of current document
under cursor.

To enable highlight on CursorHold, create an autocmd like this: >

	autocmd CursorHold * call CocActionAsync('highlight')
<
Checkout |coc-highlights-document| for related highlight groups.

Note error will not be thrown when provider not exists or nothing returned
from languageserver with |CocAction('highlight')|

Install `coc-highlight` extension if you want to highlight same words under
cursor without languageserver support.

To jump between previous/next symbol position, use
`:CocCommand document.jumpToPrevSymbol` and
`:CocCommand document.jumpToNextSymbol`

------------------------------------------------------------------------------
DOCUMENT COLORS 					*coc-document-colors*

Document colors added color highlights to vim buffers.  To enable document
color highlights, use ||coc-config-colors-filetypes||.

Note: the highlights define gui colors only, make use you have 'termguicolors'
enabled (and your terminal support gui colors) if you're not using gvim.

To pick a color from system color picker, use |CocAction('pickColor')| or
choose `editor.action.pickColor` from |:CocCommand|.

Note: may not work on your system.

To change color presentation, use |CocAction('colorPresentation')| or choose
`editor.action.colorPresentation` from |:CocCommand|.

To highlights colors without languageservers, install
https://github.com/neoclide/coc-highlight

==============================================================================
DOCUMENT LINKS 						*coc-document-links*

Check if current buffer have documentLink provider by
`:echo CocAction('hasProvider', 'documentLink')`

Use |coc-list-links| to manage list of links in current document.

Document link functions:~

- |CocAction('openLink')| Open link under cursor.
- |CocAction('links')| Get link list of current buffer.

------------------------------------------------------------------------------
SNIPPETS SUPPORT 					*coc-snippets*

Snippets engine of coc.nvim support both VSCode snippets and ultisnips
snippets format.

The complete item with snippet format has label ends with
|coc-config-suggest-snippetIndicator| (`~` by default).

Select the complete item and confirm the completion by |coc#pum#confirm()| or
|coc#_select_confirm()| to expand the snippet of current selected complete
ttem.

Jump snippet placeholders:~

|g:coc_snippet_next| and |g:coc_snippet_prev| are used to jump placeholders on
both select mode and insert mode, which defaults to <C-j> and <C-k>.  Buffer
key-mappings are created on snippet activate, and removed on snippet
deactivate.

Deactivate snippet session:~

A snippet session would be deactivated under the following conditions:

- |InsertEnter| triggered outside snippet.
- Jump to final placeholder.
- Content change detected after snippet.
- Content changed in a snippet outside placeholder (except for deletion of
  plain text).

To load and expand custom snippets, install `coc-snippets` extension is
recommended.

Related configurations:~

- |g:coc_snippet_prev|
- |g:coc_snippet_next|
- |g:coc_selectmode_mapping|
- |coc-config-suggest-snippetIndicator|
- |coc-config-suggest-preferCompleteThanJumpPlaceholder|
- |coc-config-snippet-highlight|
- |coc-config-snippet-statusText|
- |coc-config-snippet-nextPlaceholderOnDelete|

Related functions:~

- |coc#snippet#next()|
- |coc#snippet#prev()|
- |coc#expandable()|
- |coc#jumpable()|
- |coc#expandableOrJumpable()|

Related variables, highlights and autocmds:~

- |b:coc_snippet_active| Check if snippet session is activated.
- |CocSnippetVisual| For highlight of current placeholders.
- |CocJumpPlaceholder| AutocmdS triggered after placeholder jump.

------------------------------------------------------------------------------
WORKSPACE SUPPORT 					*coc-workspace*

							*coc-workspace-folders*
Workspace folders~

Unlike VSCode which prompt you to open folders, workspace folders of coc.nvim
are resolved from filepath after document attached.

A list of file/folder names is used for resolve workspace folder, the patterns
could comes from:

- |b:coc_root_patterns|
- `rootPatterns` field of configured language server.
- `rootPatterns` contributions from coc extensions.
- |coc-preferences-rootPatterns|

Workspace folder is resolved from cwd of vim first and then from top directory
to the parent directory of current filepath, when workspace folder not
resolved, current working directory is used if it's parent folder of current
buffer.  Configurations are provided to change the default behavior:

- |coc-config-workspace-ignoredFiletypes|
- |coc-config-workspace-ignoredFolders|
- |coc-config-workspace-bottomUpFiletypes|
- |coc-config-workspace-workspaceFolderCheckCwd|
- |coc-config-workspace-workspaceFolderFallbackCwd|

Note for performance reason, user's home directory would never considered as
workspace folder, which also means the languageserver that requires workspace
folder may not work when you start vim from home directory.

To preserve workspace folders across vim session, |g:WorkspaceFolders| is
provided.

To manage current workspace folders, use |coc-list-folders|

To get related root patterns of current buffer, use |coc#util#root_patterns()|

Use `:CocCommand workspace.workspaceFolders` to echo current workspaceFolders.

							*coc-workspace-edits*
Workspace edit~

Workspace edit is used to apply changes for multiple buffers(and files), the
edit could includes document edits and file operations (including file create,
file/directory delete and file/directory rename).

When the edit failed to apply, coc.nvim will revert the changes (including
document edits and file operations) that previous made.

Files not loaded would be loaded by `tab drop` command, configured by
|coc-config-workspace-openResourceCommand|.

To undo and redo workspace edit just applied, use command
`:CocCommand workspace.undo` and `:CocCommand workspace.redo`

To inspect previous workspace edit, use command
`:CocCommand workspace.inspectEdit`, in opened buffer, use <CR> for jump to
change position under cursor.

------------------------------------------------------------------------------
CURSORS SUPPORT						*coc-cursors*

Multiple cursors supported is added to allow edit multiple locations at once.

Cursors session could be started by following ways:

- Use command `:CocCommand document.renameCurrentWord` to rename variable
  under cursor.
- Use |<Plug>(coc-refactor)| to open refactor buffer.
- Use |:CocSearch| to open searched locations.
- Use cursors related key-mappings to add text range, including
  |<Plug>(coc-cursors-operator)|, |<Plug>(coc-cursors-word)|,
  |<Plug>(coc-cursors-position)| and |<Plug>(coc-cursors-range)|
- Ranges added by command `editor.action.addRanges` from coc extensions.

Default key-mappings when cursors activated:

- <esc> cancel cursors session.
- <C-n> jump to next cursors range.
- <C-p> jump to previous cursors range.

Use |coc-config-cursors| to change cursors related key-mappings.
Use highlight group |CocCursorRange| to change default range highlight.
Use |b:coc_cursors_activated| to check if cursors session is activated.

------------------------------------------------------------------------------
SYMBOLS OUTLINE						*coc-outline*

Outline is a split window with current document symbols rendered as
|coc-tree|.

To show and hide outline of current window, use |CocAction('showOutline')| and
|CocAction('hideOutline')|.

Outline view has Window variable `cocViewId` set to `OUTLINE`.

Following outline features are supported:
- Start fuzzy filter by |coc-config-tree-key-activeFilter|.
- Automatic update after document change.
- Automatic reload when buffer in current window changed.
- Automatic follow cursor position by default.
- Different filter modes that can be changed on the fly
  |coc-config-outline-switchSortKey|.
- Enable auto preview by |coc-config-outline-togglePreviewKey|.

Note: outline would try to reload document symbols after 500ms when provider
not registered, which avoid the necessary to check provider existence.

Checkout |coc-config-tree| and |coc-config-outline| for available
configurations.

Checkout |CocTree| and |CocSymbol| for customize highlights.

Use configuration `"suggest.completionItemKindLabels"` for custom icons.

To show outline for each tab automatically, use |autocmd|:
>
  autocmd VimEnter,Tabnew *
	  \ if empty(&buftype) | call CocActionAsync('showOutline', 1) | endif
<
To close outline when it's the last window automatically, use
|autocmd| like:
>
  autocmd BufEnter * call CheckOutline()
  function! CheckOutline() abort
    if &filetype ==# 'coctree' && winnr('$') == 1
      if tabpagenr('$') != 1
        close
      else
        bdelete
      endif
    endif
  endfunction
<
Create a key-mapping to toggle outline, like:
>
  nnoremap <silent><nowait> <space>o  :call ToggleOutline()<CR>
  function! ToggleOutline() abort
    let winid = coc#window#find('cocViewId', 'OUTLINE')
    if winid == -1
      call CocActionAsync('showOutline', 1)
    else
      call coc#window#close(winid)
    endif
  endfunction
<
------------------------------------------------------------------------------
CALL HIERARCHY						*coc-callHierarchy*

A call hierarchy is a split |coc-tree| with locations for incoming or
outgoing calls of current function.

Call hierarchy window is opened by |CocAction('showIncomingCalls')| and
|CocAction('showOutgoingCalls')|.

Call hierarchy is configured by |CocSymbol|, |coc-config-callHierarchy| and
|coc-config-tree|.

Related ranges are highlighted with |CocSelectedRange| highlight group in
opened buffer.

|coc-dialog-menu| could be invoked by |coc-config-tree-key-actions|.
Available actions:

- Dismiss.
- Open in new tab.
- Show Incoming Calls.
- Show Outgoing Calls.

Use <CR> in call hierarchy tree to open location in original window.

------------------------------------------------------------------------------
SEMANTIC HIGHLIGHTS					*coc-semantic-highlights*

Semantic tokens are used to add additional color information to a buffer that
depends on language specific symbol information.

The feature requires vim >= 8.1.1719 or neovim >= 0.5.0.

Use |coc-config-semanticTokens-enable| to enable semantic tokens highlights.

Use `:CocCommand semanticTokens.checkCurrent` to check semantic highlight
information with current buffer.

To create custom highlights for symbol under cursor, follow these steps:

- Inspect semantic token by
>
  :CocCommand semanticTokens.inspect
<
  to check token type and token modifiers with current symbol.

- Create new highlight group by |highlight|, for example:
>
  :hi link CocSemDeclarationVariable MoreMsg
<
- Refresh semantic highlight of current buffer by:
>
  :CocCommand semanticTokens.refreshCurrent
<
See |CocSem| to customize semantic token highlight groups.

See |coc-config-semanticTokens| for related configurations.

------------------------------------------------------------------------------
FOLD 							*coc-fold*

Check if current buffer have fold provider by
`:echo CocAction('hasProvider', 'foldingRange')`

Use |CocAction('fold')| to create folds by request the languageserver and
create manual folds on current window.

------------------------------------------------------------------------------
SELECTION RANGE 					*coc-selection-range*

Select range forward or backward at cursor position.

Check if current buffer have selection range provider by
`:echo CocAction('hasProvider', 'selectionRange')`

Selection range key-mappings:~

- |<Plug>(coc-range-select)| Select range forward.
- |<Plug>(coc-range-select-backward)| Select range backward.

Selection range function:~

- |CocAction('rangeSelect')| Visual select previous or next selection range

------------------------------------------------------------------------------
CODE LENS 						*coc-code-lens*

Code lens feature shows additional information above or after specific lines.
Only works on neovim by now.

Check if current buffer have code lens provider by
`:echo CocAction('hasProvider', 'codeLens')`

Code lens are not shown by default, use |coc-config-codeLens-enable| to enable,
you may also need enable code lens by configure extension or configured
languageserver.

Code lens are automatically requested on buffer create/change, checkout
|coc-config-codeLens| for available configurations.

------------------------------------------------------------------------------
LINKED EDITING 						*coc-linked-editing*

Linked editing feature enables editing multiple linked ranges at the same time,
for example: html tags.  The linked editing ranges would be highlighted with
|CocLinkedEditing| when activated.

Check if current buffer have linked editing provider by
`:echo CocAction('hasProvider', 'linkedEditing')`

Linked editing feature is disabled by default, use
|coc-preferences-enableLinkedEditing| to enable.

==============================================================================
INTERFACE						*coc-interface*

------------------------------------------------------------------------------

Key mappings						*coc-key-mappings*

There're some cases that local key-mappings are enabled for current buffer.

	Snippet jump key-mappings when snippet is activated:
	|g:coc_snippet_prev| and |g:coc_snippet_next|.

	Cursor jump and cancel key-mappings when cursors is activated
	|coc-config-cursors|.

	Dialog key-mappings for confirm and cancel dialog window
	|coc-config-dialog|.

	Key-mappings for |CocList| buffer: |coc-list-mappings|.

Note: Use |:verbose| command to check key-mappings that taking effect.

Note: Use 'noremap' with <Plug> will make the key-mapping not work at all.

Note: <Plug> key-mappings are provided for convenient, use |CocActionAsync()| or
|CocAction()| for more options.

Normal mode key-mappings:~

*<Plug>(coc-diagnostic-info)* Show diagnostic message of current position by
invoke |CocAction('diagnosticInfo')|

*<Plug>(coc-diagnostic-next)* Jump to next diagnostic position.

*<Plug>(coc-diagnostic-prev)* Jump to previous diagnostic position.

*<Plug>(coc-diagnostic-next-error)* Jump to next diagnostic error position.

*<Plug>(coc-diagnostic-prev-error)* Jump to previous diagnostic error position.

*<Plug>(coc-definition)* Jump to definition(s) of current symbol by invoke
|CocAction('jumpDefinition')|

*<Plug>(coc-declaration)* Jump to declaration(s) of current symbol by invoke
|CocAction('jumpDeclaration')|

*<Plug>(coc-implementation)* Jump to implementation(s) of current symbol by
invoke |CocAction('jumpImplementation')|

*<Plug>(coc-type-definition)* Jump to type definition(s) of current symbol by
invoke |CocAction('jumpTypeDefinition')|

*<Plug>(coc-references)* Jump to references of current symbol by invoke
|CocAction('jumpReferences')|

*<Plug>(coc-references-used)* Jump to references of current symbol exclude
declarations.

*<Plug>(coc-format-selected)*

	Format selected range, works on both |visual-mode| and |normal-mode|,
	when used in normal mode, the selection works on the motion object.

	For example: >

	vmap <leader>p  <Plug>(coc-format-selected)
	nmap <leader>p  <Plug>(coc-format-selected)
<
	makes `<leader>p` format the visually selected range, and you can use
	`<leader>pap` to format a paragraph.

*<Plug>(coc-format)* Format the whole buffer by invoke |CocAction('format')|
*<Plug>(coc-rename)* Rename symbol under cursor to a new word by invoke
|CocAction('rename')|

*<Plug>(coc-refactor)* Open refactor window for refactor of current symbol by
invoke |CocAction('refactor')|

*<Plug>(coc-command-repeat)* Repeat latest |CocCommand|.

*<Plug>(coc-codeaction)* Get and run code action(s) for current file, use
|coc-codeaction-cursor| for same behavior as VSCode.

*<Plug>(coc-codeaction-line)* Get and run code action(s) for current line.

*<Plug>(coc-codeaction-cursor)* Get and run code action(s) using empty range
at current cursor.

*<Plug>(coc-codeaction-selected)* Get and run code action(s) with the selected
region.  Works on both |visual-mode| and |normal-mode|.

*<Plug>(coc-openlink)* Open link under cursor by use |CocAction('openlink')|.

*<Plug>(coc-codelens-action)* Do command from codeLens of current line.

*<Plug>(coc-fix-current)* Try first quickfix action for diagnostics of current
line.

*<Plug>(coc-float-hide)* Hide all float windows/popups created by coc.nvim.

*<Plug>(coc-float-jump)* Jump to first float window (neovim only), use
|CTRL-W_p| for jump to previous window.

*<Plug>(coc-range-select)*

	Select next selection range.
	Works on both |visual-mode| and |normal-mode|.

	Note: requires selection ranges feature of language server.

*<Plug>(coc-funcobj-i)*

	Select inside function. Recommend mapping:
	Works on both |visual-mode| and |normal-mode|.
  >
	xmap if <Plug>(coc-funcobj-i)
	omap if <Plug>(coc-funcobj-i)
<
	Note: Requires 'textDocument.documentSymbol' support from the language
	server.

*<Plug>(coc-funcobj-a)*

	Select around function.  Works on both |visual-mode| and
	|normal-mode|.  Recommended mapping:
>
	xmap af <Plug>(coc-funcobj-a)
	omap af <Plug>(coc-funcobj-a)
<
	Note: Requires 'textDocument.documentSymbol' support from the language
	server.

*<Plug>(coc-classobj-i)*

	Select inside class/struct/interface.  Works on both |visual-mode| and
	|normal-mode|.  Recommended mapping:
>
	xmap ic <Plug>(coc-classobj-i)
	omap ic <Plug>(coc-classobj-i)
<
	Note: Requires 'textDocument.documentSymbol' support from the language
	server.

*<Plug>(coc-classobj-a)*

	Select around class/struct/interface.  Works on both |visual-mode| and
	|normal-mode|.  Recommended mapping:
>
	xmap ac <Plug>(coc-classobj-a)
	omap ac <Plug>(coc-classobj-a)
<
	Note: Requires 'textDocument.documentSymbol' support from the language
	server.


*<Plug>(coc-cursors-operator)* Add text to cursors session by motion object.

*<Plug>(coc-cursors-word)* Add current word to cursors session.

*<Plug>(coc-cursors-position)* Add current position as empty range to cursors
session.

Visual mode key-mappings:~

*<Plug>(coc-range-select-backward)*

	Select previous selection range.

	Note: requires selection ranges feature of language server, like:
	coc-tsserver, coc-python

*<Plug>(coc-cursors-range)* Add selection to cursors session.

------------------------------------------------------------------------------
VARIABLES						*coc-variables*

User defined variables:~

------------------------------------------------------------------------------

Buffer variables 					*coc-buffer-variables*

b:coc_enabled						*b:coc_enabled*

	Set to `0` on buffer create if you don't want coc.nvim receive content
	from buffer. Normally used with |BufAdd| autocmd, example:
>
	" Disable file with size > 1MB
	autocmd BufAdd * if getfsize(expand('<afile>')) > 1024*1024 |
				\ let b:coc_enabled=0 |
				\ endif
<
b:coc_force_attach					*b:coc_force_attach*

	When is `1`, attach the buffer without check the 'buftype' option.
	Should be set on buffer create.

b:coc_root_patterns					*b:coc_root_patterns*

	Root patterns used for resolving workspaceFolder for
	the current file, will be used instead of
	`"coc.preferences.rootPatterns"` setting. Example: >

	autocmd FileType python let b:coc_root_patterns =
				\ ['.git', '.env']
<

b:coc_suggest_disable					*b:coc_suggest_disable*

	Disable completion support of current buffer. Example: >

	" Disable completion for python
	autocmd FileType python let b:coc_suggest_disable = 1

b:coc_disabled_sources 					*b:coc_disabled_sources*

	Disabled completion sources of current buffer. Example:
>
	let b:coc_disabled_sources = ['around', 'buffer', 'file']
<
b:coc_diagnostic_disable				*b:coc_diagnostic_disable*

	Disable diagnostic support of current buffer.

b:coc_suggest_blacklist                 	        *b:coc_suggest_blacklist*

	List of input words for which completion should not be triggered.
	Example: >

	" Disable completion for 'end' in Lua files
	autocmd FileType lua let b:coc_suggest_blacklist = ["end"]

b:coc_additional_keywords				*b:coc_additional_keywords*

	Addition keyword characters for generate keywords. Example: >

	" Add keyword characters for CSS
	autocmd FileType css let b:coc_additional_keywords = ["-"]

b:coc_trim_trailing_whitespace				*b:coc_trim_trailing_whitespace*

	Trim trailing whitespace on a line, default `0`.
	Use by "FormattingOptions" send to the server.

b:coc_trim_final_newlines 				*b:coc_trim_final_newlines*

	Trim all newlines after the final newline at the end of the file.
	Use by "FormattingOptions" send to the server.

	Other buffer options that affect document format: 'eol', 'shiftwidth'
	and 'expandtab'.

	Note: language server may not respect format options.

------------------------------------------------------------------------------

Global variables 					*coc-global-variables*

g:coc_disable_startup_warning 				*g:coc_disable_startup_warning*

	Disable possible warning on startup for old vim/node version.

	Default: 0

g:coc_disable_uncaught_error 				*g:coc_disable_uncaught_error*

	Disable uncaught error messages from node process of coc.nvim.

	Default: 0

g:coc_text_prop_offset 					*g:coc_text_prop_offset*

	Start |textprop| id offset of highlight namespaces on vim, change to
	other value to avoid conflict.

	Default: 1000

g:coc_channel_timeout					*g:coc_channel_timeout*

	Channel timeout in seconds for request to node client.

	Default: 30

g:coc_disable_transparent_cursor			*g:coc_disable_transparent_cursor*

	Disable transparent cursor when CocList is activated.
	Set it to `1` if you have issue with transparent
	cursor.

	Default: 0

g:coc_start_at_startup					*g:coc_start_at_startup*

	Start coc service on startup, use |CocStart| to start server when you
	set it to 0.

	Default: 1

g:coc_global_extensions					*g:coc_global_extensions*

	Global extension names to install when they aren't installed.
>
	let g:coc_global_extensions = ['coc-json', 'coc-git']
<
	Note: coc.nvim will try to install extensions that are not installed
	in this list after initialization.

g:coc_uri_prefix_replace_patterns			*g:coc_uri_prefix_replace_patterns*

	This map defines URI prefix replacements. This is useful in the case
	that an LSP requires code to adhere to a particular directory
	structure. For example, `/Users/myUser/workspace` can be mapped to
	`/home/myUser/workspace`.
>
	let g:coc_uri_prefix_replace_patterns = {'/Users': '/home'}
<
g:coc_enable_locationlist				*g:coc_enable_locationlist*

	Use location list of |CocList| when jump to locations.

	Set it to 0 when you need customize behavior of location jump by use
	|CocLocationsChange| and |g:coc_jump_locations|

	If you want use vim's quickfix list instead, add
	`"coc.preferences.useQuickfixForLocations": true` in your
	configuration file, this configuration would be ignored and no autocmd
	triggered.

	Default: 1

g:coc_snippet_next					*g:coc_snippet_next*

	Trigger key for going to the next snippet position, applied in insert
	and select mode.

	Only works when snippet session is activated.

	Default: <C-j>

g:coc_snippet_prev					*g:coc_snippet_prev*

	Trigger key for going to the previous snippet position, applied in
	insert and select mode.

	Only works when snippet session is activated.

	Default: <C-k>

g:coc_filetype_map					*g:coc_filetype_map*

	Map for document filetypes so the server could handle current document
	as another filetype, example: >

	let g:coc_filetype_map = {
		\ 'html.swig': 'html',
		\ 'wxss': 'css',
		\ }
<
	Default: {}

	See |coc-document-filetype| for details.

g:coc_selectmode_mapping				*g:coc_selectmode_mapping*

	Add key mappings for making snippet select mode easier. >

	snoremap <silent> <BS> <c-g>c
	snoremap <silent> <DEL> <c-g>c
	snoremap <silent> <c-h> <c-g>c
	snoremap <c-r> <c-g>"_c<c-r>
<
	Default: 1

g:coc_node_path						*g:coc_node_path*

	Path to node executable to start coc service, example: >

	let g:coc_node_path = '/usr/local/opt/node@12/bin/node'
<
	Use this when coc has problems with your system node,

	Note: you can use `~` as home directory.

g:coc_node_args						*g:coc_node_args*

	Arguments passed to node when starting coc service from source code.

	Useful for starting coc in debug mode, example: >
>
	let g:coc_node_args = ['--nolazy', '--inspect-brk=6045']
<
	Default: []

g:coc_status_error_sign					*g:coc_status_error_sign*

	Error character used for statusline, default: `E`

g:coc_status_warning_sign				*g:coc_status_warning_sign*

	Warning character used for statusline, default: `W`

g:coc_quickfix_open_command				*g:coc_quickfix_open_command*

	Command used for open quickfix list.  To jump fist position after
	quickfix list opend, you can use:
>
	let g:coc_quickfix_open_command = 'copen|cfirst'
<
	Default: |copen|

g:node_client_debug					*g:node_client_debug*

	Enable debug mode of node client for check rpc messages between vim
	and coc.nvim.  Use environment variable $NODE_CLIENT_LOG_FILE to set
	the log file or get the log file after coc.nvim started.
	To open the log file, use command: >

	:call coc#client#open_log()
<
	Default: `0`

g:coc_config_home					*g:coc_config_home*

	Configure the directory which will be used to look for
	user's `coc-settings.json`, default:

	Windows: `~/AppData/Local/nvim`
	Other: `~/.config/nvim`

g:coc_data_home						*g:coc_data_home*

	Configure the directory which will be used to for data
	files(extensions, MRU and so on), default:

	Windows: `~/AppData/Local/coc`
	Other: `~/.config/coc`

g:coc_terminal_height					*g:coc_terminal_height*

	Height of terminal window, default `8`.

g:coc_markdown_disabled_languages  			*g:coc_markdown_disabled_languages*

	Filetype list that should be disabled for highlight in markdown block,
	Example: >

	let g:coc_markdown_disabled_languages = ['html']

g:coc_highlight_maximum_count 				*g:coc_highlight_maximum_count*

	When highlight items exceed maximum count, highlight items will be
	grouped and added by using |timer_start| for better user experience.

	Default `100`

g:coc_default_semantic_highlight_groups 		*g:coc_default_semantic_highlight_groups*

	Create default semantic highlight groups for |coc-semantic-highlights|

	Default: `1`

g:coc_max_treeview_width 				*g:coc_max_treeview_width*

	Maximum width of tree view when adjusted by auto width.

	Default: `40`

g:coc_borderchars 					*g:coc_borderchars*

	Border characters used by border window, default to:
>
	['', '', '', '', '', '', '', '']
<
	Note: you may need special font like Nerd font to show them.

g:coc_border_joinchars 					*g:coc_border_joinchars*

	Border join characters used by float window/popup, default to:
>
	['', '', '', '']
<
	Note: you may need special font like Nerd font to show them.

g:coc_prompt_win_width 					*g:coc_prompt_win_width*

	Width of input prompt window, default `32`.

							*g:coc_notify*
g:coc_notify_error_icon 				*g:coc_notify_error_icon*

	Error icon for notification, default to: 

g:coc_notify_warning_icon 				*g:coc_notify_warning_icon*

	Warning icon for notification, default to: 

g:coc_notify_info_icon 					*g:coc_notify_info_icon*

	Info icon for notification, default to: 

------------------------------------------------------------------------------

Some variables are provided by coc.nvim.


g:WorkspaceFolders					*g:WorkspaceFolders*

	Current workspace folders, used for restoring from a session file, add
	`set sessionoptions+=globals` to vimrc for restoring globals on
	session load.

g:coc_jump_locations					*g:coc_jump_locations*

	This variable would be set to jump locations when the
	|CocLocationsChange| autocmd is fired.

	Each location item contains:

	'filename': full file path.
	'lnum': line number (1 based).
	'col': column number(1 based).
	'text':  line content of location.

g:coc_process_pid					*g:coc_process_pid*

	Process pid of coc.nvim service. If your vim doesn't kill coc.nvim
	process on exit, use:
>
	autocmd VimLeavePre * if get(g:, 'coc_process_pid', 0)
		\	| call system('kill -9 '.g:coc_process_pid) | endif
<
	in your vimrc.

g:coc_service_initialized	 			*g:coc_service_initialized*

	Is `1` when coc.nvim initialized, used with autocmd |CocNvimInit|.

g:coc_status						*g:coc_status*

	Status string contributed by coc.nvim and extensions, used for status
	line.

g:coc_last_float_win					*g:coc_last_float_win*

	Window id of latest created float/popup window.

g:coc_last_hover_message				*g:coc_last_hover_message*

	Last message echoed from `doHover`, can be used in statusline.

	Note: not used when floating or preview window used for `doHover`.

b:coc_snippet_active					*b:coc_snippet_active*

	Is `1` when snippet session is activated, use |coc#jumpable| to check
	if it's possible to jump placeholder.

b:coc_diagnostic_info					*b:coc_diagnostic_info*

	Diagnostic information of current buffer, the format would look like:

	`{'error': 0, 'warning': 0, 'information': 0, 'hint':0}`

	can be used to customize statusline. See |coc-status|.

b:coc_current_function					*b:coc_current_function*

	Function string that current cursor in.

	Set `"coc.preferences.currentFunctionSymbolAutoUpdate": true`
	in coc-settings.json to update it on CursorHold.

b:coc_cursors_activated					*b:coc_cursors_activated*

	Use expression `get(b:, 'coc_cursors_activated',0)` to check if
	cursors session is activated for current buffer.

------------------------------------------------------------------------------
FUNCTIONS						*coc-functions*

Some functions only work after the coc.nvim has been initialized.

To run a function on startup, use an autocmd like: >

	autocmd User CocNvimInit call CocAction('runCommand',
						\ 'tsserver.watchBuild')
<
coc#start([{option}]) 					*coc#start()*

	Start completion with optional {option}.  Option could contains:

		- `source` specific completion source name.

	Example:  >

	inoremap <silent> <C-w> <C-R>=coc#start({'source': 'word'})<CR>
<
	Use `:CocList sources` to get available sources.

coc#refresh()						*coc#refresh()*

	Start or refresh completion at current cursor position, bind this to
	'imap' to trigger completion, example: >

	if has('nvim')
	  inoremap <silent><expr> <c-space> coc#refresh()
	else
	  inoremap <silent><expr> <c-@> coc#refresh()
	endif

coc#_select_confirm()					*coc#_select_confirm()*

	Select first completion item if no completion item is selected, then
	confirm the completion.

coc#config({section}, {value})				*coc#config()*

	Change user configuration, overwrite configurations from
	user config file and default values. Example: >

	call coc#config('coc.preferences', {
		\ 'willSaveHandlerTimeout': 1000,
		\})
	call coc#config('languageserver', {
		\ 'ccls': {
		\   "command": "ccls",
		\   "trace.server": "verbose",
		\   "filetypes": ["c", "cpp", "objc", "objcpp"]
		\ }
		\})
<

	Note: this function can be called multiple times.
	Note: this function can be called before coc.nvim started.
	Note: this function can work alongside the user configuration file,
	but it's not recommended to use both.

coc#add_extension({name}, ...)				*coc#add_extension()*

	Deprecated function for install extensions not exists.
	Use |g:coc_global_extensions| variable instead.

	Example: >

	call coc#add_extension('coc-json', 'coc-tsserver', 'coc-rls')
<
	This function can be called before service initialized.
	This function can be called multiple times.

coc#add_command({id}, {command}, [{title}])		*coc#add_command()*

	Add custom Vim command to commands list opened by
	`:CocList commands` .

	Example: >

	call coc#add_command('mundoToggle', 'MundoToggle',
		\ 'toggle mundo window')
<
coc#expandable()					*coc#expandable()*

	Check if a snippet is expandable at the current position.
	Requires `coc-snippets` extension installed.

coc#jumpable()						*coc#jumpable()*

	Check if a snippet is jumpable at the current position.

coc#expandableOrJumpable()				*coc#expandableOrJumpable()*

	Check if a snippet is expandable or jumpable at the current position.
	Requires `coc-snippets` extension installed.

coc#on_enter()						*coc#on_enter()*

	Notify coc.nvim that <CR> has been pressed.

	Used for the format on type and improvement of brackets, example: >

	" Confirm the completion when popupmenu is visible, insert <CR> and
	" notify coc.nvim otherwise.
	inoremap <silent><expr> <CR> coc#pum#visible() ? coc#pum#confirm()
                    	          \: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"
<
	Noteto enable format on type, add ` "coc.preferences.formatOnType": true`
	in your settings file.

coc#status()						*coc#status()*

	Return a status string that can be used in the status line, the status
	includes diagnostic information from `b:coc_diagnostic_info` and
	extension contributed statuses from `g:coc_status`. For statusline
	integration, see |coc-status|

coc#util#api_version() 					*coc#util#api_version()*

	Get coc.nvim's vim API version number, start from `1`.

coc#util#job_command()					*coc#util#job_command()*

	Get the job command used for starting the coc service.

coc#util#get_config_home()				*coc#util#get_config_home()*

	Get the config directory that contains the user's coc-settings.json.

coc#util#get_data_home()				*coc#util#get_data_home()*

	Get `coc` data directory.

coc#util#extension_root()				*coc#util#extension_root()*

	Return extensions root of coc.nvim.

coc#util#rebuild()					*coc#util#rebuild()*

	Run `npm rebuild` for all coc extensions.

coc#util#root_patterns()				*coc#util#root_patterns()*

	Get root patterns used for current document.

	Result could be something like: >

	{'global': ['.git', '.hg', '.projections.json'], 'buffer': [], 'server': v:null}
<
coc#util#get_config({key})				*coc#util#get_config()*

	Get configuration (mostly defined in coc-settings.json)	by {key},
	example: >

	:echo coc#util#get_config('coc.preferences')

coc#snippet#next() 					*coc#snippet#next()*

	Jump to next placeholder, does nothing when |coc#jumpable| is 0.

coc#snippet#prev() 					*coc#snippet#prev()*

	Jump to previous placeholder, does nothing when |coc#jumpable| is 0.

							*coc#pum*
coc#pum#visible() 					*coc#pum#visible()*

	Check if customized popupmenu is visible.

coc#pum#next({insert}) 					*coc#pum#next()*

	Select next item of customized popupmenu, insert word when {insert} is
	truth value.

coc#pum#prev({insert}) 					*coc#pum#prev()*

	Select previous item of customized popupmenu, insert word when {insert}
	is truth value.

coc#pum#stop() 						*coc#pum#stop()*

	Close the customized popupmenu, works like <C-x><C-z> of vim.
	Return <Ignore>

coc#pum#cancel() 					*coc#pum#cancel()*

	Cancel the customized popupmenu and revert trigger input, like <C-e>
	of vim. Return empty string.

coc#pum#confirm() 					*coc#pum#confirm()*

	Confirm completion and close the customized pum, like <C-y> of vim.
	Return empty string.

coc#pum#info() 						*coc#pum#info()*

	Return information of the customized popupmenu, should only be used
	when |coc#pum#visible()| is 1.

	Result contains:
		index 		Current select item index, 0 based.
		scrollbar 	Non-zero if a scrollbar is displayed.
		row 		Screen row count, 0 based.
		col 		Screen column count, 0 based.
		width 		Width of pum, including padding and border.
		height 		Height of pum, including padding and border.
		size 		Count of displayed complete items.
		inserted 	Is |v:true| when there is item inserted.
		reversed 	Is |v:true| when pum shown above cursor and
				enable |suggest.reversePumAboveCursor|

coc#pum#select({index}, {insert}, {confirm}) 		*coc#pum#select()*

	Selects an item in the completion popupmenu.
	Return empty string.

	Parameters:~
		{index} 	Index (zero-based) of the item to select.
		{insert} 	Whether the selection should be inserted
				in the buffer.
		{confirm} 	Confirm the completion and dismiss the
				popupmenu, implies `insert`.

coc#pum#insert() 					*coc#pum#insert()*

	Insert word of current selected item and finish completion.
	Timer is used to make it works as rhs of key-mappings.

coc#pum#scroll({forward}) 				*coc#pum#scroll()*

	Scroll the popupmenu forward or backward by page.
	Timer is used to make it works as rhs of key-mappings.
	Return empty string.

	Parameters:~
		{forward} 	Scroll forward when none zero.

							*coc#notify*
coc#notify#close_all()					*coc#notify#close_all()*

	Close all notification windows.

coc#notify#do_action([{winid}]) 			*coc#notify#do_action()*

	Invoke action for all notification windows, or particular window with
	winid.

coc#notify#copy() 					*coc#notify#copy()*

	Copy all content from notifications to system clipboard.

coc#notify#show_sources() 				*coc#notify#show_sources()*

	Show source name (extension name) in notification windows.

coc#notify#keep() 					*coc#notify#keep()*

	Stop auto hide timer of notification windows.

coc#float#has_float([{all}]) 				*coc#float#has_float()*

	Check if float window/popup exists, check coc.nvim's float
	window/popup by default.

coc#float#close_all([{all}])				*coc#float#close_all()*

	Close all float windows/popups created by coc.nvim, set {all} to `1`
	for all float window/popups.

coc#float#close({winid}) 				*coc#float#close()*

	Close float window/popup with {winid}.

coc#float#has_scroll() 					*coc#float#has_scroll()*

	Return `1` when there is scrollable float window/popup created by
	coc.nvim.

	Example key-mappings:
>
	if has('nvim-0.4.0') || has('patch-8.2.0750')
	  nnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
	  nnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
	  inoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(1)\<cr>" : "\<Right>"
	  inoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(0)\<cr>" : "\<Left>"
	  vnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
	  vnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
	endif
<
coc#float#scroll({forward}, [{amount}])			*coc#float#scroll()*

	Scroll all scrollable float windows/popups, scroll backward when
	{forward} is not `1`. {amount} could be number or full page when
	omitted.  Popup menu is excluded.

	Note: this function requires nvim >= 0.4.0 or vim >= 8.2.750 to work.


CocRequest({id}, {method}, [{params}])			*CocRequest()*

	Send a request to language client of {id} with {method} and optional
	{params}. Example: >

	call CocRequest('tslint', 'textDocument/tslint/allFixes',
		\  {'textDocument': {'uri': 'file:///tmp'}})
<
	Vim error will be raised if the response contains an error.

							*CocRequestAsync()*

CocRequestAsync({id}, {method}, [{params}, [{callback}]])

	Send async request to remote language server.
	{callback} function is called with error and response.

CocNotify({id}, {method}, [{params}])			*CocNotify()*

	Send notification to remote language server, example:
>
	call CocNotify('ccls', '$ccls/reload')
<
							*CocRegistNotification()*

CocRegistNotification({id}, {method}, {callback})

	Register notification callback for specified client {id} and {method},
	example: >

	autocmd User CocNvimInit call CocRegistNotification('ccls',
		\ '$ccls/publishSemanticHighlight', function('s:Handler'))
<
	{callback} is called with single param as notification result.

	Note: when register notification with same {id} and {method}, only the
	later registered would work.

							*CocLocations()*

CocLocations({id}, {method}, [{params}, {openCommand}])

	Send location request to language client of {id} with
	{method} and optional {params}. e.g.: >

	call CocLocations('ccls', '$ccls/call',  {'callee': v:true})

	call CocLocations('ccls', '$ccls/call',  {}, 'vsplit')
<
	{openCommand}: optional command to open buffer, default to
	`coc.preferences.jumpCommand` , |:edit| by default.  When it's
	`v:false` locations list would always used.

							*CocLocationsAsync()*

CocLocationsAsync({id}, {method}, [{params}, {openCommand}])

	Same as |CocLocations()|, but send notification to server instead
	of request.


CocAction({action}, [...{args}])			*CocAction()*

	Run {action} of coc with optional extra {args}.

	Checkout |coc-actions| for available actions.

	Note: it's recommended to use |CocActionAsync()| unless you have to
	block your vim.

							*CocActionAsync()*

CocActionAsync({action}, [...{args}, [{callback}]])

	Call CocAction by send notification to server of coc.nvim.

	Optional callback is called with `error` as the first argument and
	`response` as the second argument.

	Checkout |coc-actions| for available actions.

CocHasProvider({feature})				*CocHasProvider()*

	Check if provider exists for specified feature of current buffer.
	Supported features:

	`rename` `onTypeEdit` `documentLink` `documentColor` `foldingRange`
	`format` `codeAction` `workspaceSymbols` `formatRange` `hover`
	`signature` `documentSymbol` `documentHighlight` `definition`
	`declaration` `typeDefinition` `reference` `implementation` `codeLens`
	`selectionRange`

CocTagFunc({pattern}, {flags}, {info})			*CocTagFunc()*

	Used for vim's 'tagfunc' option, to make tag search by |CTRL-]| use
	coc.nvim as provider, tag search would be performed when no result
	from coc.nvim.

	Make sure your vim support 'tagfunc' by
>
	:echo exists('&tagfunc')
<
------------------------------------------------------------------------------
							*coc-actions*
Available Actions ~

Acceptable {action} names for |CocAction()| and |CocActionAsync()|.

"ensureDocument" 					*CocAction('ensureDocument')*

	Ensure current document is attached to coc.nvim
	|coc-document-attached|, should be used when you need invoke action of
	current document on buffer create.

	Return |v:false| when document can't be attached.

"diagnosticList"					*CocAction('diagnosticList')*

	Get all diagnostic items of the current Neovim session.

"diagnosticInfo"					*CocAction('diagnosticInfo')*

	Show diagnostic message at the current position, do not truncate.

"diagnosticToggle" [{enable}]	 			*CocAction('diagnosticToggle')*

	Enable/disable diagnostics on the fly, not work when `displayByAle` is
	enabled. You can toggle by specifying {enable}. {enable} can be 0 or 1

"diagnosticToggleBuffer" [{bufnr}] [{enable}] 		*CocAction('diagnosticToggleBuffer')*

	Toggle diagnostics for specific buffer, current buffer is used when
	{bufnr} not provided. 0 for current buffer
	You can toggle by specifying {enable}. {enable} can be 0 or 1

	Note: this will only affect diagnostics shown in the UI, list of all
	diagnostics won't change.

"diagnosticPreview"					*CocAction('diagnosticPreview')*

	Show diagnostics under current cursor in preview window.

"diagnosticRefresh" [{bufnr}] 				*CocAction('diagnosticRefresh')*

	Force refresh diagnostics for special buffer with {bufnr} or all buffers
	when {bufnr} doesn't exist, returns `v:null` before diagnostics are shown.

	NOTE: Will refresh in any mode.

	Useful when `diagnostic.autoRefresh` is `false`.

"refreshSource" [{source}]				*CocAction('refreshSource')*

	refresh all sources or a source with a name of {source}.

"sourceStat"						*CocAction('sourceStat')*

	get the list of completion source stats for the current buffer.

"toggleSource" {source}					*CocAction('toggleSource')*

	enable/disable {source}.

"definitions" 						*CocAction('definitions')*

	Get definition locations of symbol under cursor.
	Return LSP `Location[]`

"declarations" 						*CocAction('declarations')*

	Get declaration location(s) of symbol under cursor.
	Return LSP `Location | Location[] | LocationLink[]`

"implementations" 					*CocAction('implementations')*

	Get implementation locations of symbol under cursor.
	Return LSP `Location[]`

"typeDefinitions" 					*CocAction('typeDefinitions')*

	Get type definition locations of symbol under cursor.
	Return LSP `Location[]`

"references" [{excludeDeclaration}] 			*CocAction('references')*

	Get references location list of symbol under cursor.

	{excludeDeclaration}: exclude declaration locations when not zero.

	Return LSP `Location[]`

"jumpDefinition" [{openCommand}]			*CocAction('jumpDefinition')*

	jump to definition locations of the current symbol.
	Return `v:false` when location not found.

	|coc-list-location| is used when more than one position is available,
	for custom location list, use variable: |g:coc_enable_locationlist|.

	To always use |coc-list-location|| for locations, use `v:false` for
	{openCommand}.

	{openCommand}: optional command to open buffer, default to
	`coc.preferences.jumpCommand` in `coc-settings.json`

"jumpDeclaration" [{openCommand}]			*CocAction('jumpDeclaration')*

	jump to declaration locations of the current symbol.
	Return `v:false` when location not found.

	same behavior as "jumpDefinition".

	When {openCommand} is `v:false`, location list would be always used.

"jumpImplementation" [{openCommand}]			*CocAction('jumpImplementation')*

	Jump to implementation locations of the current symbol.
	Return `v:false` when location not found.

	same behavior as "jumpDefinition"

"jumpTypeDefinition" [{openCommand}]			*CocAction('jumpTypeDefinition')*

	Jump to type definition locations of the current symbol.
	Return `v:false` when location not found.

	same behavior as "jumpDefinition"

"jumpReferences" [{openCommand}]			*CocAction('jumpReferences')*

	Jump to references locations of the current symbol, use
	|CocAction('jumpUsed')| to exclude declaration locations.

	Return `v:false` when location not found.

	same behavior as "jumpDefinition"

"jumpUsed" [{openCommand}] 				*CocAction('jumpUsed')*

	Jump references locations without declarations.

	same behavior as "jumpDefinition"

"getHover"						*CocAction('getHover')*

	Get documentation text array on current position, returns array of
	string.

"doHover" [{hoverTarget}]				*CocAction('doHover')*

	Show documentation of  current symbol, return `v:false` when hover not
	found.

	{hoverTarget}: optional specification for where to show hover info,
	defaults to `coc.preferences.hoverTarget` in `coc-settings.json`.
	Valid options: ["preview", "echo", "float"]

"definitionHover" [{hoverTarget}]			*CocAction('definitionHover')*

	Same as |CocAction('doHover')|, but includes definition contents from
	definition provider when possible.

"showSignatureHelp"					*CocAction('showSignatureHelp')*

	Echo signature help of current function, return `v:false` when
	signature not found.  You may want to set up an autocmd like this: >

	autocmd User CocJumpPlaceholder call
				\ CocActionAsync('showSignatureHelp')
<
"getCurrentFunctionSymbol"				*CocAction('getCurrentFunctionSymbol')*

	Return the function string that current cursor in.

"documentSymbols" [{bufnr}]				*CocAction('documentSymbols')*

	Get a list of symbols of current buffer or specific {bufnr}.

"rename"						*CocAction('rename')*

	Rename the symbol under the cursor position, |coc-dialog-input| would
	be shown for prompt a new name.

	Show error message when the provider not found or prepare rename
	failed.

	The buffers are not saved after apply workspace edits, use |:wa| to
	save all buffers.  It's possible to undo/redo and inspect the changes,
	see |coc-workspace-edits|.

	Note: coc.nvim supports rename for disk files, but your language server
	may not.

"refactor"						*CocAction('refactor')*

	Open refactor windows with current symbol as activated cursor ranges.
	Check |coc-config-cursors| and |coc-config-refactor| for related
	configuration.

	Use <CR> to open buffer at current position in split window.
	Use <Tab> to show action menu which have tab open and remove actions.

"format"						*CocAction('format')*

	Format current buffer using the language server.
	Return `v:false` when format failed.

"formatSelected" [{mode}]				*CocAction('formatSelected')*

	Format the selected range, {mode} should be one of visual mode: `v` ,
	`V`, `char`, `line`.

	When {mode} is omitted, it should be called using |formatexpr|.


"selectionRanges"					*CocAction('selectionRanges')*

	Get selection ranges of current position from language server.

"services"						*CocAction('services')*

	Get an information list for all services.

"toggleService" {serviceId}				*CocAction('toggleService')*

	Start or stop a service.

"codeAction" [{mode}] [{only}]				*CocAction('codeAction')*

	Prompt for a code action and do it.

	{mode} could be `currline` or `cursor` or result of |visualmode()|,
	current buffer range is used when it's empty string.

	{only} can be title of a codeAction or list of CodeActionKind.

"codeActionRange" {start} {end} [{kind}]		*CocAction('codeActionRange')*

	Run code action for range.

	{start} 	Start line number of range.
	{end} 		End line number of range.
	{kind} 		Code action kind, see |CocAction('codeActions')| for available
			action kind.

	Can be used to create commands like: >

	command! -nargs=* -range CocAction :call CocActionAsync('codeActionRange', <line1>, <line2>, <f-args>)
	command! -nargs=* -range CocFix    :call CocActionAsync('codeActionRange', <line1>, <line2>, 'quickfix')
<
"codeLensAction"					*CocAction('codeLensAction')*

	Invoke the command for codeLens of current line (or the line that
	contains codeLens just above). Prompt would be shown when multiple
	actions are available.

"commands"						*CocAction('commands')*

	Get a list of available service commands for the current buffer.

"runCommand" [{name}] [...{args}]			*CocAction('runCommand')*

	Run a global command provided by the language server. If {name} is not
	provided, a prompt with a list of commands is shown to be selected.

	{args} are passed as arguments of command.

	You can bind your custom command like so: >

	command! -nargs=0 OrganizeImport
		\ :call CocActionAsync('runCommand', 'tsserver.organizeImports')
<
"fold" {{kind}}						*CocAction('fold')*

	Fold the current buffer, optionally use {kind} for specific
	FoldingRangeKind.
	{kind} could be 'comment', 'imports' or 'region'.

	Return `v:false` when failed.

	You can create a custom command like: >

	command! -nargs=? Fold 		:call CocAction('fold', <f-args>)
<
"highlight"						*CocAction('highlight')*

	Highlight the symbols under the cursor.

"openLink" [{command}]					*CocAction('openLink')*

	Open a link under the cursor with {command}.
	{command} default to `edit`.

	File and URL links are supported, return `v:false` when failed.

	URI under cursor is searched when no link returned from documentLink
	provider.

"links" 						*CocAction('links')*

	Return document link list of current buffer.

"extensionStats"					*CocAction('extensionStats')*

	Get all extension states as a list. Including `id`, `root` and
	`state`.

	State could be `disabled`, `activated` and `loaded`.

"toggleExtension" {id}					*CocAction('toggleExtension')*

	Enable/disable an extension.

"uninstallExtension" {id}				*CocAction('uninstallExtension')*

	Uninstall an extension.

"reloadExtension" {id}					*CocAction('reloadExtension')*

	Reload an activated extension.

"activeExtension" {id}					*CocAction('activeExtension')*

	Activate extension of {id}.

"deactivateExtension" {id}				*CocAction('deactivateExtension')*

	Deactivate extension of {id}.

"pickColor"						*CocAction('pickColor')*

	Change the color at the current cursor position, requires
	`documentColor` provider |CocHasProvider|.

	Note: only works on mac or when you have python support on Vim and
	have the GTK module installed.

"colorPresentation"					*CocAction('colorPresentation')*

	Change the color presentation at the current color position, requires
	`documentColor` provider |CocHasProvider|.

"codeActions" [{mode}] [{only}]				*CocAction('codeActions')*

	Get codeActions list of current document.

	{mode} can be result of |visualmode()| for visual selected
	range.  When it's falsy value, current file is used as range.

	{only} can be array of codeActionKind, possible values including:
	 - 'refactor': Base kind for refactoring actions
	 - 'quickfix': base kind for quickfix actions
	 - 'refactor.extract': Base kind for refactoring extraction actions
	 - 'refactor.inline': Base kind for refactoring inline actions
	 - 'refactor.rewrite': Base kind for refactoring rewrite actions
	 - 'source': Base kind for source actions
	 - 'source.organizeImports': Base kind for an organize imports source
	   action
	 - 'source.fixAll': Base kind for auto-fix source actions

	{only} can also be string, which means filter by title of codeAction.

"organizeImport" 					*CocAction('organizeImport')*

	Run organize import codeAction for current buffer.
	Show warning when codeAction not found.

"fixAll" 						*CocAction('fixAll')*

	Run fixAll codeAction for current buffer.
	Show warning when codeAction not found.


"quickfixes" [{visualmode}]				*CocAction('quickfixes')*

	Get quickfix codeActions of current buffer.

	Add {visualmode} as second argument get quickfix actions with range of
	latest |visualmode()|

"doCodeAction" {codeAction}				*CocAction('doCodeAction')*

	Do a codeAction.

"doQuickfix"						*CocAction('doQuickfix')*

	Do the first preferred quickfix action on current line.

	Throw error when no quickfix action found.

"addRanges" {ranges}					*CocAction('addRanges')*

	Ranges must be provided as array of range type: https://git.io/fjiEG

"getWordEdit"						*CocAction('getWordEdit')*

	Get workspaceEdit of current word, language server used when possible,
	extract word from current buffer as fallback.

"getWorkspaceSymbols" {input}				*CocAction('getWorkspaceSymbols')*

	Get workspace symbols from {input}.

"resolveWorkspaceSymbol" {symbol} 			*CocAction('resolveWorkspaceSymbol')*

	Resolve location for workspace {symbol}.

"showOutline" [{keep}]					*CocAction('showOutline')*

	Show |coc-outline| for current buffer. Does nothing when outline
	window already shown for current buffer.

	{keep} override `"outline.keepWindow"` configuration when specified.
	Could be 0 or 1.

	Returns after window is shown (document symbol request is still in
	progress).

"hideOutline" 						*CocAction('hideOutline')*

	Close |coc-outline| on current tab.  Throws vim error when it can't
	be closed by vim.

"incomingCalls" [{CallHierarchyItem}] 			*CocAction('incomingCalls')*

	Retrieve incoming calls from {CallHierarchyItem} or current position
	when not provided.

"outgoingCalls" [{CallHierarchyItem}] 			*CocAction('outgoingCalls')*

	Retrieve outgoing calls from {CallHierarchyItem} or current position
	when not provided.

"showIncomingCalls"  					*CocAction('showIncomingCalls')*

	Show incoming calls of current function with |coc-tree|, see
	|coc-callHierarchy|

"showOutgoingCalls"  					*CocAction('showOutgoingCalls')*

	Show outgoing calls of current function with |coc-tree|.

"semanticHighlight" 					*CocAction('semanticHighlight')*

	Request semantic tokens highlight for current buffer.

"inspectSemanticToken" 					*CocAction('inspectSemanticToken')*

	Inspect semantic token information at cursor position.

"rangeSelect" {visualmode} {forward} 		 	*CocAction('rangeSelect')*

	Visual select previous or next selection range, requires
	`selectionRange` provider.

	{visualmode} should be result of {visualmode} or "" for current cursor
	position.
	{forward} select backward when it's falsy value.

------------------------------------------------------------------------------
COMMANDS						*coc-commands*

:CocStart						*:CocStart*

	Start the coc.nvim server, do nothing if it's already started.

:CocRestart						*:CocRestart*

	Restart coc.nvim service.

	Use this command when you want coc to start all over again.

:CocDisable						*:CocDisable*

	Disable handling vim events.

:CocEnable						*:CocEnable*

	Enable handling vim events.

:CocConfig						*:CocConfig*

	Edit the user config file `.vim/coc-settings.json` in
	|coc#util#get_config_home()|

:CocLocalConfig						*:CocLocalConfig*

	Edit or create `.vim/coc-settings.json` in current workspace folder.

:CocInstall [{option}] {name} ...			*:CocInstall*

	Install one or more coc extensions.

	{option}: could be `-sync` for use blocked process to download instead
	of terminal.

	Examples: >

	" Install latest coc-omni
	:CocInstall coc-omni
	" Install coc-omni 1.0.0
	:CocInstall coc-omni@1.0.0
	" Install snippet extension from github
	:CocInstall https://github.com/dsznajder/vscode-es7-javascript-react-snippets
>
:CocUninstall {name}					*:CocUninstall*

	Uninstall an extension, use <tab> to complete the extension
	name.

:CocUpdate						*:CocUpdate*

	Update all coc extensions to the latest version.

:CocUpdateSync						*:CocUpdateSync*

	Block version of update coc extensions.

:CocRebuild						*:CocRebuild*

	Run `npm rebuild` for coc extensions.

	May be required when environment nodejs get upgraded.

:CocCommand {name} [{args}] ... 			*:CocCommand*

	Run a command contributed by extensions, use `<tab>` for name
	completion.

:CocOpenLog						*:CocOpenLog*

	Open log file of coc.nvim.

	Use environmental variable `NVIM_COC_LOG_FILE` for fixed log file.
	Note: the log would be cleared when coc.nvim started.

	Use environment variable `NVIM_COC_LOG_LEVEL` to change log level
	(default 'info', could be 'all', 'trace', 'debug', 'info',
	'warn', 'error', 'off').
	Use shell command: >

	export NVIM_COC_LOG_LEVEL=debug
<
	or add: >

	let $NVIM_COC_LOG_LEVEL='debug'
<
	to the beginning of your `.vimrc`

:CocInfo						*:CocInfo*

	Show version and log information in a split window, useful for
	submitting a bug report.

:CocDiagnostics	[height] 				*:CocDiagnostics*

	Open vim's |location-list| with diagnostics of current buffer.

:CocSearch 						*:CocSearch*

	Perform search by ripgrep https://github.com/BurntSushi/ripgrep,
	refactor window would be opened.

	Note: the search is performed on your files, so normally you should
	save your buffers before invoke this command.

	Common arguments for ripgrep:~

	`-e` `--regexp`: treat search pattern as regexp.
	`-F` `--fixed-strings`: treat search pattern as fixed string.
	`-L` `--follow`: follow symbolic links while traversing directories.
	`-g` `--glob` {GLOB}: Include or exclude files and directories for
	searching that match the given glob.
	`--hidden`: Search hidden files and directories.
	`--no-ignore-vcs`:  Don't respect version control ignore files
	(.gitignore, etc.).
	`--no-ignore`: Don't respect ignore files (.gitignore, .ignore, etc.).
	`-w` `--word-regexp`: Only show matches surrounded by word boundaries.
	`-S` `--smart-case`: Searches case insensitively if the pattern is all
	lowercase. Search case sensitively otherwise.
	`--no-config`: Never read configuration files.
	`-x` `--line-regexp`: Only show matches surrounded by line boundaries.

	Use `:man 1 rg` in your terminal for more details.

	Note: By default, hidden files and directories are skipped.

	Note: By default, vcs ignore files including `.gitignore` and
	`.ignore` are respected

	Escape arguments:~

	|<f-args>| is used to convert command line arguments to arguments of
	rg, which means you have to escape space for single argument. For
	example, if you want to search `import { Neovim` , you have to use:
>
	:CocSearch import\ \{\ Neovim
<
	The escape for `{` is required because rg use regexp be default, or:
>
	:CocSearch -F import\ {\ Neovim
<
	for strict match.

	Change and save:~

	Refactor session is started with searched patterns highlighted, just
	change the text and save refactor buffer to make changes across all
	related files. You can make any kind of changes, including add lines
	and remove lines.

:CocWatch [extension] 					*:CocWatch*

	Watch loaded [extension] for reload on file change, use <tab> for
	complete extension id.

:CocOutline 						*:CocOutline*

	Invoke |CocAction('showOutline')| by notification.

------------------------------------------------------------------------------
AUTOCMD							*coc-autocmds*

							*CocLocationsChange*

:autocmd User CocLocationsChange {command}

	For building a custom view of locations, set
	|g:coc_enable_locationlist| to 0 and use this autocmd with with
	|g:coc_jump_locations|

	For example, to disable auto preview of location list, use:
>
	let g:coc_enable_locationlist = 0
	autocmd User CocLocationsChange CocList --normal location
<
							*CocNvimInit*
:autocmd User CocNvimInit {command}

	Triggered after the coc services have started.

	If you want to trigger an action of coc after Vim has started, this
	autocmd should be used because coc is always started asynchronously.

							*CocStatusChange*

:autocmd User CocStatusChange {command}

	Triggered after `g:coc_status` changed, can be used for refresh
	statusline.

							*CocDiagnosticChange*

:autocmd User CocDiagnosticChange {command}

	Triggered after the diagnostic status has changed.

	Could be used for updating the statusline.

							*CocJumpPlaceholder*

:autocmd User CocJumpPlaceholder {command}

	Triggered after a jump to a placeholder. Can be used for
	showing signature help like: >

	autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
<
							*CocOpenFloat*

:autocmd User CocOpenFloat {command}

	Triggered when a floating window is opened.  The window is not
	focused, use |g:coc_last_float_win| to get window id.

							*CocOpenFloatPrompt*

:autocmd User CocOpenFloatPrompt {command}

	Triggered when a floating prompt window is opened (triggered after
	CocOpenFloat).

							*CocTerminalOpen*
:autocmd User CocTerminalOpen {command}

	Triggered when the terminal is shown, can be used for adjusting the
	window height.

------------------------------------------------------------------------------

HIGHLIGHTS						*coc-highlights*

To customize a highlight, simply use |:highlight| command in your vimrc, like:
>
	" make error texts have a red color
	highlight CocErrorHighlight ctermfg=Red  guifg=#ff0000
<
Type |:highlight| command with group name to check current highlight.

Note: don't use `:hi default` for overwriting the highlights.

Note: user defined highlight commands should appear after the |:colorscheme|
command and use |ColorScheme| autocmd to make sure customized highlights works
after color scheme change.

Markdown related~

*CocBold* for bold text.
*CocItalic* for italic text.
*CocUnderline* for underlined text.
*CocStrikeThrough* for strikethrough text, like usage of deprecated API.
*CocMarkdownCode* for inline code in markdown content.
*CocMarkdownHeader* for markdown header in floating window/popup.
*CocMarkdownLink* for markdown link text in floating window/popup.

Diagnostics related~
							*coc-highlights-diagnostics*

*CocFadeOut* for faded out text, such as for highlighting unnecessary code.
*CocErrorSign* for error signs.
*CocWarningSign* for warning signs.
*CocInfoSign* for information signs.
*CocHintSign* for hint signs.
*CocErrorVirtualText* for error virtual text.
*CocWarningVirtualText* for warning virtual text.
*CocInfoVirtualText* for information virtual text.
*CocHintVirtualText* for hint virtual text.
*CocErrorHighlight* for error code range.
*CocWarningHighlight* for warning code range.
*CocInfoHighlight* for information code range.
*CocHintHighlight* for hint code range.
*CocDeprecatedHighlight* for deprecated code range, links to
|CocStrikeThrough| by default.
*CocUnusedHighlight* for unnecessary code range, links to |CocFadeOut| by
default.
*CocErrorLine* line highlight of sign which contains error.
*CocWarningLine* line highlight of sign which contains warning.
*CocInfoLine* line highlight of sign which information.
*CocHintLine* line highlight of sign which contains hint.

Highlight with higher priority would overwrite highlight with lower priority.
The priority order:

	|CocUnusedHighlight| > |CocDeprecatedHighlight| > |CocErrorHighlight|
	> |CocWarningHighlight| > |CocInfoHighlight| > |CocHintHighlight|

Document highlight related~
							*coc-highlights-document*

Highlights used for highlighting same symbols in the buffer at the current
cursor position.

*CocHighlightText* default symbol highlight.
*CocHighlightRead* for `Read` kind of document symbol.
*CocHighlightWrite* for `Write` kind of document symbol.

Float window/popup related~

*CocFloating* default highlight group of floating windows/popups.
Default links to |NormalFloat| on neovim and |Pmenu| on vim.
*CocFloatThumb* thumb highlight of scrollbar.
*CocFloatSbar* Scrollbar highlight of floating window/popups.
*CocFloatDividingLine* for dividing lines, links to |NonText| by default.
*CocErrorFloat* for error text in floating windows/popups.
*CocHintFloat* for hint text in floating windows/popups.

Notification window/popup related~

CocNotification 					*CocNotification*

*CocNotificationProgress* for progress line in progress notification.
*CocNotificationButton* for action buttons in notification window.
*CocNotificationError* for highlight border of error notification.
*CocNotificationWarning* for highlight border of warning notification.
*CocNotificationInfo* for highlight border of info notification.

List related~
							*coc-highlights-list*

*CocListLine* for current cursor line.
*CocListSearch* for matched characters.
*CocListMode* for mode text in the statusline.
*CocListPath* for cwd text in the statusline.
*CocSelectedText* for sign text of selected lines (multiple selection only).
*CocSelectedLine* for line highlight of selected lines (multiple selection only).

Tree view related~

CocTree 						*CocTree*

*CocTreeTitle* for title in tree view.
*CocTreeDescription* for description beside label.
*CocTreeOpenClose* for open and close icon in tree view.
*CocTreeSelected* for highlight lines contains selected node.

Popup menu related~
							*CocPum*
*CocPumSearch* for matched input characters, linked to |CocSearch| by default.
*CocPumDetail* for highlight label details that follows label (including
possible detail and description).
*CocPumMenu* for menu of complete item.
*CocPumShortcut* for shortcut text of source.
*CocPumDeprecated* for deprecated label.
*CocPumVirtualText* for virtual text which enabled by
|coc-config-suggest-virtualText|

Symbol icons~

CocSymbol 						*CocSymbol*

Highlight groups for symbol icons, including `CompletionItemKind` and
`SymbolKind` of LSP.  The highlight groups link to related |nvim-treesitter|
highlight groups when possible and fallback to builtin highlight groups.

*CocSymbolDefault* linked to |hl-MoreMsg| by default.
*CocSymbolText*
*CocSymbolUnit*
*CocSymbolValue*
*CocSymbolKeyword*
*CocSymbolSnippet*
*CocSymbolColor*
*CocSymbolReference*
*CocSymbolFolder*
*CocSymbolFile*
*CocSymbolModule*
*CocSymbolNamespace*
*CocSymbolPackage*
*CocSymbolClass*
*CocSymbolMethod*
*CocSymbolProperty*
*CocSymbolField*
*CocSymbolConstructor*
*CocSymbolEnum*
*CocSymbolInterface*
*CocSymbolFunction*
*CocSymbolVariable*
*CocSymbolConstant*
*CocSymbolString*
*CocSymbolNumber*
*CocSymbolBoolean*
*CocSymbolArray*
*CocSymbolObject*
*CocSymbolKey*
*CocSymbolNull*
*CocSymbolEnumMember*
*CocSymbolStruct*
*CocSymbolEvent*
*CocSymbolOperator*
*CocSymbolTypeParameter*

Note: Use configuration |coc-config-suggest-completionItemKindLabels| for customized icon
characters.

Semantic token highlight groups~
								*CocSem*

Semantic highlight groups are starts with `CocSem` which link to related
|nvim-treesitter| highlight groups when possible and fallback to builtin
highlight groups, use variable |g:coc_default_semantic_highlight_groups| to
disable creation of these highlight groups.

Only semantic tokens types and `deprecated` modifier have default
highlight groups.

You need create highlight groups for highlight other modifiers and/or specific
modifier with type, for example:
>
	" Add highlights for defaultLibrary modifier
	hi link CocSemDefaultLibrary TSOtherDefaultLibrary
	hi link CocSemDefaultLibraryClass TSTypeDefaultLibrary
	hi link CocSemDefaultLibraryInterface TSTypeDefaultLibrary
	hi link CocSemDefaultLibraryEnum TSTypeDefaultLibrary
	hi link CocSemDefaultLibraryType TSTypeDefaultLibrary
	hi link CocSemDefaultLibraryNamespace TSTypeDefaultLibrary

	" Add highlights for declaration modifier
	hi link CocSemDeclaration TSOtherDeclaration
	hi link CocSemDeclarationClass TSTypeDeclaration
	hi link CocSemDeclarationInterface TSTypeDeclaration
	hi link CocSemDeclarationEnum TSTypeDeclaration
	hi link CocSemDeclarationType TSTypeDeclaration
	hi link CocSemDeclarationNamespace TSTypeDeclaration
<
The modifier highlight groups have higher priority.

Others~

*CocSearch* highlight group for matched characters in list.
*CocDisabled* highlight for disabled items, eg: menu item.
*CocCodeLens* for virtual text of codeLens.
*CocCursorRange* for highlight of activated cursors ranges.
*CocLinkedEditing* for highlight of activated linked editing ranges.
*CocHoverRange* for range of current hovered symbol.
*CocMenuSel* for current menu item in menu dialog (should only provide
background color).
*CocSelectedRange* for highlight ranges of outgoing calls.
*CocSnippetVisual* for highlight snippet placeholders.
*CocInlayHint* for highlight inlay hint virtual text block, default uses
foreground from |CocHintSign| and background from |SignColumn|

==============================================================================
TREE SUPPORT 						*coc-tree*

Tree view is used for render outline and call hierarchy, following features
are supported:

- Data update while keep tree node open/close state.
- Auto refresh on load error.
- Click open/close icon to toggle collapse state.
- Click node to invoke default command.
- Show tooltip in float window on |CursorHold| when possible.
- Key-mappings support |coc-tree-mappings|
- Optional multiple selection.
- Optional node reveal support.
- Optional fuzzy filter support.
- Provide API `window.createTreeView` for extensions.

Check |coc-config-tree| for related configurations.

The filetype is `'coctree'`, which can be used to overwrite buffer and window
options.

Use variable |w:cocViewId| to detect the kind of tree.

------------------------------------------------------------------------------

TREE KEY MAPPINGS 					*coc-tree-mappings*

Default key-mappings are provided for 'coctree' buffer, which can be changed
by configuration |coc-config-tree|.

<space> - Select/unselect item, configured by `"tree.key.toggleSelection"`.
<tab> 	- Invoke actions of current item, configured by `"tree.key.actions"`.
<esc>   - Close tree window, configured by `"tree.key.close"`.
<cr>    - Invoke command of current item,  configured by `"tree.key.invoke"`.
<C-o>   - Move cursor to original window.
f 	- Activate filter, configured by `"tree.key.activeFilter"`.
t 	- Trigger key to toggle expand state of tree node, configured by
	`tree.key.toggle`.
M 	- Collapse all tree node, configured by `"tree.key.collapseAll"`.

------------------------------------------------------------------------------

TREE FILTER 						*coc-tree-filter*

Filter mode is used for search for specific node by fuzzy filter, invoke the
key configured by `"tree.key.activeFilter"` to activate filter mode.

Note: some tree views not have filter mode supported.

When filter mode is activated, type normal character to insert filter input
and following special keys are supported:

<bs> 	- Delete last filter character when possible.
<C-h> 	- Delete last filter character when possible.
<C-u> 	- Clean up filter text.
<C-p> 	- Navigate to previous filter text (stored on command invoke).
<C-n> 	- Navigate to next filter text (stored on command invoke).
<esc> 	- exit filter mode.
<C-o> 	- exit filter mode.
<up> or `"tree.key.selectPrevious"` 	- Select previous node.
<down> or `"tree.key.selectNext"` 	- Select next node.
<cr> or `"key.key.invoke"` 	- Invoke command of selected node.

==============================================================================
LIST SUPPORT						*coc-list*

Built-in list support to make working with lists of items easier.

The following features are supported:

- Insert & normal mode.
- Default key-mappings for insert & normal mode.
- Customize key-mappings for insert & normal mode.
- Commands for reopening & doing actions with a previous list.
- Different match modes.
- Interactive mode.
- Auto preview on cursor move.
- Number select support.
- Built-in actions for locations.
- Parse ANSI code.
- Mouse support.
- Select actions using <tab>.
- Multiple selections using <space> in normal mode.
- Select lines by visual selection.

------------------------------------------------------------------------------

LIST COMMAND						*coc-list-command*

:CocList [{...options}] [{source}] [{...args}]		*:CocList*

	Open coc list of {source}, example: >

	:CocList --normal location
<
	For current jump locations.

	See |coc-list-options| for available list options,

	Also check |coc-config-list| for list configuration.

	{args} are sent to source during the fetching of list.
	Press `?` on normal mode to get supported {args} of current
	list.

	When {source} is empty, lists source is used.

:CocListResume [{name}]					*:CocListResume*

	Reopen last opened list, input and cursor position will be preserved.

:CocListCancel						*:CocListCancel*

	Close list, useful when the list is not the current window.

:CocPrev [{name}]					*:CocPrev*

	Invoke default action for the previous item in the last {name} list.

	Doesn't open the list window if it's closed.

:CocNext [{name}]					*:CocNext*

	Invoke the default action for the next item in the last {name} list.

	Doesn't open the list window if it's closed.

:CocFirst [{name}]					*:CocFirst*

	Invoke default action for first item in the last {name} list.

:CocLast [{name}]					*:CocLast*

	Invoke default action for last item in the last {name} list.

							*coc-list-options*
Options of CocList command~

--top
	Show list as top window.

--tab
	Open list in new tabpage.

--normal

	Start list in normal mode, recommended for short list.

--no-sort
	Disable sort made by fuzzy score or most recently used, use it when
	it's already sorted.

--input={input}

	Specify the input on session start.

--strict
-S
	Use strict matching instead of fuzzy matching.

--regex
-R
	Use regex matching instead of fuzzy matching.

--ignore-case

	Ignore case when using strict matching or regex matching.

--number-select
-N
	Type a line number to select an item and invoke the default action on
	insert mode. Type `0` to select the 10th line.


--interactive
-I
	Use interactive mode, list items would be reloaded on input
	change, filter and sort would be done by list implementation.

	Note: only works when the list support interactive mode.

	Note: filtering and sorting would be done by underlying task, which
	means options including `--strict`, `--no-sort`, `--regex`,
	`--ignore-case` would not work at all.

--auto-preview
-A

	Start a preview for the current item on the visible list.

--no-quit

	Not quit list session after do action.

	Note: you may need to refresh the list for current state.

--first

	Invoke default action for first list item on list open.
	Nothing happens when the list is empty.

--reverse

	Reverse lines order of list.

------------------------------------------------------------------------------

LIST CONFIGURATION					*coc-list-configuration*

Use `coc-settings.json` for configuration of lists.

Configuration of list starts with 'list.'.

See |coc-config-list| or type `list.` in your settings file to get completion
list (requires coc-json installed).

For configuration of a specified list, use section that starts with:
`list.source.{name}`, where `{name}` is the name of list.

Change default action:~

If you want to use `tabe` as default action of symbols list, you can use:
>
	// change default action of symbols
	"list.source.symbols.defaultAction": "tabe"
<
in your coc-settings.json

Change default options:~

Use `list.source.{name}.defaultOptions` setting like: >

	// make symbols list use normal mode and interactive by default
	"list.source.symbols.defaultOptions": ["--interactive", "--number-select"],
<
Note: some list like symbols only work in interactive mode, you must
include `--interactive` in `defaultOptions`.

Note: default options will not be used when there're options passed
with |:CocList| command.

Change default arguments:~

Use `list.source.{name}.defaultArgs` setting like: >

	// use regex match for grep source
	"list.source.grep.defaultArgs": ["-regex"],

Note: default arguments used only when arguments from |:CocList| command is
empty.

Note: Type `?` on normal mode to get supported arguments of current list.

------------------------------------------------------------------------------

LIST MAPPINGS						*coc-list-mappings*

Default mappings on insert mode:

<Esc>       - Cancel list session.
<CR>        - Do default action with selected items or current item.
<C-c>       - Stop loading task.
<C-v>       - Paste text from system clipboard.
<C-l>       - Reload list.
<C-o>       - Change to normal mode.
<Down>      - Select next line.
<Up>        - Select previous line.
<Left>      - Move cursor left.
<Right>     - Move cursor right.
<End>       - Move cursor to end of prompt.
<C-e>       - Same as <End>.
<Home>      - Move cursor to start of prompt.
<C-a>       - Same as <Home>.
<C-f>       - Scroll window forward.
<C-b>       - Scroll window backward.
<Backspace> - Remove previous character of cursor.
<C-h>       - Remove previous character of cursor.
<C-w>       - Remove previous word of cursor.
<C-u>       - Remove characters before cursor.
<C-n>       - Navigate to next input in history.
<C-p>       - Navigate to previous input in history.
<C-s>       - Switch matcher for filter items.
<C-r>       - Insert content from vim's register.
<Tab>       - Select action.

Default mappings on normal mode:

<Esc>       - Cancel list session.
<CR>        - Do default action with selected items or current item.
<C-c>       - Stop source from fetching more items.
<C-l>       - Reload list.
<C-a>       - Mark all visible items selected.
<C-o>       - Jump to original window on list create.
<Tab>       - Select action.
<C-e> 	    - Scroll preview window down.
<C-y> 	    - Scroll preview window up.
<Space>     - Toggle selection of current item.
i,I,o,O,a,A - Change to insert mode.
p           - Preview action.
:           - Cancel list session without closing window.
?           - Show help of current list.
t           - Do 'tabe' action.
d           - Do 'drop' action.
s           - Do 'split' action.

Use |coc-list-mappings-custom| to override default mappings.

							*coc-list-mappings-custom*

Configurations `"list.normalMappings"` and `"list.insertMappings"` are used
for customizing the list key-mappings, example: >

	"list.insertMappings": {
		"<C-r>": "do:refresh",
		"<C-f>": "feedkeys:\\<C-f>",
		"<C-b>": "feedkeys:\\<C-b>",
		"<C-n>": "normal:j",
		"<C-p>": "normal:k",
		"<C-t>": "action:tabe",
		"<C-x>": "call:MyFunc",
		// paste yanked text to prompt
		"<C-v>": "eval:@@"
	}
	"list.normalMappings": {
		"c": "expr:MyExprFunc"
		"d": "action:delete"
	}
<
Note: you should only use mappings that start with `<C-` or `<A-` for insert
mappings.

Note: <Esc> can't be remapped for other actions.

The mapping expression should be `command:arguments`, available commands:

'do' - special actions provided by coc list, including:
	'refresh'       - reload list.
	'selectall'     - mark all visible items selected.
	'switch'        - switch matcher used for filter items.
	'exit'          - exit list session.
	'stop'          - stop loading task.
	'cancel'        - cancel list session but leave list window open.
	'toggle'        - toggle selection of current item.
	'togglemode'    - toggle between insert and normal mode.
	'previous'      - move cursor to previous item.
	'next'          - move cursor to next item.
	'defaultaction' - do default action for selected item(s).
	'chooseaction'  - choose action for selected item(s).
	'jumpback'      - stop prompt and jump back to original window.
	'previewtoggle' - toggle preview window, requires preview action exists.
	'previewup'     - scroll preview window up.
	'previewdown'   - scroll preview window down.
	'help'          - show help.
'prompt' - do prompt action, including:
	'previous' - change to previous input in history.
	'next'           - change to next input in history.
	'start'          - move cursor to start.
	'end'            - move cursor to end.
	'left'           - move cursor left.
	'right'          - move cursor right.
	'deleteforward'  - remove previous character.
	'deletebackward' - remove next character.
	'removetail'     - remove characters afterwards.
	'removeahead'    - remove character ahead.
	'removeword'     - remove word before cursor.
	'insertregister' - insert content from Vim register.
	'paste'          - append text from system clipboard to prompt.
'eval'     - append text to prompt from result of VimL expression.
'action'   - execute action of list, use <tab> to find available actions.
'feedkeys' - feedkeys to list window, use `\\` in JSON to escape special
             characters.
'normal'   - execute normal command in list window.
'normal!'  - execute normal command without remap.
'command'  - execute command.
'call'     - call Vim function with |coc-list-context| as only argument.
'expr'     - same as 'call' but expect the function return action name.

							*coc-list-context*

Context argument contains the following properties:

'name'    - name of the list, example: `'location'`.
'args'    - arguments of the list.
'input'   - current input of prompt.
'winid'   - window id on list activated.
'bufnr'   - buffer number on list activated.
'targets' - list of selected targets, checkout |coc-list-target| for properties.

							*coc-list-target*

Target contains the following properties:

'label'      - mandatory property that is shown in the buffer.
'filtertext' - optional filter text used for filtering items.
'location'   - optional location of item, check out https://bit.ly/2Rtb6Bo
'data'       - optional additional properties.

------------------------------------------------------------------------------

LIST SOURCES						*coc-list-sources*

------------------------------------------------------------------------------

location						*coc-list-location*

	Last jump locations.

	Actions:

	- 'preview' : preview location in preview window.
	- 'open': open location by use
		`"coc.preferences.jumpCommand"`, default action
	- 'tabe': Use |:tabe| to open location.
	- 'drop': Use |:drop| to open location.
	- 'vsplit': Use |:vsplit| to open location.
	- 'split': Use |:split| to open location.
	- 'quickfix': Add selected items to Vim's quickfix.

extensions						*coc-list-extensions*

	Manage coc.nvim extensions.

	Actions:

	- 'toggle' activate/deactivate extension, default action.
	- 'disable' disable extension.
	- 'enable' enable extension.
	- 'lock' lock/unlock extension to current version.
	- 'doc' view extension's README doc.
	- 'fix' fix dependencies in terminal buffer.
	- 'reload' reload extension.
	- 'uninstall' uninstall extension.

diagnostics						*coc-list-diagnostics*

	All diagnostics for the workspace.

	Actions:

	- Same as |coc-list-location|

folders 						*coc-list-folders*

	Manage current workspace folders of coc.nvim.

	Actions:

	- 'edit' change the directory of workspace folder.
	- 'delete' remove selected workspace folder.

outline							*coc-list-outline*

	Symbols in the current document.

	Actions:

	- Same as |coc-list-location|

symbols							*coc-list-symbols*

	Search workspace symbols.

	Actions:

	- Same as |coc-list-location|

services						*coc-list-services*

	Manage registered services.

	Actions:

	- 'toggle': toggle service state, default action.

commands						*coc-list-commands*

	Workspace commands.

	Actions:

	- 'run': run selected command, default action.

links							*coc-list-links*

	Links in the current document.

	Actions:

	- 'open': open the link, default action.
	- 'jump': jump to link definition.

sources							*coc-list-completion-sources*

	Available completion sources.

	Actions:

	- 'toggle': activate/deactivate source, default action.
	- 'refresh': refresh source.
	- 'open': open the file where source defined.

lists							*coc-list-lists*

	Get available lists.

	Actions:

	- 'open': open selected list, default action.

==============================================================================

DIALOG SUPPORT						*coc-dialog*

Dialog is special float window/popup that could response to user actions,
dialog have close button, border, title (optional), bottom buttons(optional).

Note bottom buttons work different on neovim and vim, on neovim you can
click the button since neovim allows focus of window, on vim you have to type
highlighted character to trigger button callback.

Note dialog feature requires neovim >= 0.4.0 or vim >= 8.2.0750 to work.

See |coc-config-dialog| for available configurations.

------------------------------------------------------------------------------

							*coc-dialog-basic*

A basic dialog is create by Javascript API `window.showDialog` , which is just
some texts with optional buttons.

------------------------------------------------------------------------------

							*coc-dialog-confirm*

A confirm dialog is used for user to confirm an action, normally created by
`window.showPrompt()` Confirm dialog uses filter feature on vim8 and
|getchar()| on Neovim.

The difference is you can operate vim on vim8, but not on neovim.

Supported key-mappings:

<C-c>         - force cancel, return -1 for callback.
<esc>, n, N   - reject the action, return 0 for callback.
y,Y           - accept the action, return 1 for callback.

------------------------------------------------------------------------------

							*coc-dialog-input*

An input dialog request user input with optional default value, normally
created by `window.requestInput`, when `"coc.preferences.promptInput"` is
false, vim's command line input prompt is used instead.

On neovim, it uses float window, on vim8, it opens terminal in popup.

Supported key-mappings:

<C-a>               - move cursor to first col.
<C-e>               - move cursor to last col.
<esc>               - cancel input, null is received by callback.
<cr>                - accept current input selection of current item.

QuickPick related (available when created by |coc-dialog-quickpick|).

<C-f>               - scroll forward quickpick list.
<C-b>               - scroll backward quickpick list.
<C-j> <C-n> <down>  - move to next item in quickpick list.
<C-k> <C-p> <up>    - move to previous item in quickpick list.
<C-space>           - toggle selection of current item in quickpick list when
canSelectMany is supported.

Note on neovim, other insert mode key-mappings could work.

Note not possible to configure key-mappings on vim8, to customize key-mappings
on neovim, use |CocOpenFloatPrompt| with current buffer.

------------------------------------------------------------------------------

							*coc-dialog-quickpick*

A quickpick is a input dialog in the middle with a float window/popup contains
filtered list items.

A simple fuzzy filter is used by default.

See |coc-config-dialog| for available configurations.

See |coc-dialog-input| for available key-mappings.

------------------------------------------------------------------------------

							*coc-dialog-menu*

A menu dialog is used for pick a single item from list of items, extensions
could use `window.showMenuPicker` to create menu dialog.

Supported key-mappings:

<Esc> <C-c>          - cancel selection.
<cr>                 - confirm selection of current item, use
|dialog.confirmKey| to override.
1-9                  - select item with 1 based index.
g                    - move to first item.
G                    - move to last item.
j <tab> <down> <C-n> - move to next item.
k <s-tab> <up> <C-p> - move to previous item.
<C-f>                - scroll forward.
<C-b>                - scroll backward.

------------------------------------------------------------------------------

							*coc-dialog-picker*

A picker dialog is used for single/multiple selection. On neovim, it's
possible to toggle selection by mouse click inside the bracket. Extensions
could use `window.showPickerDialog` to create picker dialog.

Supported key-mappings:

<Esc> <C-c>          - cancel selection.
<cr>                 - confirm selection of current item, use
|dialog.confirmKey| to override.
<space>              - toggle selection of current item.
g                    - move to first item.
G                    - move to last item.
j <tab> <down> <C-n> - move to next item.
k <s-tab> <up> <C-p> - move to previous item.
<C-f>                - scroll forward.
<C-b>                - scroll backward.

Note when close button is clicked, the selection is canceled with undefined
result (same as <esc>).

==============================================================================

NOTIFICATION SUPPORT					*coc-notification*

Notification windows are created at the bottom right of the screen.

Notifications are created by Javascript APIs: `window.showErrorMessage()`,
`window.showWarningMessage()`, `window.showInformationMessage()`,
`window.showNotification()` and `window.withProgress()`.

Possible kind of notifications: 'error', 'warning', 'info' and 'progress'.

Message notifications (not progress) requires
|coc-preferences-enableMessageDialog| to be `true`.

Message notifications without actions would be automatically closed after
milliseconds specified by |coc-config-notification-timeout|.

Use |coc-config-notification-disabledProgressSources| to disable progress
notifications for specific sources.

Customize notifications:~

- Customize icons: |g:coc_notify|
- Customize highlights: |CocNotification|
- Customize configurations: |coc-config-notification|

Related functions:~

- |coc#notify#close_all()|
- |coc#notify#do_action()|
- |coc#notify#copy()|
- |coc#notify#show_sources()|
- |coc#notify#keep()|

==============================================================================

STATUSLINE SUPPORT					*coc-status*

Diagnostics info and other status info contributed by extensions could be
shown in statusline.

The easiest way is add `%{coc#status()}` to your 'statusline' option. Example: >

	set statusline^=%{coc#status()}
>
------------------------------------------------------------------------------

							*coc-status-manual*

Create function:
>
	function! StatusDiagnostic() abort
	  let info = get(b:, 'coc_diagnostic_info', {})
	  if empty(info) | return '' | endif
	  let msgs = []
	  if get(info, 'error', 0)
	    call add(msgs, 'E' . info['error'])
	  endif
	  if get(info, 'warning', 0)
	    call add(msgs, 'W' . info['warning'])
	  endif
	  return join(msgs, ' ') . ' ' . get(g:, 'coc_status', '')
	endfunction
<
Add `%{StatusDiagnostic()}` to your 'statusline' option.

------------------------------------------------------------------------------

							*coc-status-airline*

With vim-airline: https://github.com/vim-airline/vim-airline

Error and warning display should work in vim-airline out of box.

Disable vim-airline integration:
>
	let g:airline#extensions#coc#enabled = 0
<
Change error symbol:
>
	let airline#extensions#coc#error_symbol = 'Error:'
<
Change warning symbol:
>
	let airline#extensions#coc#warning_symbol = 'Warning:'
<
Change error format:
>
	let airline#extensions#coc#stl_format_err = '%E{[%e(#%fe)]}'
<
Change warning format:
>
	let airline#extensions#coc#stl_format_warn = '%W{[%w(#%fw)]}'
<
------------------------------------------------------------------------------
							*coc-status-lightline*

With lightline.vim: https://github.com/itchyny/lightline.vim

Use configuration like: >

  let g:lightline = {
	\ 'colorscheme': 'wombat',
	\ 'active': {
	\   'left': [ [ 'mode', 'paste' ],
	\             [ 'cocstatus', 'readonly', 'filename', 'modified' ] ]
	\ },
	\ 'component_function': {
	\   'cocstatus': 'coc#status'
	\ },
	\ }

  " Use autocmd to force lightline update.
  autocmd User CocStatusChange,CocDiagnosticChange call lightline#update()
<
==============================================================================
CUSTOM SOURCE						*coc-custom-source*

Creating a custom source in VimL is supported.

Check out https://github.com/neoclide/coc.nvim/wiki/Create-custom-source

==============================================================================
FAQ							*coc-faq*

------------------------------------------------------------------------------

Check out https://github.com/neoclide/coc.nvim/wiki/F.A.Q

==============================================================================
CHANGELOG						*coc-changelog*

See history.md under project root.

==============================================================================
vim:tw=78:nosta:noet:ts=8:sts=0:ft=help:noet:fen:
