*coc-nvim.txt*					NodeJS client for Vim & Neovim.

Version: 0.0.81
Author: Qiming Zhao <chemzqm at gmail.com>
License: Anti 996 license

CONTENTS					*coc-contents*

Introduction					|coc-introduction|
Requirements					|coc-requirements|
Installation					|coc-installation|
Configuration					|coc-configuration|
LSP features 					|coc-lsp|
  Document 					|coc-document|
  Completion					|coc-completion|
  Diagnostics 					|coc-diagnostics|
  Signature help 				|coc-signature|
  Format 					|coc-format|
  Code action 					|coc-code-actions|
  Document highlights 				|coc-document-highlights|
  Document color 				|coc-document-color|
  Snippets 					|coc-snippets|
  Workspace					|coc-workspace|
  Cursors 					|coc-cursors|
  Outline 					|coc-outline|
  Call hierarchy 				|coc-callHierarchy|
  Semantic highlights 				|coc-semantic-highlights|
Interface					|coc-interface|
  Key mappings					|coc-key-mappings|
  Variables					|coc-variables|
    Buffer variables 				|coc-buffer-variables|
    Global variables 				|coc-global-variables|
  Functions					|coc-functions|
  Commands					|coc-commands|
  Autocmds					|coc-autocmds|
  Highlights					|coc-highlights|
Tree 						|coc-tree|
  Tree mappings 				|coc-tree-mappings|
  Tree filter 					|coc-tree-filter|
List						|coc-list|
  List command					|coc-list-command|
  List command options 				|coc-list-options|
  List configuration				|coc-list-configuration|
  List mappings					|coc-list-mappings|
  list sources					|coc-list-sources|
Dialog 						|coc-dialog|
  Dialog basic 					|coc-dialog-basic|
  Dialog confirm  				|coc-dialog-confirm|
  Dialog input 					|coc-dialog-input|
  Dialog menu 					|coc-dialog-menu|
  Dialog picker                                 |coc-dialog-picker|
Notification					|coc-notification|	
Statusline integration				|coc-status|
  Manual					|coc-status-manual|
  Airline					|coc-status-airline|
  Lightline					|coc-status-lightline|
FAQ						|coc-faq|
Changelog					|coc-changelog|

==============================================================================
INTRODUCTION						*coc-introduction*

Coc.nvim enhances your (Neo)Vim to match the user experience provided by
VSCode through a rich extension ecosystem and implemented features of Language
Server Protocol (3.16 for now).

Some of its key features include:~

- APIs compatible with both Vim8 and Neovim.
- Loading VSCode-like extensions.
- Configuring coc.nvim and its extensions with JSON configuration
  |coc-configuration|.
- Configuring Language Servers that using Language Server Protocol (LSP)
  |coc-config-languageserver|.

It is designed for best possible integration with other Vim plugins.

Note: This plugin doesn't come with support for any specific language. You
will need to install a coc.nvim extension or set up the language server by
configuration.

Note: This plugin doesn't change any of your existing key-mappings. You will
need to create key-mappings by yourself, see README.md for examples.

Note: Automatic completion plugins can't play nicely together, you can disable
automatic completion of coc.nvim through `"suggest.autoTrigger": "none"` (or
`"suggest.autoTrigger": "trigger"`) in your configuration file.

==============================================================================
REQUIREMENTS						*coc-requirements*

Neovim >= 0.3.2 or Vim >= 8.0.1453, for best experience, use neovim >= 0.4.0
or vim >= 8.2.0750.

NodeJS https://nodejs.org/ >= 12.12.0.

Yarn https://yarnpkg.com/ required to build coc.nvim from typescript source
code.

==============================================================================
INSTALLATION						*coc-installation*

If you're using [vim-plug](https://github.com/junegunn/vim-plug), add this to
your `init.vim` or `.vimrc`: >

  Plug 'neoclide/coc.nvim', {'branch': 'release'}
<
And run: >

  :PlugInstall

For other plugin managers, make sure to use code from the release branch.

You can also use Vim's native package management like: >

  #!/bin/sh
  # for vim8
  mkdir -p ~/.vim/pack/coc/start
  cd ~/.vim/pack/coc/start
  curl --fail -L https://github.com/neoclide/coc.nvim/archive/release.tar.gz|tar xzfv -

  # for neovim
  mkdir -p ~/.local/share/nvim/site/pack/coc/start
  cd ~/.local/share/nvim/site/pack/coc/start
  curl --fail -L https://github.com/neoclide/coc.nvim/archive/release.tar.gz|tar xzfv -

==============================================================================
CONFIGURATION						*coc-configuration*

The configuration of coc.nvim is stored in file `coc-settings.json`.

Command |:CocConfig| will open (create when necessary) a user settings
file in the folder returned by |coc#util#get_config_home()|

To create a local configuration file for a specific workspace, use
|:CocLocalConfig|.

The global configuration file can be created in another directory by setting
`g:coc_config_home` in your `.vimrc` or `init.vim`: >

	let g:coc_config_home = '/path/to/folder'

The configuration files are all in JSON format, it's recommended to
enable JSON completion and validation by install the `coc-json` extension: >

	:CocInstall coc-json
<
The user configuration can also be changed by |coc#config()|.

Configurations are composed with builtin configurations and configurations
contributed by coc extensions, see |coc-config| for builtin configurations.

==============================================================================
LSP FEATURES 						*coc-lsp*

All features (except for telemetry) of LSP 3.16 are supported, checkout
the specification at
https://microsoft.github.io/language-server-protocol/specifications/specification-3-16/

Use `:CocCommand document.checkBuffer` to check exists providers used by
current buffer. Or use API |CocHasProvider()|.

For historic reason, some features just works, but some are not.

Features automatically work by default:~

- Trigger completion |coc-completion|.
- Diagnostics refresh |coc-diagnostics|.
- Trigger signature help |coc-signature|.
- Inlay hints (only works with some coc extensions, but not
  |coc-config-languageserver| yet).

Note the features could be disabled by |coc-configuration| and some vim
variables.

Features require enabled by configuration:~

- Semantic highlights |coc-semantic-highlights|.
- Document color highlights |coc-document-color|.
- Code lens, enabled by |coc-config-codeLens-enable|.
- Linked editing, enabled by |coc-preferences-enableLinkedEditing|.
- Format on type, enabled by |coc-preferences-formatOnType|
- Format on save, enabled by |coc-preferences-formatOnSaveFiletypes|.

Features requested by user:~

- Invoke code action |coc-code-actions|.
- Show call hierarchy tree |coc-callHierarchy|.
- Format, range format and on type format |coc-format|.
- Highlight same symbol ranges |coc-document-highlights|.
- Outline of document symbols |coc-outline| and |coc-list-symbols|.
- Show hover message |CocAction('doHover')| and |CocAction('definitionHover')|.
- Rename current symbol |CocAction('rename')|.
- Jump to definition locations |CocAction('jumpDefinition')|.
- Jump to declaration locations |CocAction('jumpDeclaration')|.
- Jump to implementation locations |CocAction('jumpImplementation')|.
- Jump to type definition locations |CocAction('jumpTypeDefinition')|.
- Jump to references |CocAction('jumpReferences')| and |CocAction('jumpUsed')|.
- Open link under cursor |CocAction('openlink')|.
- Range selection |CocAction('rangeSelect').|
- Create folds |CocAction('fold')|.

For convenient, some actions have associated |coc-key-mappings| provided.

Features triggered by languageserver or extension:~

- Show message notification.
- Show message request.
- Log message (use `:CocCommand workspace.showOutput` to show output).
- Show document request.
- Work done progress.

To make coc.nvim provide LSP features for your languages, checkout
https://github.com/neoclide/coc.nvim/wiki/Language-servers

To debug issues with languageserver, checkout
https://github.com/neoclide/coc.nvim/wiki/Debug-language-server

==============================================================================

DOCUMENT 						*coc-document*

A document is created on buffer create, and disposed on buffer unload.

Attached document:~
							*coc-document-attached*

An attached document means coc.nvim synchronize the lines of vim's buffer with
associated document automatically.

Only attached documents are synchronized with language servers and therefore
LSP features could be provided for the attached buffer.

The buffer may not be attached by following reasons:

- The 'buftype' is neither <empty> nor 'acwrite'.
- Buffer variable |b:coc_enabled| should is `1`.
- Byte length of buffer exceed |coc-preferences-maxFileSize|.
- Buffer is used for command line window.

Use |CocAction('ensureDocument')| or `:CocCommand document.checkBuffer` to
check attached state of current buffer.

Filetype map:~
							*coc-document-filetype*

Some filetypes are mapped to others to match the languageId used by VSCode,
including:

- javascript.jsx -> javascriptreact
- typescript.jsx -> typescriptreact
- typescript.tsx -> typescriptreact
- tex -> latex

Use |g:coc_filetype_map| to create additional filetype maps.

Use `:CocCommand document.echoFiletype` to echo mapped filetype of current
document.

Note make sure use mapped filetypes for configurations that expect filetypes.

==============================================================================
COMPLETION						*coc-completion*

Default behavior of coc.nvim's completion:

- Completion is automatically triggered.
- 'completeopt' is temporarily changed to `noinsert,menuone`.
- Snippet complete item would only be expanded after confirm completion.

Use configurations |coc-config-suggest| to change behavior of completion.

Related variables:~

- |b:coc_suggest_disable|
- |b:coc_disabled_sources|
- |b:coc_suggest_blacklist|
- |b:coc_additional_keywords|

Related APIs:~

- |coc#start()|
- |coc#refresh()|
- |coc#_select_confirm()|

Tips:~

- 'completeopt' used by coc.nvim default to `noselect,menuone`.
- Your 'completeopt' option would be changed and restored during completion,
  so you can still use `menu,preview` for Vim's built in completion.
- Snippet expand and additional edit feature of LSP requires confirm
  completion by <C-y> to work.

------------------------------------------------------------------------------

Example completion key-mappings:~

Map <tab> to trigger completion and navigate to the next item: >

    function! s:check_back_space() abort
      let col = col('.') - 1
      return !col || getline('.')[col - 1]  =~ '\s'
    endfunction

    inoremap <silent><expr> <TAB>
		  \ pumvisible() ? "\<C-n>" :
		  \ <SID>check_back_space() ? "\<TAB>" :
		  \ coc#refresh()


Map <c-space> to trigger completion: >

	inoremap <silent><expr> <c-space> coc#refresh()
<
<CR> to confirm completion, use: >

	inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<CR>"
<
To make <CR> auto-select the first completion item and notify coc.nvim to
format on enter, use: >

	inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm()
				\: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"

Map <tab> for trigger completion, completion confirm, snippet expand and jump
like VSCode. >

	inoremap <silent><expr> <TAB>
	  \ pumvisible() ? coc#_select_confirm() :
	  \ coc#expandableOrJumpable() ?
	  \ "\<C-r>=coc#rpc#request('doKeymap', ['snippets-expand-jump',''])\<CR>" :
	  \ <SID>check_back_space() ? "\<TAB>" :
	  \ coc#refresh()

	function! s:check_back_space() abort
	  let col = col('.') - 1
	  return !col || getline('.')[col - 1]  =~# '\s'
	endfunction

	let g:coc_snippet_next = '<tab>'
<
Note: the `coc-snippets` extension is required for this to work.

==============================================================================
DIAGNOSTICS SUPPORT 					*coc-diagnostics*

Diagnostics of coc.nvim are automatically refreshed to UI by default, checkout
|coc-config-diagnostic| for available configurations.

Note most language servers only send diagnostics for opened buffers for
performance reason, some lint tools could provide diagnostics for all files in
workspace.

Note pull diagnostics feature is added in LSP 3.17, which is not available
yet.

Changes on diagnostics refresh~

- Add highlights for diagnostic ranges and virtual text (when enabled on
  neovim with virtual text support), see |coc-highlights-diagnostics|.
- Add diagnostic signs to 'signcolumn', use `set signcolumn=yes` to avoid
  unnecessary UI refresh.
- Update variable |b:coc_diagnostic_info|.
- Refresh related |location-list| which was opened by |:CocDiagnostics|.

Diagnostics are not refreshed when buffer is hidden, and refresh on insert
mode is disabled by default.

Diagnostics highlights:~

See |coc-highlights-diagnostics|.

Enable and disable diagnostics~

Use |coc-config-diagnostic-enable| to toggle diagnostics feature.

Use |CocAction('diagnosticToggle')| for enable/disable diagnostics of current
buffer.

Show diagnostic messages~

Diagnostic messages would be automatically shown/hide when the diagnostics
under cursor position changed (use float window/popup when possible) by
default.

To manually refresh diagnostics messages, use |<Plug>(coc-diagnostic-info)|
and |CocAction('diagnosticPreview')|.

Jump between diagnostics~

Use key-mappings:

	|<Plug>(coc-diagnostic-next)| jump to next diagnostic.
	|<Plug>(coc-diagnostic-prev)| jump to previous diagnostic.
	|<Plug>(coc-diagnostic-next-error)| jump to next error.
	|<Plug>(coc-diagnostic-prev-error)| jump to previous error.

Check all diagnostics~

Use |coc-list-diagnostics| to open |CocList| with all diagnostics.

Use API |CocAction('diagnosticList')| to get list of all diagnostics.

==============================================================================
SIGNATURE HELP 						*coc-signature*

Signature help of function is automatically triggered by default(when user
type trigger characters defined by the provider), which will use float
window/popup to show the signature messages when possible.

Use |CocAction('showSignatureHelp')| to trigger signature help manually.

Note error will not be thrown when provider not exists or nothing returned
from languageserver, use `:CocCommand document.checkBuffer` to check provider
state of current buffer.

Use |coc-config-signature| to change default signature help behavior.

==============================================================================
FORMAT 							*coc-format*

There're various ways to format document.

Format full document:~

Use |CocAction('format')|, you can create a command like: >

	command! -nargs=0 Format :call CocActionAsync('format')
<
to format current buffer.

Format on type:~

Enable format when insert specific characters by configurations:

- |coc-preferences-formatOnType|
- |coc-preferences-formatOnTypeFiletypes|

requires `onTypeEdit` provider |CocHasProvider|.

Format selected code:~

Use 'formatexpr' for specific filetypes: >

  autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')

So that |gq| could works for format range of lines.
>
Setup visual mode and operator key-mappings: >

  xmap <leader>f  <Plug>(coc-format-selected)
  nmap <leader>f  <Plug>(coc-format-selected)
<
Format on save:~

Use configuration |coc-preferences-formatOnSaveFiletypes|.

Or create |BufWritePre| autocmd like: >

	autocmd BufWritePre * call CocAction('format')
<
Note avoid use |CocActionAsync| with |BufWritePre|.

==============================================================================
CODE ACTION 						*coc-code-actions*

Code actions are used for make some specific code changes.

There're different kinds of code actions:

- `quickfix` used for fix diagnostic(s).
- `refactor` used for code refactor.
- `source` code actions apply to the entire file.
- `organizeImport` organize import statements of current document.

Invoke code action~

To fix diagnostic at current line, use |<plug>(coc-fix-current)|.

Key-mappings for choose code action:~

- |<plug>(coc-codeaction-cursor)|
- |<plug>(coc-codeaction-line)|
- |<plug>(coc-codeaction)|
- |<plug>(coc-codeaction-selected)|

|coc-dialog-menu| would be shown for pick specific code action.

To invoke organize import action, use command like:
>
	command! -nargs=0 OR :call CocAction('runCommand',
				\ 'editor.action.organizeImport')

Related APIs~

- |CocAction('codeActions')|
- |CocAction('organizeImport')|
- |CocAction('fixAll')|
- |CocAction('quickfixes')|
- |CocAction('doCodeAction')|
- |CocAction('doQuickfix')|
- |CocAction('codeActionRange')|

==============================================================================
DOCUMENT HIGHLIGHTS 					*coc-document-highlights*

Document highlights is used for highlight same symbols of current document
under cusor.

To enable highlight on CursorHold, create an autocmd like this: >

	autocmd CursorHold * silent call CocActionAsync('highlight')
<
Checkout |coc-highlights-document| for related highlight groups.

Note error will not be thrown when provider not exists or nothing returned
from languageserver with |CocAction('highlight')|

Install `coc-highlight` extension if you want to highlight same words under
cursor without languageserver support.

To jump between previous/next symbol position, use
`:CocCommand document.jumpToPrevSymbol` and
`:CocCommand document.jumpToNextSymbol`

==============================================================================
DOCUMENT COLOR 						*coc-document-color*

Document colors added color highlights to your documents.  To enable document
color highlights, use ||coc-config-colors-filetypes||.

Install `coc-highlights` to provide document color highlights for all
filetypes.

To pick a color from system color picker, use |CocAction('pickColor')| or
choose `editor.action.pickColor` from |:CocCommand|.

Note: may not work on your system.

To change color presentation, use |CocAction('colorPresentation')| or choose
`editor.action.colorPresentation` from |:CocCommand|.

==============================================================================
SNIPPETS SUPPORT 					*coc-snippets*

Snippets engine of coc.nvim support both VSCode snippets and ultisnips
snippets format.

The complete item with snippet format has label ends with `~` by default.
Select the complete item and confirm the completion by <C-y> to expand the
snippet.

A snippet session would be deactivated under the following conditions:

- |InsertEnter| triggered outside snippet.
- Jump to final placeholder.
- Content change detected after snippet.
- Content changed in a snippet outside placeholder (except for deletion of
  plain text).

To load and expand custom snippets, install `coc-snippets` extension is
recommended.

Related configurations:

- |g:coc_snippet_prev|
- |g:coc_snippet_next|
- |coc-config-suggest-snippetIndicator|
- |coc-config-suggest-preferCompleteThanJumpPlaceholder|
- |coc-preferences-snippetStatusText|
- |coc-preferences-snippetHighlight|

Related functions:

- |coc#snippet#next()|
- |coc#snippet#prev()|
- |coc#expandable()|
- |coc#jumpable()|
- |coc#expandableOrJumpable()|

Related variables: |b:coc_snippet_active|
Related highlights: |CocSnippetVisual|
Related autocmds: |CocJumpPlaceholder|

==============================================================================
WROKSPACE SUPPORT 					*coc-workspace*

Workspace folders~

Unlike VSCode, workspace folders are resolved from filepath after buffer load.

A list of file/folder names is used for resolve workspace folder, the patterns
could comes from:

- |b:coc_root_patterns|
- `rootPatterns` field of configured language server.
- `rootPatterns` contributions from coc extensions.
- |coc-preferences-rootPatterns|

Workspace folder is resolved from cwd of vim first and then from top directory
to the parent directory of current filepath, when workspace folder not
resolved, current working directory is used if it's parent folder of current
buffer.  Configurations are provided to change the default behavior:

- |coc-config-workspace-ignoredFiletypes|
- |coc-config-workspace-ignoredFolders|
- |coc-config-workspace-bottomUpFiletypes|
- |coc-config-workspace-workspaceFolderCheckCwd|
- |coc-config-workspace-workspaceFolderFallbackCwd|

Note for performance reason, user's home directory would never considered as
workspace folder, which also means the languageserver that requires workspace
folder may not work when you start vim from home directory.

To preserve workspace folders across vim session, |g:WorkspaceFolders| is
provided.

To manage current workspace folders, use |coc-list-folders|

To get related root patterns of current buffer, use |coc#util#root_patterns()|

Use `:CocCommand workspace.workspaceFolders` to echo current workspaceFolders.

Workspace edit~

Workspace edit is used to apply changes for multiple buffers(and files), the
edit could includes document edits and file operations (including file create,
file/directory delete and file/directory rename).

When the edit failed to apply, coc.nvim will revert the changes (including
document edits and file operations) that previous made.

Files not loaded would be loaded by `tab drop` command, configured by
|coc-config-workspace-openResourceCommand|.

To undo and redo workspace edit just applied, use command
`:CocCommand workspace.undo` and `:CocCommand workspace.redo`

To inspect previous workspace edit, use command
`:CocCommand workspace.inspectEdit`, in opened buffer, use <CR> for jump to
change position under cursor.

==============================================================================
CURSORS SUPPORT						*coc-cursors*

Multiple cursors supported is added to allow edit multiple locations at once.

Cursors session could be started by following ways:

- Use command `:CocCommand document.renameCurrentWord` to rename variable
  under cursor.
- Use |<plug>(coc-refactor)| to open refactor buffer.
- Use |:CocSearch| to open searched locations.
- Use cursors related key-mappings to add text range, including
  |<plug>(coc-cursors-operator)|, |<Plug>(coc-cursors-word)|,
  |<Plug>(coc-cursors-position)| and |<plug>(coc-cursors-range)|
- Ranges added by command `editor.action.addRanges` from coc extensions.

Default key-mappings when cursors activated:

- <esc> cancel cursors session.
- <C-n> jump to next cursors range.
- <C-p> jump to previous cursors range.

Use |coc-config-cursors| to change cursors related key-mappings.
Use highlight group |CocCursorRange| to change default range highlight.
Use |b:coc_cursors_activated| to check if cursors session is enabled.

==============================================================================
SYMBOLS OUTLINE						*coc-outline*

Outline is a split window with current document symbols rendered as
|coc-tree|.

To show and hide outline of current window, use |CocAction('showOutline')| and
|CocAction('hideOutline')|.

Outline view has Window variable `cocViewId` set to `OUTLINE`.

Following outline features are supported:
- Start fuzzy filter by |coc-config-tree-key-activeFilter|.
- Automatic update after document change.
- Automatic reload when buffer in current window changed.
- Automatic follow cursor position by default.
- Different filter modes that can be changed on the fly
  |coc-config-outline-switchSortKey|.

Note: outline would try to reload document symbols after 500ms when provider
not registered, which avoid the necessary to check provider existence.

Checkout |coc-config-tree| and |coc-config-outline| for available
configurations.

Checkout |CocTree| and |CocSymbol| for customize highlights.

Use configuration `"suggest.completionItemKindLabels"` for custom icons.

To show outline for each tab automatically, use |autocmd|:
>
  autocmd VimEnter,Tabnew *
	  \ if empty(&buftype) | call CocActionAsync('showOutline', 1) | endif
<
To close outline when it's the last window automatically, use
|autocmd| like:
>
  autocmd BufEnter * call CheckOutline()
  function! CheckOutline() abort
    if &filetype ==# 'coctree' && winnr('$') == 1
      if tabpagenr('$') != 1
        close
      else
        bdelete
      endif
    endif
  endfunction
<
Create a key-mapping to toggle outline, like:
>
  nnoremap <silent><nowait> <space>o  :call ToggleOutline()<CR>
  function! ToggleOutline() abort
    let winid = coc#window#find('cocViewId', 'OUTLINE')
    if winid == -1
      call CocActionAsync('showOutline', 1)
    else
      call coc#window#close(winid)
    endif
  endfunction
<
==============================================================================
CALL HIERARCHY						*coc-callHierarchy*

A call hierarchy is a splited |coc-tree| with locations for incoming or
outgoing calls of current function.

Call hierarchy window is opend by |CocAction('showIncomingCalls')| and
|CocAction('showOutgoingCalls')|.

Call hierarchy is configured by |CocSymbol|, |coc-config-callHierarchy| and
|coc-config-tree|.

Related ranges are highlighted with |CocSelectedRange| highlight group in
opend buffer.

|coc-dialog-menu| could be invoked by |coc-config-tree-key-actions|.
Available actions:

- Dismiss.
- Open in new tab.
- Show Incoming Calls.
- Show Outgoing Calls.

Use <CR> in call hierarchy tree to open location in original window.

==============================================================================
SEMANTIC HIGHLIGHTS					*coc-semantic-highlights*

Semantic tokens are used to add additional color information to a file that
depends on language specific symbol information.

Use |coc-config-semanticTokens-filetypes| to enable semantic tokens highlights.

Use `:CocCommand semanticTokens.checkCurrent` to check semantic highlight
information with current buffer.

To create custom highlights for symbol under cursor, follow these steps:

- Inspect semantic token by
>
  :CocCommand semanticTokens.inspect
<
  to check token type and token modifiers with current symbol.

- Create new highlight group by |highlight|, for example:
>
  :hi link CocSemDeclarationVariable MoreMsg
<
- Refresh semantic highlight of current buffer by:
>
  :CocCommand semanticTokens.refreshCurrent
<
See |CocSem| to customize semantic token highlight groups.

See |coc-config-semanticTokens| for related configurations.

==============================================================================
INTERFACE						*coc-interface*

------------------------------------------------------------------------------

Key mappings						*coc-key-mappings*

There're some cases that local key-mappings are enabled for current buffer.

	Snippet jump key-mappings when snippet is activated:
	|g:coc_snippet_prev| and |g:coc_snippet_next|.

	Cursor jump and cancel key-mappings when cursors is activated
	|coc-config-cursors|.

	Dialog key-mappings for confirm and cancel dialog window
	|coc-config-dialog|.

	Key-mappings for |CocList| buffer: |coc-list-mappings|.

Note: Use |:verbose| command to check key-mappings that taking effect.

Note: Use 'noremap' with <Plug> will make the key-mapping not work at all.

Note: <Plug> key-mappings are provided for convenient, use |CocActionAsync()| or
|CocAction()| for more options.

Normal mode key-mappings:~

*<plug>(coc-diagnostic-info)* Show diagnostic message of current position by
invoke |CocAction('diagnosticInfo')|

*<plug>(coc-diagnostic-next)* Jump to next diagnostic position.

*<plug>(coc-diagnostic-prev)* Jump to previous diagnostic position.

*<plug>(coc-diagnostic-next-error)* Jump to next diagnostic error position.

*<plug>(coc-diagnostic-prev-error)* Jump to previous diagnostic error position.

*<plug>(coc-definition)* Jump to definition(s) of current symbol by invoke
|CocAction('jumpDefinition')|

*<plug>(coc-declaration)* Jump to declaration(s) of current symbol by invoke
|CocAction('jumpDeclaration')|

*<plug>(coc-implementation)* Jump to implementation(s) of current symbol by
invoke |CocAction('jumpImplementation')|

*<plug>(coc-type-definition)* Jump to type definition(s) of current symbol by
invoke |CocAction('jumpTypeDefinition')|

*<plug>(coc-references)* Jump to references of current symbol by invoke
|CocAction('jumpReferences')|

*<plug>(coc-references-used)* Jump to references of current symbol exclude
declarations.

*<plug>(coc-format-selected)*

	Format selected range, works on both |visual-mode| and |normal-mode|,
	when used in normal mode, the selection works on the motion object.

	For example: >

	vmap <leader>p  <Plug>(coc-format-selected)
	nmap <leader>p  <Plug>(coc-format-selected)
<
	makes `<leader>p` format the visually selected range, and you can use
	`<leader>pap` to format a paragraph.

*<plug>(coc-format)* Format the whole buffer by invoke |CocAction('format')|
*<plug>(coc-rename)* Rename symbol under cursor to a new word by invoke
|CocAction('rename')|

*<plug>(coc-refactor)* Open refactor window for refactor of current symbol by
invoke |CocAction('refactor')|

*<plug>(coc-command-repeat)* Repeat latest |CocCommand|.

*<plug>(coc-codeaction)* Get and run code action(s) for current file, use
|coc-codeaction-cursor| for same behavior as VSCode.

*<plug>(coc-codeaction-line)* Get and run code action(s) for current line.

*<plug>(coc-codeaction-cursor)* Get and run code action(s) using empty range
at current cursor.

*<plug>(coc-codeaction-selected)* Get and run code action(s) with the selected
region.  Works on both |visual-mode| and |normal-mode|.

*<plug>(coc-openlink)* Open link under cursor by use |CocAction('openlink')|.

*<plug>(coc-codelens-action)* Do command from codeLens of current line.

*<plug>(coc-fix-current)* Try first quickfix action for diagnostics of current
line.

*<plug>(coc-float-hide)* Hide all float windows/popups created by coc.nvim.

*<plug>(coc-float-jump)* Jump to first float window (neovim only), use
|CTRL-W_p| for jump to previous window.

*<plug>(coc-range-select)*

	Select next selection range.
	Works on both |visual-mode| and |normal-mode|.

	Note: requires selection ranges feature of language server.

*<plug>(coc-funcobj-i)*

	Select inside function. Recommend mapping:
	Works on both |visual-mode| and |normal-mode|.
  >
	xmap if <Plug>(coc-funcobj-i)
	omap if <Plug>(coc-funcobj-i)
<
	Note: Requires 'textDocument.documentSymbol' support from the language
	server.

*<Plug>(coc-funcobj-a)*

	Select around function.  Works on both |visual-mode| and
	|normal-mode|.  Recommended mapping:
>
	xmap af <Plug>(coc-funcobj-a)
	omap af <Plug>(coc-funcobj-a)
<
	Note: Requires 'textDocument.documentSymbol' support from the language
	server.

*<Plug>(coc-classobj-i)*

	Select inside class/struct/interface.  Works on both |visual-mode| and
	|normal-mode|.  Recommended mapping:
>
	xmap ic <Plug>(coc-classobj-i)
	omap ic <Plug>(coc-classobj-i)
<
	Note: Requires 'textDocument.documentSymbol' support from the language
	server.

*<plug>(coc-classobj-a)*

	Select around class/struct/interface.  Works on both |visual-mode| and
	|normal-mode|.  Recommended mapping:
>
	xmap ac <Plug>(coc-classobj-a)
	omap ac <Plug>(coc-classobj-a)
<
	Note: Requires 'textDocument.documentSymbol' support from the language
	server.


*<plug>(coc-cursors-operator)* Add text to cursors session by motion object.

*<Plug>(coc-cursors-word)* Add current word to cursors session.

*<Plug>(coc-cursors-position)* Add current position as empty range to cursors
session.

Visual mode key-mappings:~

*<plug>(coc-range-select-backward)*

	Select previous selection range.

	Note: requires selection ranges feature of language server, like:
	coc-tsserver, coc-python

*<plug>(coc-cursors-range)* Add selection to cursors session.

------------------------------------------------------------------------------
VARIABLES						*coc-variables*

User defined variables:~

------------------------------------------------------------------------------

Buffer variables 					*coc-buffer-variables*

b:coc_enabled						*b:coc_enabled*

	Set to `0` on buffer create if you don't want coc.nvim receive content
	from buffer. Normally used with |BufAdd| autocmd, example:
>
	" Disable file with size > 1MB
	autocmd BufAdd * if getfsize(expand('<afile>')) > 1024*1024 |
				\ let b:coc_enabled=0 |
				\ endif
<
b:coc_root_patterns					*b:coc_root_patterns*

	Root patterns used for resolving workspaceFolder for
	the current file, will be used instead of
	`"coc.preferences.rootPatterns"` setting. Example: >

	autocmd FileType python let b:coc_root_patterns =
				\ ['.git', '.env']
<

b:coc_suggest_disable					*b:coc_suggest_disable*

	Disable completion support of current buffer. Example: >

	" Disable completion for python
	autocmd FileType python let b:coc_suggest_disable = 1

b:coc_disabled_sources 					*b:coc_disabled_sources*

	Disabled completion sources of current buffer. Example:
>
	let b:coc_disabled_sources = ['around', 'buffer', 'file']
<
b:coc_diagnostic_disable				*b:coc_diagnostic_disable*

	Disable diagnostic support of current buffer.

b:coc_suggest_blacklist                 	        *b:coc_suggest_blacklist*

	List of input words for which completion should not be triggered.
	Example: >

	" Disable completion for 'end' in lua files
	autocmd FileType lua let b:coc_suggest_blacklist = ["end"]

b:coc_additional_keywords				*b:coc_additional_keywords*

	Addition keyword characters for generate keywords. Example: >

	" Add keyword characters for css
	autocmd FileType css let b:coc_additional_keywords = ["-"]

b:coc_trim_trailing_whitespace				*b:coc_trim_trailing_whitespace*

	Trim trailing whitespace on a line, default `0`.
	Use by "FormattingOptions" send to the server.

b:coc_trim_final_newlines 				*b:coc_trim_final_newlines*

	Trim all newlines after the final newline at the end of the file.
	Use by "FormattingOptions" send to the server.

	Other buffer options that affect document format: 'eol', 'shiftwidth'
	and 'expandtab'.

	Note: language server may not respect format options.

------------------------------------------------------------------------------

Global variables 					*coc-global-variables*

g:coc_disable_startup_warning 				*g:coc_disable_startup_warning*

	Disable possible warning on startup for old vim/node version.

	Default: 0

g:coc_disable_uncaught_error 				*g:coc_disable_uncaught_error*

	Disable uncaught error messages from node process of coc.nvim.

	Default: 0

g:coc_text_prop_offset 					*g:coc_text_prop_offset*

	Start |textprop| id offset of highlight namespaces on vim, change to
	other value to avoid conflict.

	Default: 1000

g:coc_channel_timeout					*g:coc_channel_timeout*

	Channel timeout in seconds for request to node client.

	Default: 30

g:coc_disable_transparent_cursor			*g:coc_disable_transparent_cursor*

	Disable transparent cursor when CocList is activated.
	Set it to `1` if you have issue with transparent
	cursor.

	Default: 0

g:coc_start_at_startup					*g:coc_start_at_startup*

	Start coc service on startup, use |CocStart| to start server when you
	set it to 0.

	Default: 1

g:coc_global_extensions					*g:coc_global_extensions*

	Global extension names to install when they aren't installed.
>
	let g:coc_global_extensions = ['coc-json', 'coc-git']
<
	Note: coc.nvim will try to install extensions that are not installed
	in this list after initialization.

g:coc_uri_prefix_replace_patterns			*g:coc_uri_prefix_replace_patterns*

	This map defines URI prefix replacements. This is useful in the case
	that an LSP requires code to adhere to a particular directory
	structure. For example, `/Users/myUser/workspace` can be mapped to
	`/home/myUser/workspace`.
>
	let g:coc_uri_prefix_replace_patterns = {'/Users': '/home'}
<
g:coc_enable_locationlist				*g:coc_enable_locationlist*

	Use location list of |CocList| when jump to locations.

	Set it to 0 when you need customize behavior of location jump by use
	|CocLocationsChange| and |g:coc_jump_locations|

	If you want use vim's quickfix list instead, add
	`"coc.preferences.useQuickfixForLocations": true` in your
	configuration file, this configuration would be ignored and no autocmd
	triggered.

	Default: 1

g:coc_snippet_next					*g:coc_snippet_next*

	Trigger key for going to the next snippet position, applied in insert
	and select mode.

	Only works when snippet session is activated.

	Default: <C-j>

g:coc_snippet_prev					*g:coc_snippet_prev*

	Trigger key for going to the previous snippet position, applied in
	insert and select mode.

	Only works when snippet session is activated.

	Default: <C-k>

g:coc_filetype_map					*g:coc_filetype_map*

	Map for document filetypes so the server could handle current document
	as another filetype, example: >

	let g:coc_filetype_map = {
		\ 'html.swig': 'html',
		\ 'wxss': 'css',
		\ }
<
	Default: {}

	See |coc-document-filetype| for details.

g:coc_selectmode_mapping				*g:coc_selectmode_mapping*

	Add key mappings for making snippet select mode easier. >

	snoremap <silent> <BS> <c-g>c
	snoremap <silent> <DEL> <c-g>c
	snoremap <silent> <c-h> <c-g>c
	snoremap <c-r> <c-g>"_c<c-r>
<
	Default: 1

g:coc_node_path						*g:coc_node_path*

	Path to node executable to start coc service, example: >

	let g:coc_node_path = '/usr/local/opt/node@12/bin/node'
<
	Use this when coc has problems with your system node,

	Note: you can use `~` as home directory.

g:coc_node_args						*g:coc_node_args*

	Arguments passed to node when starting coc service from source code.

	Useful for starting coc in debug mode, example: >
>
	let g:coc_node_args = ['--nolazy', '--inspect-brk=6045']
<
	Default: []

g:coc_status_error_sign					*g:coc_status_error_sign*

	Error character used for statusline, default: `E`

g:coc_status_warning_sign				*g:coc_status_warning_sign*

	Warning character used for statusline, default: `W`

g:coc_quickfix_open_command				*g:coc_quickfix_open_command*

	Command used for open quickfix list.  To jump fist position after
	quickfix list opend, you can use:
>
	let g:coc_quickfix_open_command = 'copen|cfirst'
<
	Default: |copen|

g:node_client_debug					*g:node_client_debug*

	Enable debug mode of node client for check rpc messages between vim
	and coc.nvim.  Use environment variable $NODE_CLIENT_LOG_FILE to set
	the log file or get the log file after coc.nvim started.
	To open the log file, use command: >

	:call coc#client#open_log()
<
	Default: `0`

g:coc_config_home					*g:coc_config_home*

	Configure the directory which will be used to look for
	user's `coc-settings.json`, default:

	Windows: `~/AppData/Local/nvim`
	Other: `~/.config/nvim`

g:coc_data_home						*g:coc_data_home*

	Configure the directory which will be used to for data
	files(extensions, mru and so on), default:

	Windows: `~/AppData/Local/coc`
	Other: `~/.config/coc`

g:coc_terminal_height					*g:coc_terminal_height*

	Height of terminal window, default `8`.

g:coc_markdown_disabled_languages  			*g:coc_markdown_disabled_languages*

	Filetype list that should be disabled for highlight in markdown block,
	Example: >

	let g:coc_markdown_disabled_languages = ['html']

g:coc_highlight_maximum_count 				*g:coc_highlight_maximum_count*

	When highlight items exceed maximum count, highlight items will be
	grouped and added by using |timer_start| for better user experience.

	Default `100`

g:coc_default_semantic_highlight_groups 		*g:coc_default_semantic_highlight_groups*

	Create default semantic highlight groups for |coc-semantic-highlights|

	Default: `1`

g:coc_max_treeview_width 				*g:coc_max_treeview_width*

	Maximum width of tree view when adjusted by auto width.

	Default: `40`

g:coc_borderchars 					*g:coc_borderchars*

	Border characters used by border window, default to:
>
	['─', '│', '─', '│', '┌', '┐', '┘', '└']
<
	Note: you may need special font like Nerd font to show them.

g:coc_border_joinchars 					*g:coc_border_joinchars*

	Border join characters used by float window/popup, default to:
>
	['┬', '┤', '┴', '├']
<
	Note: you may need special font like Nerd font to show them.

g:coc_prompt_win_width 					*g:coc_prompt_win_width*

	Width of input prompt window, default `32`.

							*g:coc_notify*
g:coc_notify_error_icon 				*g:coc_notify_error_icon*

	Error icon for notification, default to: 

g:coc_notify_warning_icon 				*g:coc_notify_warning_icon*

	Warning icon for notification, default to: ⚠

g:coc_notify_info_icon 					*g:coc_notify_info_icon*

	Info icon for notification, default to: 

------------------------------------------------------------------------------

Some variables are provided by coc.nvim.


g:WorkspaceFolders					*g:WorkspaceFolders*

	Current workspace folders, used for restoring from a session file, add
	`set sessionoptions+=globals` to vimrc for restoring globals on
	session load.

g:coc_jump_locations					*g:coc_jump_locations*

	This variable would be set to jump locations when the
	|CocLocationsChange| autocmd is fired.

	Each location item contains:

	'filename': full file path.
	'lnum': line number (1 based).
	'col': column number(1 based).
	'text':  line content of location.

g:coc_process_pid					*g:coc_process_pid*

	Process pid of coc.nvim service. If your vim doesn't kill coc.nvim
	process on exit, use:
>
	autocmd VimLeavePre * if get(g:, 'coc_process_pid', 0)
		\	| call system('kill -9 '.g:coc_process_pid) | endif
<
	in your vimrc.

g:coc_service_initialized	 			*g:coc_service_initialized*

	Is `1` when coc.nvim initialized, used with autocmd |CocNvimInit|.

g:coc_status						*g:coc_status*

	Status string contributed by coc.nvim and extensions, used for status
	line.

g:coc_last_float_win					*g:coc_last_float_win*

	Window id of latest created float/popup window.

g:coc_last_hover_message				*g:coc_last_hover_message*

	Last message echoed from `doHover`, can be used in statusline.

	Note: not used when floating or preview window used for `doHover`.

b:coc_snippet_active					*b:coc_snippet_active*

	Is `1` when snippet session is activated, use |coc#jumpable| to check
	if it's possible to jump placeholder.

b:coc_diagnostic_info					*b:coc_diagnostic_info*

	Diagnostic information of current buffer, the format would look like:

	`{'error': 0, 'warning': 0, 'information': 0, 'hint':0}`

	can be used to customize statusline. See |coc-status|.

b:coc_current_function					*b:coc_current_function*

	Function string that current cursor in.

	Set `"coc.preferences.currentFunctionSymbolAutoUpdate": true`
	in coc-settings.json to update it on CursorHold.

b:coc_cursors_activated					*b:coc_cursors_activated*

	Use expression `get(b:, 'coc_cursors_activated',0)` to check if
	cursors session is activated for current buffer.

------------------------------------------------------------------------------
FUNCTIONS						*coc-functions*

Coc functions are normally used by user defined command/keymap or other
plugins.

Note: some functions only work after the coc service has been initialized.

To run a function on startup, use an autocmd like: >

	autocmd User CocNvimInit call CocAction('runCommand',
						\ 'tsserver.watchBuild')
<
coc#start([{option}]) 					*coc#start()*

	Start completion with optional {option}.  Option could contains:

		- `source` specific completion source name.

	Example:  >

	inoremap <silent> <C-w> <C-R>=coc#start({'source': 'word'})<CR>
<
	Use `:CocList sources` to get available sources.

coc#config({section}, {value})				*coc#config()*

	Change user configuration by Vim script, no changes would be made to
	user configuration file. Example: >

	call coc#config('coc.preferences', {
		\ 'timeout': 1000,
		\})
	call coc#config('languageserver', {
		\ 'ccls': {
		\   "command": "ccls",
		\   "trace.server": "verbose",
		\   "filetypes": ["c", "cpp", "objc", "objcpp"]
		\ }
		\})
<

	Note: this function can be called multiple times.

	Note: this function can be called before the service has been
	initialized.

	Note: this function can work alongside the user configuration file,
	but it's not recommended to use both.

coc#add_extension({name}, ...)				*coc#add_extension()*

	Deprecated function for install extensions not exists.
	Use |g:coc_global_extensions| variable instead.

	Example: >

	call coc#add_extension('coc-json', 'coc-tsserver', 'coc-rls')
<
	This function can be called before service initialized.
	This function can be called multiple times.

coc#add_command({id}, {command}, [{title}])		*coc#add_command()*

	Add custom Vim command to commands list opened by
	`:CocList commands` .

	Example: >

	call coc#add_command('mundoToggle', 'MundoToggle',
		\ 'toggle mundo window')
<
coc#refresh()						*coc#refresh()*

	Start or refresh completion at current cursor position, bind this to
	'imap' to trigger completion, example: >

	inoremap <silent><expr> <c-space> coc#refresh()
<
coc#expandable()					*coc#expandable()*

	Check if a snippet is expandable at the current position.
	Requires `coc-snippets` extension installed.

coc#jumpable()						*coc#jumpable()*

	Check if a snippet is jumpable at the current position.

coc#expandableOrJumpable()				*coc#expandableOrJumpable()*

	Check if a snippet is expandable or jumpable at the current position.
	Requires `coc-snippets` extension installed.

coc#on_enter()						*coc#on_enter()*

	Notify coc.nvim that `<enter>` has been pressed.

	Used for the format on type and improvement of brackets, example: >

	inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm()
				\: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"
<
	Note：to enable formatOnType, add ` "coc.preferences.formatOnType": true`
	in your settings file.

coc#status()						*coc#status()*

	Return a status string that can be used in the status line, the status
	includes diagnostic information from `b:coc_diagnostic_info` and
	extension contributed statuses from `g:coc_status`. For statusline
	integration, see |coc-status|

coc#_select_confirm()					*coc#_select_confirm()*

	Select first completion item if no completion item is selected, then
	confirm the completion.

	Note: for this function to work as expected, either |CompleteChanged|
	autocmd should exist or only <C-n> and <C-p> should be used to select
	a completion item.

coc#util#api_version() 					*coc#util#api_version()*

	Get coc.nvim's vim api version number, start from `1`.

coc#util#job_command()					*coc#util#job_command()*

	Get the job command used for starting the coc service.

coc#util#get_config_home()				*coc#util#get_config_home()*

	Get the config directory that contains the user's coc-settings.json.

coc#util#get_data_home()				*coc#util#get_data_home()*

	Get `coc` data directory.

coc#util#extension_root()				*coc#util#extension_root()*

	Return extensions root of coc.nvim.

coc#util#rebuild()					*coc#util#rebuild()*

	Run `npm rebuild` for all coc extensions.

coc#util#root_patterns()				*coc#util#root_patterns()*

	Get root patterns used for current document.

	Result could be something like: >

	{'global': ['.git', '.hg', '.projections.json'], 'buffer': [], 'server': v:null}
<
coc#util#get_config({key})				*coc#util#get_config()*

	Get configuration (mostly defined in coc-settings.json)	by {key},
	example: >

	:echo coc#util#get_config('coc.preferences')

coc#snippet#next() 					*coc#snippet#next()*

	Jump to next placeholder, does nothing when |coc#jumpable| is 0.

coc#snippet#prev() 					*coc#snippet#prev()*

	Jump to previous placeholder, does nothing when |coc#jumpable| is 0.

coc#float#has_float([{all}]) 				*coc#float#has_float()*

	Check if float window/popup exists, check coc.nvim's float
	window/popup by default.

coc#float#close_all([{all}])				*coc#float#close_all()*

	Close all float windows/popups created by coc.nvim, set {all} to `1`
	for all float window/popups.

coc#float#close({winid}) 				*coc#float#close()*

	Close float window/popup with {winid}.

coc#float#has_scroll() 					*coc#float#has_scroll()*

	Return `1` when there is scrollable float window/popup created by
	coc.nvim.

	Example key-mappings:
>
	if has('nvim-0.4.0') || has('patch-8.2.0750')
	  nnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
	  nnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
	  inoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(1)\<cr>" : "\<Right>"
	  inoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(0)\<cr>" : "\<Left>"
	  vnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
	  vnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
	endif
<
coc#float#scroll({forward}, [{amount}])			*coc#float#scroll()*

	Scroll all scrollable float windows/popups, scroll backward when
	{forward} is not `1`. {amount} could be number or full page when
	omitted.

	Note: this function requires nvim >= 0.4.0 or vim >= 8.2.750 to work.


CocRequest({id}, {method}, [{params}])			*CocRequest()*

	Send a request to language client of {id} with {method} and optional
	{params}. Example: >

	call CocRequest('tslint', 'textDocument/tslint/allFixes',
		\  {'textDocument': {'uri': 'file:///tmp'}})
<
	Vim error will be raised if the response contains an error.

							*CocRequestAsync()*

CocRequestAsync({id}, {method}, [{params}, [{callback}]])

	Send async request to remote language server.
	{callback} function is called with error and response.

CocNotify({id}, {method}, [{params}])			*CocNotify()*

	Send notification to remote language server, example:
>
	call CocNotify('ccls', '$ccls/reload')
<
							*CocRegistNotification()*

CocRegistNotification({id}, {method}, {callback})

	Register notification callback for specified client {id} and {method},
	example: >

	autocmd User CocNvimInit call CocRegistNotification('ccls',
		\ '$ccls/publishSemanticHighlight', function('s:Handler'))
<
	{callback} is called with single param as notification result.

	Note: when register notification with same {id} and {method}, only the
	later registered would work.

							*CocLocations()*

CocLocations({id}, {method}, [{params}, {openCommand}])

	Send location request to language client of {id} with
	{method} and optional {params}. eg: >

	call CocLocations('ccls', '$ccls/call',  {'callee': v:true})

	call CocLocations('ccls', '$ccls/call',  {}, 'vsplit')
<
	{openCommand}: optional command to open buffer, default to
	`coc.preferences.jumpCommand` , |:edit| by default.  When it's
	`v:false` locations list would always used.

							*CocLocationsAsync()*

CocLocationsAsync({id}, {method}, [{params}, {openCommand}])

	Same as |CocLocations()|, but send notification to server instead
	of request.


CocAction({action}, [...{args}])			*CocAction()*

	Run {action} of coc with optional extra {args}.

	Checkout |coc-actions| for available actions.

	Note: it's recommended to use |CocActionAsync()| unless you have to
	block your vim.

							*CocActionAsync()*

CocActionAsync({action}, [...{args}, [{callback}]])

	Call CocAction by send notification to server of coc.nvim.

	Optional callback is called with `error` as the first argument and
	`response` as the second argument.

	Checkout |coc-actions| for available actions.

CocHasProvider({feature})				*CocHasProvider()*

	Check if provider exists for specified feature of current buffer.
	Supported features:

	`rename` `onTypeEdit` `documentLink` `documentColor` `foldingRange`
	`format` `codeAction` `workspaceSymbols` `formatRange` `hover`
	`signature` `documentSymbol` `documentHighlight` `definition`
	`declaration` `typeDefinition` `reference` `implementation` `codeLens`
	`selectionRange`

CocTagFunc({pattern}, {flags}, {info})			*CocTagFunc()*

	Used for vim's 'tagfunc' option, to make tag search by |CTRL-]| use
	coc.nvim as provider, tag search would be performed when no result
	from coc.nvim.

	Make sure your vim support 'tagfunc' by
>
	:echo exists('&tagfunc')
<
							*coc#notify*
coc#notify#close_all()					*coc#notify#close_all()*

	Close all notification windows.

coc#notify#do_action([{winid}]) 			*coc#notify#do_action()*

	Invoke action for all notification windows, or particular window with
	winid.

	Use `"notification.preferMenuPicker": true` if you would like to
	choose action on notification shown.

coc#notify#copy() 					*coc#notify#copy()*

	Copy all content from notifications to system clipboard.

coc#notify#show_sources() 				*coc#notify#show_sources()*

	Show source name (extension name) in notification windows.

coc#notify#keep() 					*coc#notify#keep()*

	Stop auto hide timer of notification windows.

------------------------------------------------------------------------------
							*coc-actions*
Available Actions ~

Acceptable {action} names for |CocAction()| and |CocActionAsync|.

"ensureDocument" 					*CocAction('ensureDocument')*

	Ensure current document is attached to coc.nvim
	|coc-document-attached|, should be used when you need invoke action of
	current document on buffer create.

	Return |v:false| when document can't be attached.

"diagnosticList"					*CocAction('diagnosticList')*

	Get all diagnostic items of the current Neovim session.

"diagnosticInfo"					*CocAction('diagnosticInfo')*

	Show diagnostic message at the current position, do not truncate.

"diagnosticToggle" [{enable}]	 			*CocAction('diagnosticToggle')*

	Enable/disable diagnostics on the fly, not work when `displayByAle` is
	enabled. You can toggle by specifying {enable}. {enable} can be 0 or 1

"diagnosticPreview"					*CocAction('diagnosticPreview')*

	Show diagnostics under current cursor in preview window.

"diagnosticRefresh" [{bufnr}] 				*CocAction('diagnosticRefresh')*

	Force refresh diagnostics for special buffer with {bufnr} or all buffers
	when {bufnr} doesn't exist, returns `v:null` before diagnostics are shown.

	NOTE: Will refresh in any mode.

	Useful when `diagnostic.autoRefresh` is `false`.

"refreshSource" [{source}]				*CocAction('refreshSource')*

	refresh all sources or a source with a name of {source}.

"sourceStat"						*CocAction('sourceStat')*

	get the list of completion source stats for the current buffer.

"toggleSource" {source}					*CocAction('toggleSource')*

	enable/disable {source}.

"jumpDefinition" [{openCommand}]			*CocAction('jumpDefinition')*

	jump to definition locations of the current symbol.
	Return `v:false` when location not found.

	|coc-list-location| is used when more than one position is available,
	for custom location list, use variable: |g:coc_enable_locationlist|.

	To always use |coc-list-location|| for locations, use `v:false` for
	{openCommand}.

	{openCommand}: optional command to open buffer, default to
	`coc.preferences.jumpCommand` in `coc-settings.json`

"jumpDeclaration" [{openCommand}]			*CocAction('jumpDeclaration')*

	jump to declaration locations of the current symbol.
	Return `v:false` when location not found.

	same behavior as "jumpDefinition".

	When {openCommand} is `v:false`, location list would be always used.

"jumpImplementation" [{openCommand}]			*CocAction('jumpImplementation')*

	Jump to implementation locations of the current symbol.
	Return `v:false` when location not found.

	same behavior as "jumpDefinition"

"jumpTypeDefinition" [{openCommand}]			*CocAction('jumpTypeDefinition')*

	Jump to type definition locations of the current symbol.
	Return `v:false` when location not found.

	same behavior as "jumpDefinition"

"jumpReferences" [{openCommand}]			*CocAction('jumpReferences')*

	Jump to references locations of the current symbol, use
	|CocAction('jumpUsed')| to exclude declaration locations.

	Return `v:false` when location not found.

	same behavior as "jumpDefinition"

"jumpUsed" [{openCommand}] 				*CocAction('jumpUsed')*

	Jump references locations withtout declarations.

	same behavior as "jumpDefinition"

"getHover"						*CocAction('getHover')*

	Get documentation text array on current position, returns array of
	string.

"doHover" [{hoverTarget}]				*CocAction('doHover')*

	Show documentation of  current symbol, return `v:false` when hover not
	found.

	{hoverTarget}: optional specification for where to show hover info,
	defaults to `coc.preferences.hoverTarget` in `coc-settings.json`.
	Valid options: ["preview", "echo", "float"]

"definitionHover" [{hoverTarget}]			*CocAction('definitionHover')*

	Same as |CocAction('doHover')|, but includes definition contents from
	definition provider when possible.

"references" [{excludeDeclaration}] 			*CocAction('references')*

	Get references location list, declaration locations are included by
	default.

"showSignatureHelp"					*CocAction('showSignatureHelp')*

	Echo signature help of current function, return `v:false` when
	signature not found.  You may want to set up an autocmd like this: >

	autocmd User CocJumpPlaceholder call
				\ CocActionAsync('showSignatureHelp')
<
"getCurrentFunctionSymbol"				*CocAction('getCurrentFunctionSymbol')*

	Return the function string that current cursor in.

"documentSymbols" [{bufnr}]				*CocAction('documentSymbols')*

	Get a list of symbols of current buffer or specific {bufnr}.

"rename"						*CocAction('rename')*

	Rename the symbol under the cursor position, user will be prompted for
	a new name.

	Note: coc.nvim supports rename for disk files, but your language server
	may not.

"refactor"						*CocAction('refactor')*

	Open refactor windows with current symbol as activated cursor ranges.
	Check |coc-config-cursors| and |coc-config-refactor| for related
	configuration.

	Use <CR> to open buffer at current position in split window.
	Use <Tab> to show action menu which have tab open and remove actions.

"format"						*CocAction('format')*

	Format current buffer using the language server.
	Return `v:false` when format failed.

"formatSelected" [{mode}]				*CocAction('formatSelected')*

	Format the selected range, {mode} should be one of visual mode: `v` ,
	`V`, `char`, `line`.

	When {mode} is omitted, it should be called using |formatexpr|.


"selectionRanges"					*CocAction('selectionRanges')*

	Get selection ranges of current position from language server.

"services"						*CocAction('services')*

	Get an information list for all services.

"toggleService" {serviceId}				*CocAction('toggleService')*

	Start or stop a service.

"codeAction" [{mode}] [{only}]				*CocAction('codeAction')*

	Prompt for a code action and do it.

	{mode} could be `line` or `cursor` or result of |visualmode()|,
	current buffer range is used when it's empty string.

	{only} can be title of a codeAction or list of CodeActionKind.

"codeActionRange" {start} {end} [{kind}]		*CocAction('codeActionRange')*

	Run code action for range.

	{start} start line number of range.
	{end} end line number of range.
	{kind} code action kind, see |CocAction('codeActions')| for available
	action kind.

	Can be used to create commands like: >

	command! -nargs=* -range CocAction :call CocActionAsync('codeActionRange', <line1>, <line2>, <f-args>)
	command! -nargs=* -range CocFix    :call CocActionAsync('codeActionRange', <line1>, <line2>, 'quickfix')
<
"codeLensAction"					*CocAction('codeLensAction')*

	Invoke the command for codeLens of current line (or the line that
	contains codeLens just above). Prompt would be shown when multiple
	actions are available.

"commands"						*CocAction('commands')*

	Get a list of available service commands for the current buffer.

"runCommand" [{name}] [...{args}]			*CocAction('runCommand')*

	Run a global command provided by the language server. If {name} is not
	provided, a prompt with a list of commands is shown to be selected.

	{args} are passed as arguments of command.

	You can bind your custom command like so: >

	command! -nargs=0 OrganizeImport
		\ :call CocActionAsync('runCommand', 'tsserver.organizeImports')

"fold" {{kind}}						*CocAction('fold')*

	Fold the current buffer, optionally use {kind} for filtering folds,
	{kind} could be either 'comment', 'imports' or 'region'

	Return `v:false` when failed.

"highlight"						*CocAction('highlight')*

	Highlight the symbols under the cursor.

"openLink" [{command}]					*CocAction('openlink')*

	Open a link under the cursor with {command}.
	{command} default to `edit`.

	File and URL links are supported, return `v:false` when failed.

	Uri under cursor is searched when no link returned from documentLink
	provider.

"extensionStats"					*CocAction('extensionStats')*

	Get all extension states as a list. Including `id`, `root` and
	`state`.

	State could be `disabled`, `activated` and `loaded`.

"toggleExtension" {id}					*CocAction('toggleExtension')*

	Enable/disable an extension.

"uninstallExtension" {id}				*CocAction('uninstallExtension')*

	Uninstall an extension.

"reloadExtension" {id}					*CocAction('reloadExtension')*

	Reload an activated extension.

"activeExtension" {id}					*CocAction('activeExtension')*

	Activate extension of {id}.

"deactivateExtension" {id}				*CocAction('deactivateExtension')*

	Deactivate extension of {id}.

"pickColor"						*CocAction('pickColor')*

	Change the color at the current cursor position, requires
	`documentColor` provider |CocHasProvider|.

	Note: only works on mac or when you have python support on Vim and
	have the gtk module installed.

"colorPresentation"					*CocAction('colorPresentation')*

	Change the color presentation at the current color position, requires
	`documentColor` provider |CocHasProvider|.

"codeActions" [{mode}] [{only}]				*CocAction('codeActions')*

	Get codeActions list of current document.

	{mode} can be result of |visualmode()| for visual selected
	range.  When it's falsy value, current file is used as range.

	{only} can be array of codeActionKind, possible values including:
	 - 'refactor': Base kind for refactoring actions
	 - 'quickfix': base kind for quickfix actions
	 - 'refactor.extract': Base kind for refactoring extraction actions
	 - 'refactor.inline': Base kind for refactoring inline actions
	 - 'refactor.rewrite': Base kind for refactoring rewrite actions
	 - 'source': Base kind for source actions
	 - 'source.organizeImports': Base kind for an organize imports source
	   action
	 - 'source.fixAll': Base kind for auto-fix source actions

	{only} can also be string, which means filter by tilte of codeAction.

"organizeImport" 					*CocAction('organizeImport')*

	Run organize import codeAction for current buffer.
	Show warning when codeAction not found.

"fixAll" 						*CocAction('fixAll')*

	Run fixAll codeAction for current buffer.
	Show warning when codeAction not found.


"quickfixes" [{visualmode}]				*CocAction('quickfixes')*

	Get quickfix codeActions of current buffer.

	Add {visualmode} as second argument get quickfix actions with range of
	latest |visualmode()|

"doCodeAction" {codeAction}				*CocAction('doCodeAction')*

	Do a codeAction.

"doQuickfix"						*CocAction('doQuickfix')*

	Do the first preferred quickfix action on current line.

	Throw error when no quickfix action found.

"addRanges" {ranges}					*CocAction('addRanges')*

	Ranges must be provided as array of range type: https://git.io/fjiEG

"getWordEdit"						*CocAction('getWordEdit')*

	Get workspaceEdit of current word, language server used when possible,
	extract word from current buffer as fallback.

"getWorkspaceSymbols" {input}				*CocAction('getWorkspaceSymbols')*

	Get workspace symbols from {input}.

"resolveWorkspaceSymbol" {symbol} 			*CocAction('resolveWorkspaceSymbol')*

	Resolve location for workspace {symbol}.

"diagnosticToggleBuffer" [{bufnr}] [{enable}] 		*CocAction('diagnosticToggleBuffer')*

	Toggle diagnostics for specific buffer, current buffer is used when
	{bufnr} not provided. 0 for current buffer
	You can toggle by specifying {enable}. {enable} can be 0 or 1

	Note: this will only affect diagnostics shown in the UI, list of all
	diagnostics won't change.

"showOutline" [{keep}]					*CocAction('showOutline')*

	Show |coc-outline| for current buffer. Does nothing when outline
	window already shown for current buffer.

	{keep} override `"outline.keepWindow"` configuration when specified.
	Could be 0 or 1.

	Returns after window is shown (document symbol request is still in
	progress).

"hideOutline" 						*CocAction('hideOutline')*

	Close |coc-outline| on current tab.  Throws vim error when it can't
	be closed by vim.

"incomingCalls" [{CallHierarchyItem}] 			*CocAction('incomingCalls')*

	Retrieve incoming calls from {CallHierarchyItem} or current position
	when not provided.

"outgoingCalls" [{CallHierarchyItem}] 			*CocAction('outgoingCalls')*

	Retrieve outgoing calls from {CallHierarchyItem} or current position
	when not provided.

"showIncomingCalls"  					*CocAction('showIncomingCalls')*

	Show incoming calls of current function with |coc-tree|, see
	|coc-callHierarchy|

"showOutgoingCalls"  					*CocAction('showOutgoingCalls')*

	Show outgoing calls of current function with |coc-tree|.

"semanticHighlight" 					*CocAction('semanticHighlight')*

	Request semantic tokens highlight for current buffer.

"inspectSemanticToken" 					*CocAction('inspectSemanticToken')*

	Inspect semantic token information at cursor position.

"rangeSelect" {visualmode} {forward} 		 	*CocAction('rangeSelect')*

	Visual select previous or next code range, requires `selectionRange`
	provider.

	{visualmode} should be result of {visualmode} or "" for current cursor
	position.
	{forward} select backward when it's falsy value.

------------------------------------------------------------------------------
COMMANDS						*coc-commands*

:CocStart						*:CocStart*

	Start the coc.nvim server, do nothing if it's already started.

:CocRestart						*:CocRestart*

	Restart coc.nvim service.

	Use this command when you want coc to start all over again.

:CocDisable						*:CocDisable*

	Disable handling vim events.

:CocEnable						*:CocEnable*

	Enable handling vim events.

:CocConfig						*:CocConfig*

	Edit the user config file `.vim/coc-settings.json` in
	|coc#util#get_config_home()|

:CocLocalConfig						*:CocLocalConfig*

	Edit or create `.vim/coc-settings.json` in current workspace folder.

:CocInstall [{option}] {name} ...			*:CocInstall*

	Install one or more coc extensions.

	{option}: could be `-sync` for use blocked process to download instead
	of terminal.

	Examples: >

	" Install latest coc-omni
	:CocInstall coc-omni
	" Install coc-omni 1.0.0
	:CocInstall coc-omni@1.0.0
	" Install snippet extension from github
	:CocInstall https://github.com/dsznajder/vscode-es7-javascript-react-snippets
>
:CocUninstall {name}					*:CocUninstall*

	Uninstall an extension, use <tab> to complete the extension
	name.

:CocUpdate						*:CocUpdate*

	Update all coc extensions to the latest version.

:CocUpdateSync						*:CocUpdateSync*

	Block version of update coc extensions.

:CocRebuild						*:CocRebuild*

	Run `npm rebuild` for coc extensions.

	May be required when environment nodejs get upgraded.

:CocCommand {name} [{args}] ... 			*:CocCommand*

	Run a command contributed by extensions, use `<tab>` for name
	completion.

:CocOpenLog						*:CocOpenLog*

	Open log file of coc.nvim.

	Use environmental variable `NVIM_COC_LOG_FILE` for fixed log file.
	Note: the log would be cleared when coc.nvim started.

	Use environment variable `NVIM_COC_LOG_LEVEL` to change log level
	(default 'info', could be 'all', 'trace', 'debug', 'info',
	'warn', 'error', 'off').
	Use shell command: >

	export NVIM_COC_LOG_LEVEL=debug
<
	or add: >

	let $NVIM_COC_LOG_LEVEL='debug'
<
	to the beginning of your `.vimrc`

:CocInfo						*:CocInfo*

	Show version and log information in a split window, useful for
	submitting a bug report.

:CocDiagnostics	[height] 				*:CocDiagnostics*

	Open vim's |location-list| with diagnostics of current buffer.

:CocSearch 						*:CocSearch*

	Perform search by ripgrep https://github.com/BurntSushi/ripgrep,
	refactor window would be opened.

	Note: the search is performed on your files, so normally you should
	save your buffers before invoke this command.

	Common arguments for ripgrep:~

	`-e` `--regexp`: treat search pattern as regexp.
	`-F` `--fixed-strings`: treat search pattern as fixed string.
	`-L` `--follow`: follow symbolic links while traversing directories.
	`-g` `--glob` {GLOB}: Include or exclude files and directories for
	searching that match the given glob.
	`--hidden`: Search hidden files and directories.
	`--no-ignore-vcs`:  Don't respect version control ignore files
	(.gitignore, etc.).
	`--no-ignore`: Don't respect ignore files (.gitignore, .ignore, etc.).
	`-w` `--word-regexp`: Only show matches surrounded by word boundaries.
	`-S` `--smart-case`: Searches case insensitively if the pattern is all
	lowercase. Search case sensitively otherwise.
	`--no-config`: Never read configuration files.
	`-x` `--line-regexp`: Only show matches surrounded by line boundaries.

	Use `:man 1 rg` in your terminal for more details.

	Note: By default, hidden files and directories are skipped.

	Note: By default, vcs ignore files including `.gitignore` and
	`.ignore` are respected

	Escape arguments:~

	|<f-args>| is used to convert command line arguments to arguments of
	rg, which means you have to escape space for single argument. For
	example, if you want to search `import { Neovim` , you have to use:
>
	:CocSearch import\ \{\ Neovim
<
	The escape for `{` is required because rg use regexp be default, or:
>
	:CocSearch -F import\ {\ Neovim
<
	for strict match.

	Change and save:~

	Refactor session is started with searched patterns highlighted, just
	change the text and save refactor buffer to make changes across all
	related files. You can make any kind of changes, including add lines
	and remove lines.

:CocWatch [extension] 					*:CocWatch*

	Watch loaded [extension] for reload on file change, use <tab> for
	complete extension id.

:CocOutline 						*:CocOutline*

	Invoke |CocAction('showOutline')| by notification.

------------------------------------------------------------------------------
AUTOCMD							*coc-autocmds*

							*CocLocationsChange*

:autocmd User CocLocationsChange {command}

	For building a custom view of locations, set
	|g:coc_enable_locationlist| to 0 and use this autocmd with with
	|g:coc_jump_locations|

	For example, to disable auto preview of location list, use:
>
	let g:coc_enable_locationlist = 0
	autocmd User CocLocationsChange CocList --normal location
<
							*CocNvimInit*
:autocmd User CocNvimInit {command}

	Triggered after the coc services have started.

	If you want to trigger an action of coc after Vim has started, this
	autocmd should be used because coc is always started asynchronously.

							*CocStatusChange*

:autocmd User CocStatusChange {command}

	Triggered after `g:coc_status` changed, can be used for refresh
	stautsline.

							*CocDiagnosticChange*

:autocmd User CocDiagnosticChange {command}

	Triggered after the diagnostic status has changed.

	Could be used for updating the statusline.

							*CocJumpPlaceholder*

:autocmd User CocJumpPlaceholder {command}

	Triggered after a jump to a placeholder. Can be used for
	showing signature help like: >

	autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
<
							*CocOpenFloat*

:autocmd User CocOpenFloat {command}

	Triggered when a floating window is opened.  The window is not
	focused, use |g:coc_last_float_win| to get window id.

							*CocOpenFloatPrompt*

:autocmd User CocOpenFloatPrompt {command}

	Triggered when a floating prompt window is opened (triggered after
	CocOpenFloat).

							*CocTerminalOpen*
:autocmd User CocTerminalOpen {command}

	Triggered when the terminal is shown, can be used for adjusting the
	window height.

------------------------------------------------------------------------------

HIGHLIGHTS						*coc-highlights*

To customize a highlight, simply use |:highlight| command in your vimrc, like:
>
	" make error texts have a red color
	highlight CocErrorHighlight ctermfg=Red  guifg=#ff0000
<
Type |:highlight| command with group name to check current highlight.

Note: don't use `:hi default` for overwriting the highlights.

Note: user defined highlight commands should appear after the |:colorscheme|
command and use |ColorScheme| autocmd to make sure customized highlights works
after color scheme change.

Markdown related~

*CocBold* for bold text.
*CocItalic* for italic text.
*CocUnderline* for underlined text.
*CocStrikeThrough* for strikethrough text, like usage of deprecated API.
*CocMarkdownCode* for inline code in markdown content.
*CocMarkdownHeader* for markdown header in floating window/popup.
*CocMarkdownLink* for markdown link text in floating window/popup.

Diagnostics related~
							*coc-highlights-diagnostics*

*CocFadeOut* for faded out text, such as for highlighting unnecessary code.
*CocErrorSign* for error signs.
*CocWarningSign* for warning signs.
*CocInfoSign* for information signs.
*CocHintSign* for hint signs.
*CocErrorVirtualText* for error virtual text.
*CocWarningVirtualText* for warning virtual text.
*CocInfoVirtualText* for information virtual text.
*CocHintVirtualText* for hint virtual text.
*CocErrorHighlight* for error code range.
*CocWarningHighlight* for warning code range.
*CocInfoHighlight* for information code range.
*CocHintHighlight* for hint code range.
*CocDeprecatedHighlight* for deprecated code range, links to
|CocStrikeThrough| by default.
*CocUnusedHighlight* for unnecessary code range, links to |CocFadeOut| by
default.
*CocErrorLine* line highlight of sign which contains error.
*CocWarningLine* line highlight of sign which contains warning.
*CocInfoLine* line highlight of sign which information.
*CocHintLine* line highlight of sign which contains hint.

Highlight with higher priority would overwrite highlight with lower priority.
The priority order:

	|CocUnusedHighlight| > |CocDeprecatedHighlight| > |CocErrorHighlight|
	> |CocWarningHighlight| > |CocInfoHighlight| > |CocHintHighlight|

Document highlight related~
							*coc-highlights-document*

Highlights used for highlighting same symbols in the buffer at the current
cursor position.

*CocHighlightText* default symbol highlight.
*CocHighlightRead* for `Read` kind of document symbol.
*CocHighlightWrite* for `Write` kind of document symbol.

Float window/popup related~

*CocFloating* default highlight group of floating windows/popups.
Default link to |NormalFloat| on neovim and|`Pmenu| on vim.
*CocErrorFloat* for errors in floating windows/popups.
*CocWarningFloat* for warnings in floating windows/popups.
*CocInfoFloat* for infos in floating windows/popups.
*CocHintFloat* for hints in floating windows/popups.

Notification window/popup related~

CocNotification 					*CocNotification*

*CocNotificationProgress* for progress line in progress notification.
*CocNotificationButton* for action buttons in notification window.
*CocNotificationError* for highlight border of error notification.
*CocNotificationWarning* for highlight border of warning notification.
*CocNotificationInfo* for highlight border of info notification.

List related~
							*coc-highlights-list*

*CocListLine* for current cursor line.
*CocListSearch* for matched characters.
*CocListMode* for mode text in the statusline.
*CocListPath* for cwd text in the statusline.
*CocSelectedText* for sign text of selected lines (multiple selection only).
*CocSelectedLine* for line highlight of selected lines (multiple selection only).

Tree view related~

CocTree 						*CocTree*

*CocTreeTitle* for title in tree view.
*CocTreeDescription* for description beside label.
*CocTreeOpenClose* for open and close icon in tree view.
*CocTreeSelected* for highlight lines contains selected node.

Symbol icons~

CocSymbol 						*CocSymbol*

Highlight groups for symbol icons, including:

*CocSymbolFile*
*CocSymbolModule*
*CocSymbolNamespace*
*CocSymbolPackage*
*CocSymbolClass*
*CocSymbolMethod*
*CocSymbolProperty*
*CocSymbolField*
*CocSymbolConstructor*
*CocSymbolEnum*
*CocSymbolInterface*
*CocSymbolFunction*
*CocSymbolVariable*
*CocSymbolConstant*
*CocSymbolString*
*CocSymbolNumber*
*CocSymbolBoolean*
*CocSymbolArray*
*CocSymbolObject*
*CocSymbolKey*
*CocSymbolNull*
*CocSymbolEnumMember*
*CocSymbolStruct*
*CocSymbolEvent*
*CocSymbolOperator*
*CocSymbolTypeParameter*
*CocSymbolDefault*

Note: Use configuration `suggest.completionItemKindLabels` for customized icon
characters.

Semantic token highlight groups~
								*CocSem*

Semantic highlight groups are starts with `CocSem` which links to related
|nvim-treesitter| highlight groups when possible and fallback to builtin
highlight groups, use variable |g:coc_default_semantic_highlight_groups| to
disable creation of these highlight groups.

Only semantic tokens types and `deprecated` modifier have default
highlight groups.

You need create highlight groups for highlight other modifiers and/or specific
modifier with type, for example:
>
	" Add highlights for defaultLibrary modifier
	hi link CocSemDefaultLibrary TSOtherDefaultLibrary
	hi link CocSemDefaultLibraryClass TSTypeDefaultLibrary
	hi link CocSemDefaultLibraryInterface TSTypeDefaultLibrary
	hi link CocSemDefaultLibraryEnum TSTypeDefaultLibrary
	hi link CocSemDefaultLibraryType TSTypeDefaultLibrary
	hi link CocSemDefaultLibraryNamespace TSTypeDefaultLibrary

	" Add highlights for declaration modifier
	hi link CocSemDeclaration TSOtherDeclaration
	hi link CocSemDeclarationClass TSTypeDeclaration
	hi link CocSemDeclarationInterface TSTypeDeclaration
	hi link CocSemDeclarationEnum TSTypeDeclaration
	hi link CocSemDeclarationType TSTypeDeclaration
	hi link CocSemDeclarationNamespace TSTypeDeclaration
<
The modifier highlight groups have higher priority.

Others~

*CocSearch* highlight group for matched characters in list.
*CocDisabled* highlight for disabled items, eg: menu item.
*CocCodeLens* for virtual text of codeLens.
*CocCursorRange* for highlight of activated cursors ranges.
*CocLinkedEditing* for highlight of activated linked editing ranges.
*CocHoverRange* for range of current hovered symbol.
*CocMenuSel* for current menu item in menu dialog.
*CocSelectedRange* for highlight ranges of outgoing calls.
*CocSnippetVisual* for highlight snippet placeholders.
*CocInlayHint* for highlight inlay hint virtual text block, default linked to
|CocHintSign|

==============================================================================
TREE SUPPORT 						*coc-tree*

Tree view is used for render outline and call hierarchy, following features
are supported:

- Data update while keep tree node open/close state.
- Auto refresh on load error.
- Click open/close icon to toggle collapse state.
- Click node to invoke default command.
- Show tooltip in float window on |CursorHold| when possible.
- Key-mappings support |coc-tree-mappings|
- Optional multiple selection.
- Optional node reveal support.
- Optional fuzzy filter support.
- Provide api `window.createTreeView` for extensions.

Check |coc-config-tree| for related configurations.

The filetype is `'coctree'`, which can be used to overwrite buffer and window
options.

Use variable |w:cocViewId| to detect the kind of tree.

------------------------------------------------------------------------------

TREE KEY MAPPINGS 					*coc-tree-mappings*

Default key-mappings are provided for 'coctree' buffer, which can be changed
by configuration |coc-config-tree|.

<space> - Select/unselect item, configured by `"tree.key.toggleSelection"`.
<tab> 	- Invoke actions of current item, configured by `"tree.key.actions"`.
<esc>   - Close tree window, configured by `"tree.key.close"`.
<cr>    - Invoke command of current item,  configured by `"tree.key.invoke"`.
<C-o>   - Move cursor to original window.
f 	- Activate filter, configured by `"tree.key.activeFilter"`.
t 	- Trigger key to toggle expand state of tree node, configured by
	`tree.key.toggle`.
M 	- Collapse all tree node, configured by `"tree.key.collapseAll"`.

------------------------------------------------------------------------------

TREE FILTER 						*coc-tree-filter*

Filter mode is used for search for specific node by fuzzy filter, invoke the
key configured by `"tree.key.activeFilter"` to activate filter mode.

Note: some tree views not have filter mode supported.

When filter mode is activated, type normal character to insert filter input
and following special keys are supported:

<bs> 	- Delete last filter character when possible.
<C-h> 	- Delete last filter character when possible.
<C-u> 	- Clean up filter text.
<C-p> 	- Navigate to previous filter text (stored on command invoke).
<C-n> 	- Navigate to next filter text (stored on command invoke).
<esc> 	- exit filter mode.
<C-o> 	- exit filter mode.
<up> or `"tree.key.selectPrevious"` 	- Select previous node.
<down> or `"tree.key.selectNext"` 	- Select next node.
<cr> or `"key.key.invoke"` 	- Invoke command of selected node.

==============================================================================
LIST SUPPORT						*coc-list*

Built-in list support to make working with lists of items easier.

The following features are supported:

- Insert & normal mode.
- Default key-mappings for insert & normal mode.
- Customize key-mappings for insert & normal mode.
- Commands for reopening & doing actions with a previous list.
- Different match modes.
- Interactive mode.
- Auto preview on cursor move.
- Number select support.
- Built-in actions for locations.
- Parse ANSI code.
- Mouse support.
- Select actions using <tab>.
- Multiple selections using <space> in normal mode.
- Select lines by visual selection.

------------------------------------------------------------------------------

LIST COMMAND						*coc-list-command*

:CocList [{...options}] [{source}] [{...args}]		*:CocList*

	Open coc list of {source}, example: >

	:CocList --normal location
<
	For current jump locations.

	See |coc-list-options| for available list options,

	Also check |coc-config-list| for list configuration.

	{args} are sent to source during the fetching of list.
	Press `?` on normal mode to get supported {args} of current
	list.

	When {source} is empty, lists source is used.

:CocListResume [{name}]					*:CocListResume*

	Reopen last opened list, input and cursor position will be preserved.

:CocListCancel						*:CocListCancel*

	Close list, useful when the list is not the current window.

:CocPrev [{name}]					*:CocPrev*

	Invoke default action for the previous item in the last {name} list.

	Doesn't open the list window if it's closed.

:CocNext [{name}]					*:CocNext*

	Invoke the default action for the next item in the last {name} list.

	Doesn't open the list window if it's closed.

:CocFirst [{name}]					*:CocFirst*

	Invoke default action for first item in the last {name} list.

:CocLast [{name}]					*:CocLast*

	Invoke default action for last item in the last {name} list.

							*coc-list-options*
Options of CocList command~

--top
	Show list as top window.

--tab
	Open list in new tabpage.

--normal

	Start list in normal mode, recommended for short list.

--no-sort
	Disable sort made by fuzzy score or most recently used, use it when
	it's already sorted.

--input={input}

	Specify the input on session start.

--strict
-S
	Use strict matching instead of fuzzy matching.

--regex
-R
	Use regex matching instead of fuzzy matching.

--ignore-case

	Ignore case when using strict matching or regex matching.

--number-select
-N
	Type a line number to select an item and invoke the default action on
	insert mode. Type `0` to select the 10th line.


--interactive
-I
	Use interactive mode, list items would be reloaded on input
	change, filter and sort would be done by list implementation.

	Note: filtering and sorting would be done by underlying task, which
	means options including `--strict`, `--no-sort`, `--regex`,
	`--ignore-case` would not work at all.

	Note: it requires list implementation have support for interactive
	mode.

--auto-preview
-A

	Start a preview for the current item on the visible list.

--no-quit

	Not quit list session after do action.

	Note: you may need to refresh the list for current state.

--first

	Invoke default action for first list item on list open.
	Nothing happens when the list is empty.

--reverse

	Reverse lines order of list.

------------------------------------------------------------------------------

LIST CONFIGURATION					*coc-list-configuration*

Use `coc-settings.json` for configuration of lists.

The general configuration of list starts with 'list.'.

Checkout |coc-config-list| or type `list.` in your settings file to get completion
list (requires coc-json installed).

For configuration of a specified list, use section that starts with:
`list.source.{name}`, where `{name}` is the name of list.

Change default action:~

If you want to use `tabe` as default action of symbols list, you can use:
>
	// change default action of symbols
	"list.source.symbols.defaultAction": "tabe"
<
in your coc-settings.json

Change default options:~

Use `list.source.{name}.defaultOptions` setting like: >

	// make symbols list use normal mode and interactive by default
	"list.source.symbols.defaultOptions": ["--interactive", "--number-select"],
<
Note: some list like symbols only work in interactive mode, you must
include `--interactive` in `defaultOptions`.

Note: default options will not be used when there're options passed
with |:CocList| command.

Change default arguments:~

Use `list.source.{name}.defaultArgs` setting like: >

	// use regex match for grep source
	"list.source.grep.defaultArgs": ["-regex"],

Note: default arguments used only when arguments from |:CocList| command is
empty.

Note: Type `?` on normal mode to get supported arguments of current list.

------------------------------------------------------------------------------

LIST MAPPINGS						*coc-list-mappings*

Default mappings on insert mode:

<Esc>       - Cancel list session.
<CR>        - Do default action with selected items or current item.
<C-c>       - Stop loading task.
<C-v>       - Paste text from system clipboard.
<C-l>       - Reload list.
<C-o>       - Change to normal mode.
<Down>      - Select next line.
<Up>        - Select previous line.
<Left>      - Move cursor left.
<Right>     - Move cursor right.
<End>       - Move cursor to end of prompt.
<C-e>       - Same as <End>.
<Home>      - Move cursor to start of prompt.
<C-a>       - Same as <Home>.
<C-f>       - Scroll window forward.
<C-b>       - Scroll window backward.
<Backspace> - Remove previous character of cursor.
<C-h>       - Remove previous character of cursor.
<C-w>       - Remove previous word of cursor.
<C-u>       - Remove characters before cursor.
<C-n>       - Navigate to next input in history.
<C-p>       - Navigate to previous input in history.
<C-s>       - Switch matcher for filter items.
<C-r>       - Insert content from vim's register.
<Tab>       - Select action.

Default mappings on normal mode:

<Esc>       - Cancel list session.
<CR>        - Do default action with selected items or current item.
<C-c>       - Stop source from fetching more items.
<C-l>       - Reload list.
<C-a>       - Mark all visible items selected.
<C-o>       - Jump to original window on list create.
<Tab>       - Select action.
<C-e> 	    - Scroll preview window down.
<C-y> 	    - Scroll preview window up.
<Space>     - Toggle select of current item.
i,I,o,O,a,A - Change to insert mode.
p           - Preview action.
:           - Cancel list session without closing window.
?           - Show help of current list.
t           - Do 'tabe' action.
d           - Do 'drop' action.
s           - Do 'split' action.

Use |coc-list-mappings-custom| to override default mappings.

							*coc-list-mappings-custom*

Configurations `"list.normalMappings"` and `"list.insertMappings"` are used
for customizing the list key-mappings, example: >

	"list.insertMappings": {
		"<C-r>": "do:refresh",
		"<C-f>": "feedkeys:\\<C-f>",
		"<C-b>": "feedkeys:\\<C-b>",
		"<C-n>": "normal:j",
		"<C-p>": "normal:k",
		"<C-t>": "action:tabe",
		"<C-x>": "call:MyFunc",
		// paste yanked text to prompt
		"<C-v>": "eval:@@"
	}
	"list.normalMappings": {
		"c": "expr:MyExprFunc"
		"d": "action:delete"
	}
<
Note: you should only use mappings that start with `<C-` or `<A-` for insert
mappings.

Note: <Esc> can't be remapped for other actions.

The mapping expression should be `command:arguments`, available commands:

'do' - special actions provided by coc list, including:
	'refresh'       - reload list.
	'selectall'     - mark all visible items selected.
	'switch'        - switch matcher used for filter items.
	'exit'          - exit list session.
	'stop'          - stop loading task.
	'cancel'        - cancel list session but leave list window open.
	'toggle'        - toggle selection of current item.
	'togglemode'    - toggle between insert and normal mode.
	'previous'      - move cursor to previous item.
	'next'          - move cursor to next item.
	'defaultaction' - do default action for selected item(s).
	'chooseaction'  - choose action for selected item(s).
	'jumpback'      - stop prompt and jump back to original window.
	'previewtoggle' - toggle preview window, requires preview action exists.
	'previewup'     - scroll preview window up.
	'previewdown'   - scroll preview window down.
	'help'          - show help.
'prompt' - do prompt action, including:
	'previous' - change to previous input in history.
	'next'           - change to next input in history.
	'start'          - move cursor to start.
	'end'            - move cursor to end.
	'left'           - move cursor left.
	'right'          - move cursor right.
	'deleteforward'  - remove previous character.
	'deletebackward' - remove next character.
	'removetail'     - remove characters afterwards.
	'removeahead'    - remove character ahead.
	'removeword'     - remove word before cursor.
	'insertregister' - insert content from Vim register.
	'paste'          - append text from system clipboard to prompt.
'eval'     - append text to prompt from result of VimL expression.
'action'   - execute action of list, use <tab> to find available actions.
'feedkeys' - feedkeys to list window, use `\\` in JSON to escape special
             characters.
'normal'   - execute normal command in list window.
'normal!'  - execute normal command without remap.
'command'  - execute command.
'call'     - call Vim function with |coc-list-context| as only argument.
'expr'     - same as 'call' but expect the function return action name.

							*coc-list-context*

Context argument contains the following properties:

'name'    - name of the list, example: `'location'`.
'args'    - arguments of the list.
'input'   - current input of prompt.
'winid'   - window id on list activated.
'bufnr'   - buffer number on list activated.
'targets' - list of selected targets, checkout |coc-list-target| for properties.

							*coc-list-target*

Target contains the following properties:

'label'      - mandatory property that is shown in the buffer.
'filtertext' - optional filter text used for filtering items.
'location'   - optional location of item, check out https://bit.ly/2Rtb6Bo
'data'       - optional additional properties.

------------------------------------------------------------------------------

LIST SOURCES						*coc-list-sources*

------------------------------------------------------------------------------

location						*coc-list-location*

	Last jump locations.

	Actions:

	- 'preview' : preview location in preview window.
	- 'open': open location by use
		`"coc.preferences.jumpCommand"`, default action
	- 'tabe': Use |:tabe| to open location.
	- 'drop': Use |:drop| to open location.
	- 'vsplit': Use |:vsplit| to open location.
	- 'split': Use |:split| to open location.
	- 'quickfix': Add selected items to Vim's quickfix.

extensions						*coc-list-extensions*

	Manage coc.nvim extensions.

	Actions:

	- 'toggle' activate/deactivate extension, default action.
	- 'disable' disable extension.
	- 'enable' enable extension.
	- 'lock' lock/unlock extension to current version.
	- 'doc' view extension's README doc.
	- 'fix' fix dependencies in terminal buffer.
	- 'reload' reload extension.
	- 'uninstall' uninstall extension.

diagnostics						*coc-list-diagnostics*

	All diagnostics for the workspace.

	Actions:

	- Same as |coc-list-location|

folders 						*coc-list-folders*

	Manage current workspace folders of coc.nvim.

	Actions:

	- 'edit' change the directory of workspace folder.
	- 'delete' remove selected workspace folder.

outline							*coc-list-outline*

	Symbols in the current document.

	Actions:

	- Same as |coc-list-location|

symbols							*coc-list-symbols*

	Search workspace symbols.

	Actions:

	- Same as |coc-list-location|

services						*coc-list-services*

	Manage registered services.

	Actions:

	- 'toggle': toggle service state, default action.

commands						*coc-list-commands*

	Workspace commands.

	Actions:

	- 'run': run selected command, default action.

links							*coc-list-links*

	Links in the current document.

	Actions:

	- 'open': open the link, default action.
	- 'jump': jump to link definition.

sources							*coc-list-completion-sources*

	Available completion sources.

	Actions:

	- 'toggle': activate/deactivate source, default action.
	- 'refresh': refresh source.
	- 'open': open the file where source defined.

lists							*coc-list-lists*

	Get available lists.

	Actions:

	- 'open': open selected list, default action.

==============================================================================

DIALOG SUPPORT						*coc-dialog*

Dialog is special float window/popup that could response to user actions,
dialog have close button, border, title (optional), bottom buttons(optional).

Note bottom buttons work different on neovim and vim, on neovim you can
click the button since neovim allows focus of window, on vim you have to type
highlighted character to trigger button callback.

Note dialog feature requires neovim >= 0.4.0 or vim >= 8.2.0750 to work.

See |coc-config-dialog| for available configurations.

------------------------------------------------------------------------------

							*coc-dialog-basic*

A basic dialog is create by javascript api `window.showDialog` , which is just
some texts with optional buttons.

------------------------------------------------------------------------------

							*coc-dialog-confirm*

A confirm dialog is used for user to confirm an action, normally created by
`window.showPrompt()` Confirm dialog uses filter feature on vim8 and
|getchar()| on neoivm.

The difference is you can operate vim on vim8, but not on neovim.

Supported key-mappings:

<C-c>         - force cancel, return -1 for callback.
<esc>, n, N   - reject the action, return 0 for callback.
y,Y           - accept the action, return 1 for callback.

------------------------------------------------------------------------------

							*coc-dialog-input*

An input dialog request user input with optional default value, normally
created by `window.requestInput`, when `"coc.preferences.promptInput"` is
false, vim's commandline input prompt is used instead.

On neovim, it uses float window, on vim8, it opens terminal in popup.

Supported key-mappings:

<C-a>               - move cursor to first col.
<C-e>               - move cursor to last col.
<esc>               - cancel input, null is received by callback.
<cr>                - accept current input selection of current item.

QuickPick related (available when created by |coc-dialog-quickpick|).

<C-f>               - scroll forward quickpick list.
<C-b>               - scroll backward quickpick list.
<C-j> <C-n> <down>  - move to next item in quickpick list.
<C-k> <C-p> <up>    - move to previous item in quickpick list.
<C-space>           - toggle selection of current item in quickpick list when
canSelectMany is supported.

Note on neovim, other insert mode key-mappings could work.

Note not possible to configure key-mappings on vim8, to customize key-mappings
on neovim, use |CocOpenFloatPrompt| with current buffer.

------------------------------------------------------------------------------

							*coc-dialog-quickpick*

A quickpick is a input dialog in the middle with a float window/popup contains
filtred list items.

A simple fuzzy filter is used by default.

See |coc-config-dialog| for available configurations.

See |coc-dialog-input| for available key-mappings.

------------------------------------------------------------------------------

							*coc-dialog-menu*

A menu dialog is shown aside current cursor position for pick a single item
from list of items, extensions could use `window.showMenuPicker` to create menu
dialog.

Supported key-mappings:

<Esc> <C-c>          - cancel selection.
<cr>                 - confirm selection of current item, use
|dialog.confirmKey| to override.
1-9                  - select item with 1 based index.
g                    - move to first item.
G                    - move to last item.
j <tab> <down> <C-n> - move to next item.
k <s-tab> <up> <C-p> - move to previous item.
<C-f>                - scroll forward.
<C-b>                - scroll backward.

------------------------------------------------------------------------------

							*coc-dialog-picker*

A picker dialog is used for multiple selection. On neovim, it's possible to
toggle selection by mouse click inside the bracket. Extensions could use
`window.showPickerDialog` to create picker dialog.

Supported key-mappings:

<Esc> <C-c>          - cancel selection.
<cr>                 - confirm selection of current item, use
|dialog.confirmKey| to override.
<space>              - toggle selection of current item.
g                    - move to first item.
G                    - move to last item.
j <tab> <down> <C-n> - move to next item.
k <s-tab> <up> <C-p> - move to previous item.
<C-f>                - scroll forward.
<C-b>                - scroll backward.

Note when close button is clicked, the selection is canceled with undefined
result (same as <esc>).

==============================================================================

NOTIFICATION SUPPORT					*coc-notification*

Notification windows are shown from bottom right of the screen. Notifications
behavior like notifications on VSCode.

Notifications are created by javascript APIs: `window.showErrorMessage()`,
`window.showWarningMessage()`, `window.showInformationMessage()`,
`window.showNotification()` and `window.withProgress()`.

Possible kind of notifications: 'error', 'warning', 'info' and 'progress'.

Message notifications (not progress) requires
|coc-preferences-enableMessageDialog| to be `true`. Message notifications
without actions would be automatically closed after milliseconds specified by
|coc-config-notification-timeout|.

Features:

- Animated position and 'winblend' on show and hide.
- Reposition current tab notification windows when notification dismissed.
- Notification with same options will be replaced to avoid duplicated windows.
- Percent and message update for progress notification.
- Click the button (neovim only) or use |coc#notify#do_action()| to invoke
  actions.
- Click the window would cancel auto close (on neovim and focusable is true).
- For customize icons, see |g:coc_notify|.
- For customize highlights, see |CocNotification|.
- For customize other behaviors, see |coc-config-notification|.
- For available user actions (ex: "close_all", "do_action" "show_sources"), see
  |coc#notify|.

Note notification feature requires neovim >= 0.4.0 or vim >= 8.2.0750 to work.

==============================================================================

STATUSLINE SUPPORT					*coc-status*

Diagnostics info and other status info contributed by extensions could be
shown in statusline.

The easiest way is add `%{coc#status()}` to your 'statusline' option. Example: >

	set statusline^=%{coc#status()}
>
------------------------------------------------------------------------------

							*coc-status-manual*

Create function:
>
	function! StatusDiagnostic() abort
	  let info = get(b:, 'coc_diagnostic_info', {})
	  if empty(info) | return '' | endif
	  let msgs = []
	  if get(info, 'error', 0)
	    call add(msgs, 'E' . info['error'])
	  endif
	  if get(info, 'warning', 0)
	    call add(msgs, 'W' . info['warning'])
	  endif
	  return join(msgs, ' ') . ' ' . get(g:, 'coc_status', '')
	endfunction
<
Add `%{StatusDiagnostic()}` to your 'statusline' option.

------------------------------------------------------------------------------

							*coc-status-airline*

With vim-airline: https://github.com/vim-airline/vim-airline

Error and warning display should work in vim-airline out of box.

Disable vim-airline integration:
>
	let g:airline#extensions#coc#enabled = 0
<
Change error symbol:
>
	let airline#extensions#coc#error_symbol = 'Error:'
<
Change warning symbol:
>
	let airline#extensions#coc#warning_symbol = 'Warning:'
<
Change error format:
>
	let airline#extensions#coc#stl_format_err = '%E{[%e(#%fe)]}'
<
Change warning format:
>
	let airline#extensions#coc#stl_format_warn = '%W{[%w(#%fw)]}'
<
------------------------------------------------------------------------------
							*coc-status-lightline*

With lightline.vim: https://github.com/itchyny/lightline.vim

Use configuration like: >

  let g:lightline = {
	\ 'colorscheme': 'wombat',
	\ 'active': {
	\   'left': [ [ 'mode', 'paste' ],
	\             [ 'cocstatus', 'readonly', 'filename', 'modified' ] ]
	\ },
	\ 'component_function': {
	\   'cocstatus': 'coc#status'
	\ },
	\ }

  " Use autocmd to force lightline update.
  autocmd User CocStatusChange,CocDiagnosticChange call lightline#update()
<
==============================================================================
CUSTOM SOURCE						*coc-custom-source*

Creating a custom source in VimL is supported.

Check out https://github.com/neoclide/coc.nvim/wiki/Create-custom-source

==============================================================================
FAQ							*coc-faq*

------------------------------------------------------------------------------

Check out https://github.com/neoclide/coc.nvim/wiki/F.A.Q

==============================================================================
CHANGELOG						*coc-changelog*

See history.md under project root.

==============================================================================
vim:tw=78:nosta:noet:ts=8:sts=0:ft=help:noet:fen:
